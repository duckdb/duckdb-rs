/* automatically generated by rust-bindgen 0.69.4 */

pub const DUCKDB_API_0_3_1: u32 = 1;
pub const DUCKDB_API_0_3_2: u32 = 2;
pub const DUCKDB_API_LATEST: u32 = 2;
pub const DUCKDB_API_VERSION: u32 = 2;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__fsid_t), "::", stringify!(__val))
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub const DUCKDB_TYPE_DUCKDB_TYPE_INVALID: DUCKDB_TYPE = 0;
pub const DUCKDB_TYPE_DUCKDB_TYPE_BOOLEAN: DUCKDB_TYPE = 1;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TINYINT: DUCKDB_TYPE = 2;
pub const DUCKDB_TYPE_DUCKDB_TYPE_SMALLINT: DUCKDB_TYPE = 3;
pub const DUCKDB_TYPE_DUCKDB_TYPE_INTEGER: DUCKDB_TYPE = 4;
pub const DUCKDB_TYPE_DUCKDB_TYPE_BIGINT: DUCKDB_TYPE = 5;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UTINYINT: DUCKDB_TYPE = 6;
pub const DUCKDB_TYPE_DUCKDB_TYPE_USMALLINT: DUCKDB_TYPE = 7;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UINTEGER: DUCKDB_TYPE = 8;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UBIGINT: DUCKDB_TYPE = 9;
pub const DUCKDB_TYPE_DUCKDB_TYPE_FLOAT: DUCKDB_TYPE = 10;
pub const DUCKDB_TYPE_DUCKDB_TYPE_DOUBLE: DUCKDB_TYPE = 11;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIMESTAMP: DUCKDB_TYPE = 12;
pub const DUCKDB_TYPE_DUCKDB_TYPE_DATE: DUCKDB_TYPE = 13;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIME: DUCKDB_TYPE = 14;
pub const DUCKDB_TYPE_DUCKDB_TYPE_INTERVAL: DUCKDB_TYPE = 15;
pub const DUCKDB_TYPE_DUCKDB_TYPE_HUGEINT: DUCKDB_TYPE = 16;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UHUGEINT: DUCKDB_TYPE = 32;
pub const DUCKDB_TYPE_DUCKDB_TYPE_VARCHAR: DUCKDB_TYPE = 17;
pub const DUCKDB_TYPE_DUCKDB_TYPE_BLOB: DUCKDB_TYPE = 18;
pub const DUCKDB_TYPE_DUCKDB_TYPE_DECIMAL: DUCKDB_TYPE = 19;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIMESTAMP_S: DUCKDB_TYPE = 20;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIMESTAMP_MS: DUCKDB_TYPE = 21;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIMESTAMP_NS: DUCKDB_TYPE = 22;
pub const DUCKDB_TYPE_DUCKDB_TYPE_ENUM: DUCKDB_TYPE = 23;
pub const DUCKDB_TYPE_DUCKDB_TYPE_LIST: DUCKDB_TYPE = 24;
pub const DUCKDB_TYPE_DUCKDB_TYPE_STRUCT: DUCKDB_TYPE = 25;
pub const DUCKDB_TYPE_DUCKDB_TYPE_MAP: DUCKDB_TYPE = 26;
pub const DUCKDB_TYPE_DUCKDB_TYPE_ARRAY: DUCKDB_TYPE = 33;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UUID: DUCKDB_TYPE = 27;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UNION: DUCKDB_TYPE = 28;
pub const DUCKDB_TYPE_DUCKDB_TYPE_BIT: DUCKDB_TYPE = 29;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIME_TZ: DUCKDB_TYPE = 30;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIMESTAMP_TZ: DUCKDB_TYPE = 31;
#[doc = "! An enum over DuckDB's internal types."]
pub type DUCKDB_TYPE = ::std::os::raw::c_uint;
#[doc = "! An enum over DuckDB's internal types."]
pub use self::DUCKDB_TYPE as duckdb_type;
pub const duckdb_state_DuckDBSuccess: duckdb_state = 0;
pub const duckdb_state_DuckDBError: duckdb_state = 1;
#[doc = "! An enum over the returned state of different functions."]
pub type duckdb_state = ::std::os::raw::c_uint;
pub const duckdb_pending_state_DUCKDB_PENDING_RESULT_READY: duckdb_pending_state = 0;
pub const duckdb_pending_state_DUCKDB_PENDING_RESULT_NOT_READY: duckdb_pending_state = 1;
pub const duckdb_pending_state_DUCKDB_PENDING_ERROR: duckdb_pending_state = 2;
pub const duckdb_pending_state_DUCKDB_PENDING_NO_TASKS_AVAILABLE: duckdb_pending_state = 3;
#[doc = "! An enum over the pending state of a pending query result."]
pub type duckdb_pending_state = ::std::os::raw::c_uint;
pub const duckdb_result_type_DUCKDB_RESULT_TYPE_INVALID: duckdb_result_type = 0;
pub const duckdb_result_type_DUCKDB_RESULT_TYPE_CHANGED_ROWS: duckdb_result_type = 1;
pub const duckdb_result_type_DUCKDB_RESULT_TYPE_NOTHING: duckdb_result_type = 2;
pub const duckdb_result_type_DUCKDB_RESULT_TYPE_QUERY_RESULT: duckdb_result_type = 3;
#[doc = "! An enum over DuckDB's different result types."]
pub type duckdb_result_type = ::std::os::raw::c_uint;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_INVALID: duckdb_statement_type = 0;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_SELECT: duckdb_statement_type = 1;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_INSERT: duckdb_statement_type = 2;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_UPDATE: duckdb_statement_type = 3;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_EXPLAIN: duckdb_statement_type = 4;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_DELETE: duckdb_statement_type = 5;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_PREPARE: duckdb_statement_type = 6;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_CREATE: duckdb_statement_type = 7;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_EXECUTE: duckdb_statement_type = 8;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_ALTER: duckdb_statement_type = 9;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_TRANSACTION: duckdb_statement_type = 10;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_COPY: duckdb_statement_type = 11;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_ANALYZE: duckdb_statement_type = 12;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_VARIABLE_SET: duckdb_statement_type = 13;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_CREATE_FUNC: duckdb_statement_type = 14;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_DROP: duckdb_statement_type = 15;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_EXPORT: duckdb_statement_type = 16;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_PRAGMA: duckdb_statement_type = 17;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_VACUUM: duckdb_statement_type = 18;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_CALL: duckdb_statement_type = 19;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_SET: duckdb_statement_type = 20;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_LOAD: duckdb_statement_type = 21;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_RELATION: duckdb_statement_type = 22;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_EXTENSION: duckdb_statement_type = 23;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_LOGICAL_PLAN: duckdb_statement_type = 24;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_ATTACH: duckdb_statement_type = 25;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_DETACH: duckdb_statement_type = 26;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_MULTI: duckdb_statement_type = 27;
#[doc = "! An enum over DuckDB's different statement types."]
pub type duckdb_statement_type = ::std::os::raw::c_uint;
#[doc = "! DuckDB's index type."]
pub type idx_t = u64;
#[doc = "! The callback that will be called to destroy data, e.g.,\n! bind data (if any), init data (if any), extra data for replacement scans (if any)"]
pub type duckdb_delete_callback_t = ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
#[doc = "! Used for threading, contains a task state. Must be destroyed with `duckdb_destroy_state`."]
pub type duckdb_task_state = *mut ::std::os::raw::c_void;
#[doc = "! Days are stored as days since 1970-01-01\n! Use the duckdb_from_date/duckdb_to_date function to extract individual information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_date {
    pub days: i32,
}
#[test]
fn bindgen_test_layout_duckdb_date() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_date> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_date>(),
        4usize,
        concat!("Size of: ", stringify!(duckdb_date))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_date>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_date))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).days) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_date), "::", stringify!(days))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_date_struct {
    pub year: i32,
    pub month: i8,
    pub day: i8,
}
#[test]
fn bindgen_test_layout_duckdb_date_struct() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_date_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_date_struct>(),
        8usize,
        concat!("Size of: ", stringify!(duckdb_date_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_date_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_date_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).year) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_date_struct),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_date_struct),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_date_struct),
            "::",
            stringify!(day)
        )
    );
}
#[doc = "! Time is stored as microseconds since 00:00:00\n! Use the duckdb_from_time/duckdb_to_time function to extract individual information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_time {
    pub micros: i64,
}
#[test]
fn bindgen_test_layout_duckdb_time() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_time> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_time>(),
        8usize,
        concat!("Size of: ", stringify!(duckdb_time))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_time>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_time))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).micros) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_time), "::", stringify!(micros))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_time_struct {
    pub hour: i8,
    pub min: i8,
    pub sec: i8,
    pub micros: i32,
}
#[test]
fn bindgen_test_layout_duckdb_time_struct() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_time_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_time_struct>(),
        8usize,
        concat!("Size of: ", stringify!(duckdb_time_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_time_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_time_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hour) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_struct),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_struct),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sec) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_struct),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).micros) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_struct),
            "::",
            stringify!(micros)
        )
    );
}
#[doc = "! TIME_TZ is stored as 40 bits for int64_t micros, and 24 bits for int32_t offset"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_time_tz {
    pub bits: u64,
}
#[test]
fn bindgen_test_layout_duckdb_time_tz() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_time_tz> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_time_tz>(),
        8usize,
        concat!("Size of: ", stringify!(duckdb_time_tz))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_time_tz>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_time_tz))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_time_tz), "::", stringify!(bits))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_time_tz_struct {
    pub time: duckdb_time_struct,
    pub offset: i32,
}
#[test]
fn bindgen_test_layout_duckdb_time_tz_struct() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_time_tz_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_time_tz_struct>(),
        12usize,
        concat!("Size of: ", stringify!(duckdb_time_tz_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_time_tz_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_time_tz_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_tz_struct),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_tz_struct),
            "::",
            stringify!(offset)
        )
    );
}
#[doc = "! Timestamps are stored as microseconds since 1970-01-01\n! Use the duckdb_from_timestamp/duckdb_to_timestamp function to extract individual information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_timestamp {
    pub micros: i64,
}
#[test]
fn bindgen_test_layout_duckdb_timestamp() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_timestamp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_timestamp>(),
        8usize,
        concat!("Size of: ", stringify!(duckdb_timestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_timestamp>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_timestamp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).micros) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_timestamp),
            "::",
            stringify!(micros)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_timestamp_struct {
    pub date: duckdb_date_struct,
    pub time: duckdb_time_struct,
}
#[test]
fn bindgen_test_layout_duckdb_timestamp_struct() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_timestamp_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_timestamp_struct>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_timestamp_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_timestamp_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_timestamp_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).date) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_timestamp_struct),
            "::",
            stringify!(date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_timestamp_struct),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_interval {
    pub months: i32,
    pub days: i32,
    pub micros: i64,
}
#[test]
fn bindgen_test_layout_duckdb_interval() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_interval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_interval>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_interval))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_interval>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_interval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).months) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_interval),
            "::",
            stringify!(months)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).days) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(duckdb_interval), "::", stringify!(days))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).micros) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_interval),
            "::",
            stringify!(micros)
        )
    );
}
#[doc = "! Hugeints are composed of a (lower, upper) component\n! The value of the hugeint is upper * 2^64 + lower\n! For easy usage, the functions duckdb_hugeint_to_double/duckdb_double_to_hugeint are recommended"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_hugeint {
    pub lower: u64,
    pub upper: i64,
}
#[test]
fn bindgen_test_layout_duckdb_hugeint() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_hugeint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_hugeint>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_hugeint))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_hugeint>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_hugeint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lower) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_hugeint), "::", stringify!(lower))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).upper) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(duckdb_hugeint), "::", stringify!(upper))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_uhugeint {
    pub lower: u64,
    pub upper: u64,
}
#[test]
fn bindgen_test_layout_duckdb_uhugeint() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_uhugeint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_uhugeint>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_uhugeint))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_uhugeint>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_uhugeint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lower) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_uhugeint),
            "::",
            stringify!(lower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).upper) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_uhugeint),
            "::",
            stringify!(upper)
        )
    );
}
#[doc = "! Decimals are composed of a width and a scale, and are stored in a hugeint"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_decimal {
    pub width: u8,
    pub scale: u8,
    pub value: duckdb_hugeint,
}
#[test]
fn bindgen_test_layout_duckdb_decimal() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_decimal> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_decimal>(),
        24usize,
        concat!("Size of: ", stringify!(duckdb_decimal))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_decimal>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_decimal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_decimal), "::", stringify!(width))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        1usize,
        concat!("Offset of field: ", stringify!(duckdb_decimal), "::", stringify!(scale))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(duckdb_decimal), "::", stringify!(value))
    );
}
#[doc = "! A type holding information about the query execution progress"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_query_progress_type {
    pub percentage: f64,
    pub rows_processed: u64,
    pub total_rows_to_process: u64,
}
#[test]
fn bindgen_test_layout_duckdb_query_progress_type() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_query_progress_type> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_query_progress_type>(),
        24usize,
        concat!("Size of: ", stringify!(duckdb_query_progress_type))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_query_progress_type>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_query_progress_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).percentage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_query_progress_type),
            "::",
            stringify!(percentage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rows_processed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_query_progress_type),
            "::",
            stringify!(rows_processed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_rows_to_process) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_query_progress_type),
            "::",
            stringify!(total_rows_to_process)
        )
    );
}
#[doc = "! The internal representation of a VARCHAR (string_t). If the VARCHAR does not\n! exceed 12 characters, then we inline it. Otherwise, we inline a prefix for faster\n! string comparisons and store a pointer to the remaining characters. This is a non-\n! owning structure, i.e., it does not have to be freed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct duckdb_string_t {
    pub value: duckdb_string_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union duckdb_string_t__bindgen_ty_1 {
    pub pointer: duckdb_string_t__bindgen_ty_1__bindgen_ty_1,
    pub inlined: duckdb_string_t__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_string_t__bindgen_ty_1__bindgen_ty_1 {
    pub length: u32,
    pub prefix: [::std::os::raw::c_char; 4usize],
    pub ptr: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_duckdb_string_t__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string_t__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string_t__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_string_t__bindgen_ty_1__bindgen_ty_2 {
    pub length: u32,
    pub inlined: [::std::os::raw::c_char; 12usize],
}
#[test]
fn bindgen_test_layout_duckdb_string_t__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string_t__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string_t__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string_t__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inlined) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(inlined)
        )
    );
}
#[test]
fn bindgen_test_layout_duckdb_string_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string_t__bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_string_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1),
            "::",
            stringify!(pointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inlined) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1),
            "::",
            stringify!(inlined)
        )
    );
}
#[test]
fn bindgen_test_layout_duckdb_string_t() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string_t>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string_t))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string_t>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_string_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t),
            "::",
            stringify!(value)
        )
    );
}
#[doc = "! The internal representation of a list metadata entry contains the list's offset in\n! the child vector, and its length. The parent vector holds these metadata entries,\n! whereas the child vector holds the data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_list_entry {
    pub offset: u64,
    pub length: u64,
}
#[test]
fn bindgen_test_layout_duckdb_list_entry() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_list_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_list_entry>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_list_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_list_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_list_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_list_entry),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_list_entry),
            "::",
            stringify!(length)
        )
    );
}
#[doc = "! A column consists of a pointer to its internal data. Don't operate on this type directly.\n! Instead, use functions such as duckdb_column_data, duckdb_nullmask_data,\n! duckdb_column_type, and duckdb_column_name, which take the result and the column index\n! as their parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_column {
    pub __deprecated_data: *mut ::std::os::raw::c_void,
    pub __deprecated_nullmask: *mut bool,
    pub __deprecated_type: duckdb_type,
    pub __deprecated_name: *mut ::std::os::raw::c_char,
    pub internal_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_duckdb_column() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_column> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_column>(),
        40usize,
        concat!("Size of: ", stringify!(duckdb_column))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_column>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_column))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__deprecated_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(__deprecated_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__deprecated_nullmask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(__deprecated_nullmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__deprecated_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(__deprecated_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__deprecated_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(__deprecated_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(internal_data)
        )
    );
}
#[doc = "! A vector to a specified column in a data chunk. Lives as long as the\n! data chunk lives, i.e., must not be destroyed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_vector {
    pub __vctr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_vector() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_vector> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_vector>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_vector>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_vector))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__vctr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_vector),
            "::",
            stringify!(__vctr)
        )
    );
}
#[doc = "! A vector to a specified column in a data chunk. Lives as long as the\n! data chunk lives, i.e., must not be destroyed."]
pub type duckdb_vector = *mut _duckdb_vector;
#[doc = "! Strings are composed of a char pointer and a size. You must free string.data\n! with `duckdb_free`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_string {
    pub data: *mut ::std::os::raw::c_char,
    pub size: idx_t,
}
#[test]
fn bindgen_test_layout_duckdb_string() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_string))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_string), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(duckdb_string), "::", stringify!(size))
    );
}
#[doc = "! BLOBs are composed of a byte pointer and a size. You must free blob.data\n! with `duckdb_free`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_blob {
    pub data: *mut ::std::os::raw::c_void,
    pub size: idx_t,
}
#[test]
fn bindgen_test_layout_duckdb_blob() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_blob> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_blob>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_blob))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_blob>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_blob))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_blob), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(duckdb_blob), "::", stringify!(size))
    );
}
#[doc = "! A query result consists of a pointer to its internal data.\n! Must be freed with 'duckdb_destroy_result'."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_result {
    pub __deprecated_column_count: idx_t,
    pub __deprecated_row_count: idx_t,
    pub __deprecated_rows_changed: idx_t,
    pub __deprecated_columns: *mut duckdb_column,
    pub __deprecated_error_message: *mut ::std::os::raw::c_char,
    pub internal_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_duckdb_result() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_result> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_result>(),
        48usize,
        concat!("Size of: ", stringify!(duckdb_result))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_result>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_result))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__deprecated_column_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(__deprecated_column_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__deprecated_row_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(__deprecated_row_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__deprecated_rows_changed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(__deprecated_rows_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__deprecated_columns) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(__deprecated_columns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__deprecated_error_message) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(__deprecated_error_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(internal_data)
        )
    );
}
#[doc = "! A database object. Should be closed with `duckdb_close`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_database {
    pub __db: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_database() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_database> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_database>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_database))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_database>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_database))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__db) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_database),
            "::",
            stringify!(__db)
        )
    );
}
#[doc = "! A database object. Should be closed with `duckdb_close`."]
pub type duckdb_database = *mut _duckdb_database;
#[doc = "! A connection to a duckdb database. Must be closed with `duckdb_disconnect`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_connection {
    pub __conn: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_connection() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_connection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_connection>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_connection))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_connection>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_connection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__conn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_connection),
            "::",
            stringify!(__conn)
        )
    );
}
#[doc = "! A connection to a duckdb database. Must be closed with `duckdb_disconnect`."]
pub type duckdb_connection = *mut _duckdb_connection;
#[doc = "! A prepared statement is a parameterized query that allows you to bind parameters to it.\n! Must be destroyed with `duckdb_destroy_prepare`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_prepared_statement {
    pub __prep: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_prepared_statement() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_prepared_statement> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_prepared_statement>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_prepared_statement))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_prepared_statement>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_prepared_statement))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prep) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_prepared_statement),
            "::",
            stringify!(__prep)
        )
    );
}
#[doc = "! A prepared statement is a parameterized query that allows you to bind parameters to it.\n! Must be destroyed with `duckdb_destroy_prepare`."]
pub type duckdb_prepared_statement = *mut _duckdb_prepared_statement;
#[doc = "! Extracted statements. Must be destroyed with `duckdb_destroy_extracted`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_extracted_statements {
    pub __extrac: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_extracted_statements() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_extracted_statements> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_extracted_statements>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_extracted_statements))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_extracted_statements>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_extracted_statements))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__extrac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_extracted_statements),
            "::",
            stringify!(__extrac)
        )
    );
}
#[doc = "! Extracted statements. Must be destroyed with `duckdb_destroy_extracted`."]
pub type duckdb_extracted_statements = *mut _duckdb_extracted_statements;
#[doc = "! The pending result represents an intermediate structure for a query that is not yet fully executed.\n! Must be destroyed with `duckdb_destroy_pending`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_pending_result {
    pub __pend: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_pending_result() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_pending_result> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_pending_result>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_pending_result))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_pending_result>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_pending_result))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pend) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_pending_result),
            "::",
            stringify!(__pend)
        )
    );
}
#[doc = "! The pending result represents an intermediate structure for a query that is not yet fully executed.\n! Must be destroyed with `duckdb_destroy_pending`."]
pub type duckdb_pending_result = *mut _duckdb_pending_result;
#[doc = "! The appender enables fast data loading into DuckDB.\n! Must be destroyed with `duckdb_appender_destroy`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_appender {
    pub __appn: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_appender() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_appender> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_appender>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_appender))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_appender>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_appender))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__appn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_appender),
            "::",
            stringify!(__appn)
        )
    );
}
#[doc = "! The appender enables fast data loading into DuckDB.\n! Must be destroyed with `duckdb_appender_destroy`."]
pub type duckdb_appender = *mut _duckdb_appender;
#[doc = "! Can be used to provide start-up options for the DuckDB instance.\n! Must be destroyed with `duckdb_destroy_config`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_config {
    pub __cnfg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_config() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_config> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_config>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_config))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_config>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cnfg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_config),
            "::",
            stringify!(__cnfg)
        )
    );
}
#[doc = "! Can be used to provide start-up options for the DuckDB instance.\n! Must be destroyed with `duckdb_destroy_config`."]
pub type duckdb_config = *mut _duckdb_config;
#[doc = "! Holds an internal logical type.\n! Must be destroyed with `duckdb_destroy_logical_type`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_logical_type {
    pub __lglt: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_logical_type() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_logical_type> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_logical_type>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_logical_type))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_logical_type>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_logical_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lglt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_logical_type),
            "::",
            stringify!(__lglt)
        )
    );
}
#[doc = "! Holds an internal logical type.\n! Must be destroyed with `duckdb_destroy_logical_type`."]
pub type duckdb_logical_type = *mut _duckdb_logical_type;
#[doc = "! Contains a data chunk from a duckdb_result.\n! Must be destroyed with `duckdb_destroy_data_chunk`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_data_chunk {
    pub __dtck: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_data_chunk() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_data_chunk> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_data_chunk>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_data_chunk))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_data_chunk>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_data_chunk))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__dtck) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_data_chunk),
            "::",
            stringify!(__dtck)
        )
    );
}
#[doc = "! Contains a data chunk from a duckdb_result.\n! Must be destroyed with `duckdb_destroy_data_chunk`."]
pub type duckdb_data_chunk = *mut _duckdb_data_chunk;
#[doc = "! Holds a DuckDB value, which wraps a type.\n! Must be destroyed with `duckdb_destroy_value`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_value {
    pub __val: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_value() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_value>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_value))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_value>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_duckdb_value), "::", stringify!(__val))
    );
}
#[doc = "! Holds a DuckDB value, which wraps a type.\n! Must be destroyed with `duckdb_destroy_value`."]
pub type duckdb_value = *mut _duckdb_value;
#[doc = "! A table function. Must be destroyed with `duckdb_destroy_table_function`."]
pub type duckdb_table_function = *mut ::std::os::raw::c_void;
#[doc = "! The bind info of the function. When setting this info, it is necessary to pass a destroy-callback function."]
pub type duckdb_bind_info = *mut ::std::os::raw::c_void;
#[doc = "! Additional function init info. When setting this info, it is necessary to pass a destroy-callback function."]
pub type duckdb_init_info = *mut ::std::os::raw::c_void;
#[doc = "! Additional function info. When setting this info, it is necessary to pass a destroy-callback function."]
pub type duckdb_function_info = *mut ::std::os::raw::c_void;
#[doc = "! The bind function of the table function."]
pub type duckdb_table_function_bind_t = ::std::option::Option<unsafe extern "C" fn(info: duckdb_bind_info)>;
#[doc = "! The (possibly thread-local) init function of the table function."]
pub type duckdb_table_function_init_t = ::std::option::Option<unsafe extern "C" fn(info: duckdb_init_info)>;
#[doc = "! The main function of the table function."]
pub type duckdb_table_function_t =
    ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info, output: duckdb_data_chunk)>;
#[doc = "! Additional replacement scan info. When setting this info, it is necessary to pass a destroy-callback function."]
pub type duckdb_replacement_scan_info = *mut ::std::os::raw::c_void;
#[doc = "! A replacement scan function that can be added to a database."]
pub type duckdb_replacement_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        info: duckdb_replacement_scan_info,
        table_name: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = "! Holds an arrow query result. Must be destroyed with `duckdb_destroy_arrow`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_arrow {
    pub __arrw: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_arrow() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_arrow> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_arrow>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_arrow))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_arrow>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_arrow))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arrw) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_duckdb_arrow), "::", stringify!(__arrw))
    );
}
#[doc = "! Holds an arrow query result. Must be destroyed with `duckdb_destroy_arrow`."]
pub type duckdb_arrow = *mut _duckdb_arrow;
#[doc = "! Holds an arrow array stream. Must be destroyed with `duckdb_destroy_arrow_stream`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_arrow_stream {
    pub __arrwstr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_arrow_stream() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_arrow_stream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_arrow_stream>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_arrow_stream))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_arrow_stream>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_arrow_stream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arrwstr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_arrow_stream),
            "::",
            stringify!(__arrwstr)
        )
    );
}
#[doc = "! Holds an arrow array stream. Must be destroyed with `duckdb_destroy_arrow_stream`."]
pub type duckdb_arrow_stream = *mut _duckdb_arrow_stream;
#[doc = "! Holds an arrow schema. Remember to release the respective ArrowSchema object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_arrow_schema {
    pub __arrs: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_arrow_schema() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_arrow_schema> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_arrow_schema>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_arrow_schema))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_arrow_schema>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_arrow_schema))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_arrow_schema),
            "::",
            stringify!(__arrs)
        )
    );
}
#[doc = "! Holds an arrow schema. Remember to release the respective ArrowSchema object."]
pub type duckdb_arrow_schema = *mut _duckdb_arrow_schema;
#[doc = "! Holds an arrow array. Remember to release the respective ArrowArray object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_arrow_array {
    pub __arra: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_arrow_array() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_arrow_array> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_arrow_array>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_arrow_array))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_arrow_array>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_arrow_array))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arra) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_arrow_array),
            "::",
            stringify!(__arra)
        )
    );
}
#[doc = "! Holds an arrow array. Remember to release the respective ArrowArray object."]
pub type duckdb_arrow_array = *mut _duckdb_arrow_array;
extern "C" {
    #[doc = "Creates a new database or opens an existing database file stored at the given path.\nIf no path is given a new in-memory database is created instead.\nThe instantiated database should be closed with 'duckdb_close'.\n\n path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.\n out_database: The result database object.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_open(path: *const ::std::os::raw::c_char, out_database: *mut duckdb_database) -> duckdb_state;
}
extern "C" {
    #[doc = "Extended version of duckdb_open. Creates a new database or opens an existing database file stored at the given path.\nThe instantiated database should be closed with 'duckdb_close'.\n\n path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.\n out_database: The result database object.\n config: (Optional) configuration used to start up the database system.\n out_error: If set and the function returns DuckDBError, this will contain the reason why the start-up failed.\nNote that the error must be freed using `duckdb_free`.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_open_ext(
        path: *const ::std::os::raw::c_char,
        out_database: *mut duckdb_database,
        config: duckdb_config,
        out_error: *mut *mut ::std::os::raw::c_char,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Closes the specified database and de-allocates all memory allocated for that database.\nThis should be called after you are done with any database allocated through `duckdb_open` or `duckdb_open_ext`.\nNote that failing to call `duckdb_close` (in case of e.g. a program crash) will not cause data corruption.\nStill, it is recommended to always correctly close a database object after you are done with it.\n\n database: The database object to shut down."]
    pub fn duckdb_close(database: *mut duckdb_database);
}
extern "C" {
    #[doc = "Opens a connection to a database. Connections are required to query the database, and store transactional state\nassociated with the connection.\nThe instantiated connection should be closed using 'duckdb_disconnect'.\n\n database: The database file to connect to.\n out_connection: The result connection object.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_connect(database: duckdb_database, out_connection: *mut duckdb_connection) -> duckdb_state;
}
extern "C" {
    #[doc = "Interrupt running query\n\n connection: The connection to interrupt"]
    pub fn duckdb_interrupt(connection: duckdb_connection);
}
extern "C" {
    #[doc = "Get progress of the running query\n\n connection: The working connection\n returns: -1 if no progress or a percentage of the progress"]
    pub fn duckdb_query_progress(connection: duckdb_connection) -> duckdb_query_progress_type;
}
extern "C" {
    #[doc = "Closes the specified connection and de-allocates all memory allocated for that connection.\n\n connection: The connection to close."]
    pub fn duckdb_disconnect(connection: *mut duckdb_connection);
}
extern "C" {
    #[doc = "Returns the version of the linked DuckDB, with a version postfix for dev versions\n\nUsually used for developing C extensions that must return this for a compatibility check."]
    pub fn duckdb_library_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Initializes an empty configuration object that can be used to provide start-up options for the DuckDB instance\nthrough `duckdb_open_ext`.\nThe duckdb_config must be destroyed using 'duckdb_destroy_config'\n\nThis will always succeed unless there is a malloc failure.\n\n out_config: The result configuration object.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_create_config(out_config: *mut duckdb_config) -> duckdb_state;
}
extern "C" {
    #[doc = "This returns the total amount of configuration options available for usage with `duckdb_get_config_flag`.\n\nThis should not be called in a loop as it internally loops over all the options.\n\n returns: The amount of config options available."]
    pub fn duckdb_config_count() -> usize;
}
extern "C" {
    #[doc = "Obtains a human-readable name and description of a specific configuration option. This can be used to e.g.\ndisplay configuration options. This will succeed unless `index` is out of range (i.e. `>= duckdb_config_count`).\n\nThe result name or description MUST NOT be freed.\n\n index: The index of the configuration option (between 0 and `duckdb_config_count`)\n out_name: A name of the configuration flag.\n out_description: A description of the configuration flag.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_get_config_flag(
        index: usize,
        out_name: *mut *const ::std::os::raw::c_char,
        out_description: *mut *const ::std::os::raw::c_char,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Sets the specified option for the specified configuration. The configuration option is indicated by name.\nTo obtain a list of config options, see `duckdb_get_config_flag`.\n\nIn the source code, configuration options are defined in `config.cpp`.\n\nThis can fail if either the name is invalid, or if the value provided for the option is invalid.\n\n duckdb_config: The configuration object to set the option on.\n name: The name of the configuration flag to set.\n option: The value to set the configuration flag to.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_set_config(
        config: duckdb_config,
        name: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Destroys the specified configuration object and de-allocates all memory allocated for the object.\n\n config: The configuration object to destroy."]
    pub fn duckdb_destroy_config(config: *mut duckdb_config);
}
extern "C" {
    #[doc = "Executes a SQL query within a connection and stores the full (materialized) result in the out_result pointer.\nIf the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling\n`duckdb_result_error`.\n\nNote that after running `duckdb_query`, `duckdb_destroy_result` must be called on the result object even if the\nquery fails, otherwise the error stored within the result will not be freed correctly.\n\n connection: The connection to perform the query in.\n query: The SQL query to run.\n out_result: The query result.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_query(
        connection: duckdb_connection,
        query: *const ::std::os::raw::c_char,
        out_result: *mut duckdb_result,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Closes the result and de-allocates all memory allocated for that connection.\n\n result: The result to destroy."]
    pub fn duckdb_destroy_result(result: *mut duckdb_result);
}
extern "C" {
    #[doc = "Returns the column name of the specified column. The result should not need to be freed; the column names will\nautomatically be destroyed when the result is destroyed.\n\nReturns `NULL` if the column is out of range.\n\n result: The result object to fetch the column name from.\n col: The column index.\n returns: The column name of the specified column."]
    pub fn duckdb_column_name(result: *mut duckdb_result, col: idx_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Returns the column type of the specified column.\n\nReturns `DUCKDB_TYPE_INVALID` if the column is out of range.\n\n result: The result object to fetch the column type from.\n col: The column index.\n returns: The column type of the specified column."]
    pub fn duckdb_column_type(result: *mut duckdb_result, col: idx_t) -> duckdb_type;
}
extern "C" {
    #[doc = "Returns the statement type of the statement that was executed\n\n result: The result object to fetch the statement type from.\n returns: duckdb_statement_type value or DUCKDB_STATEMENT_TYPE_INVALID"]
    pub fn duckdb_result_statement_type(result: duckdb_result) -> duckdb_statement_type;
}
extern "C" {
    #[doc = "Returns the logical column type of the specified column.\n\nThe return type of this call should be destroyed with `duckdb_destroy_logical_type`.\n\nReturns `NULL` if the column is out of range.\n\n result: The result object to fetch the column type from.\n col: The column index.\n returns: The logical column type of the specified column."]
    pub fn duckdb_column_logical_type(result: *mut duckdb_result, col: idx_t) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Returns the number of columns present in a the result object.\n\n result: The result object.\n returns: The number of columns present in the result object."]
    pub fn duckdb_column_count(result: *mut duckdb_result) -> idx_t;
}
extern "C" {
    #[doc = "Returns the number of rows present in the result object.\n\n result: The result object.\n returns: The number of rows present in the result object."]
    pub fn duckdb_row_count(result: *mut duckdb_result) -> idx_t;
}
extern "C" {
    #[doc = "Returns the number of rows changed by the query stored in the result. This is relevant only for INSERT/UPDATE/DELETE\nqueries. For other queries the rows_changed will be 0.\n\n result: The result object.\n returns: The number of rows changed."]
    pub fn duckdb_rows_changed(result: *mut duckdb_result) -> idx_t;
}
extern "C" {
    #[doc = "DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.\n\nReturns the data of a specific column of a result in columnar format.\n\nThe function returns a dense array which contains the result data. The exact type stored in the array depends on the\ncorresponding duckdb_type (as provided by `duckdb_column_type`). For the exact type by which the data should be\naccessed, see the comments in [the types section](types) or the `DUCKDB_TYPE` enum.\n\nFor example, for a column of type `DUCKDB_TYPE_INTEGER`, rows can be accessed in the following manner:\n```c\nint32_t *data = (int32_t *) duckdb_column_data(&result, 0);\nprintf(\"Data for row %d: %d\\n\", row, data[row]);\n```\n\n result: The result object to fetch the column data from.\n col: The column index.\n returns: The column data of the specified column."]
    pub fn duckdb_column_data(result: *mut duckdb_result, col: idx_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.\n\nReturns the nullmask of a specific column of a result in columnar format. The nullmask indicates for every row\nwhether or not the corresponding row is `NULL`. If a row is `NULL`, the values present in the array provided\nby `duckdb_column_data` are undefined.\n\n```c\nint32_t *data = (int32_t *) duckdb_column_data(&result, 0);\nbool *nullmask = duckdb_nullmask_data(&result, 0);\nif (nullmask[row]) {\nprintf(\"Data for row %d: NULL\\n\", row);\n} else {\nprintf(\"Data for row %d: %d\\n\", row, data[row]);\n}\n```\n\n result: The result object to fetch the nullmask from.\n col: The column index.\n returns: The nullmask of the specified column."]
    pub fn duckdb_nullmask_data(result: *mut duckdb_result, col: idx_t) -> *mut bool;
}
extern "C" {
    #[doc = "Returns the error message contained within the result. The error is only set if `duckdb_query` returns `DuckDBError`.\n\nThe result of this function must not be freed. It will be cleaned up when `duckdb_destroy_result` is called.\n\n result: The result object to fetch the error from.\n returns: The error of the result."]
    pub fn duckdb_result_error(result: *mut duckdb_result) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Fetches a data chunk from the duckdb_result. This function should be called repeatedly until the result is exhausted.\n\nThe result must be destroyed with `duckdb_destroy_data_chunk`.\n\nThis function supersedes all `duckdb_value` functions, as well as the `duckdb_column_data` and `duckdb_nullmask_data`\nfunctions. It results in significantly better performance, and should be preferred in newer code-bases.\n\nIf this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be\nmixed with the legacy result functions).\n\nUse `duckdb_result_chunk_count` to figure out how many chunks there are in the result.\n\n result: The result object to fetch the data chunk from.\n chunk_index: The chunk index to fetch from.\n returns: The resulting data chunk. Returns `NULL` if the chunk index is out of bounds."]
    pub fn duckdb_result_get_chunk(result: duckdb_result, chunk_index: idx_t) -> duckdb_data_chunk;
}
extern "C" {
    #[doc = "Checks if the type of the internal result is StreamQueryResult.\n\n result: The result object to check.\n returns: Whether or not the result object is of the type StreamQueryResult"]
    pub fn duckdb_result_is_streaming(result: duckdb_result) -> bool;
}
extern "C" {
    #[doc = "Returns the number of data chunks present in the result.\n\n result: The result object\n returns: Number of data chunks present in the result."]
    pub fn duckdb_result_chunk_count(result: duckdb_result) -> idx_t;
}
extern "C" {
    #[doc = "Returns the return_type of the given result, or DUCKDB_RETURN_TYPE_INVALID on error\n\n result: The result object\n returns: The return_type"]
    pub fn duckdb_result_return_type(result: duckdb_result) -> duckdb_result_type;
}
extern "C" {
    #[doc = " returns: The boolean value at the specified location, or false if the value cannot be converted."]
    pub fn duckdb_value_boolean(result: *mut duckdb_result, col: idx_t, row: idx_t) -> bool;
}
extern "C" {
    #[doc = " returns: The int8_t value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_int8(result: *mut duckdb_result, col: idx_t, row: idx_t) -> i8;
}
extern "C" {
    #[doc = " returns: The int16_t value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_int16(result: *mut duckdb_result, col: idx_t, row: idx_t) -> i16;
}
extern "C" {
    #[doc = " returns: The int32_t value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_int32(result: *mut duckdb_result, col: idx_t, row: idx_t) -> i32;
}
extern "C" {
    #[doc = " returns: The int64_t value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_int64(result: *mut duckdb_result, col: idx_t, row: idx_t) -> i64;
}
extern "C" {
    #[doc = " returns: The duckdb_hugeint value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_hugeint(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_hugeint;
}
extern "C" {
    #[doc = " returns: The duckdb_uhugeint value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_uhugeint(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_uhugeint;
}
extern "C" {
    #[doc = " returns: The duckdb_decimal value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_decimal(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_decimal;
}
extern "C" {
    #[doc = " returns: The uint8_t value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_uint8(result: *mut duckdb_result, col: idx_t, row: idx_t) -> u8;
}
extern "C" {
    #[doc = " returns: The uint16_t value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_uint16(result: *mut duckdb_result, col: idx_t, row: idx_t) -> u16;
}
extern "C" {
    #[doc = " returns: The uint32_t value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_uint32(result: *mut duckdb_result, col: idx_t, row: idx_t) -> u32;
}
extern "C" {
    #[doc = " returns: The uint64_t value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_uint64(result: *mut duckdb_result, col: idx_t, row: idx_t) -> u64;
}
extern "C" {
    #[doc = " returns: The float value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_float(result: *mut duckdb_result, col: idx_t, row: idx_t) -> f32;
}
extern "C" {
    #[doc = " returns: The double value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_double(result: *mut duckdb_result, col: idx_t, row: idx_t) -> f64;
}
extern "C" {
    #[doc = " returns: The duckdb_date value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_date(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_date;
}
extern "C" {
    #[doc = " returns: The duckdb_time value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_time(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_time;
}
extern "C" {
    #[doc = " returns: The duckdb_timestamp value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_timestamp(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_timestamp;
}
extern "C" {
    #[doc = " returns: The duckdb_interval value at the specified location, or 0 if the value cannot be converted."]
    pub fn duckdb_value_interval(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_interval;
}
extern "C" {
    #[doc = " DEPRECATED: use duckdb_value_string instead. This function does not work correctly if the string contains null bytes.\n returns: The text value at the specified location as a null-terminated string, or nullptr if the value cannot be\nconverted. The result must be freed with `duckdb_free`."]
    pub fn duckdb_value_varchar(result: *mut duckdb_result, col: idx_t, row: idx_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns: The string value at the specified location.\n The resulting field \"string.data\" must be freed with `duckdb_free.`"]
    pub fn duckdb_value_string(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_string;
}
extern "C" {
    #[doc = " DEPRECATED: use duckdb_value_string_internal instead. This function does not work correctly if the string contains\nnull bytes.\n returns: The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.\nIf the column is NOT a VARCHAR column this function will return NULL.\n\nThe result must NOT be freed."]
    pub fn duckdb_value_varchar_internal(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " DEPRECATED: use duckdb_value_string_internal instead. This function does not work correctly if the string contains\nnull bytes.\n returns: The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.\nIf the column is NOT a VARCHAR column this function will return NULL.\n\nThe result must NOT be freed."]
    pub fn duckdb_value_string_internal(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_string;
}
extern "C" {
    #[doc = " returns: The duckdb_blob value at the specified location. Returns a blob with blob.data set to nullptr if the\nvalue cannot be converted. The resulting field \"blob.data\" must be freed with `duckdb_free.`"]
    pub fn duckdb_value_blob(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_blob;
}
extern "C" {
    #[doc = " returns: Returns true if the value at the specified index is NULL, and false otherwise."]
    pub fn duckdb_value_is_null(result: *mut duckdb_result, col: idx_t, row: idx_t) -> bool;
}
extern "C" {
    #[doc = "Allocate `size` bytes of memory using the duckdb internal malloc function. Any memory allocated in this manner\nshould be freed using `duckdb_free`.\n\n size: The number of bytes to allocate.\n returns: A pointer to the allocated memory region."]
    pub fn duckdb_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Free a value returned from `duckdb_malloc`, `duckdb_value_varchar`, `duckdb_value_blob`, or\n`duckdb_value_string`.\n\n ptr: The memory region to de-allocate."]
    pub fn duckdb_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "The internal vector size used by DuckDB.\nThis is the amount of tuples that will fit into a data chunk created by `duckdb_create_data_chunk`.\n\n returns: The vector size."]
    pub fn duckdb_vector_size() -> idx_t;
}
extern "C" {
    #[doc = "Whether or not the duckdb_string_t value is inlined.\nThis means that the data of the string does not have a separate allocation."]
    pub fn duckdb_string_is_inlined(string: duckdb_string_t) -> bool;
}
extern "C" {
    #[doc = "Decompose a `duckdb_date` object into year, month and date (stored as `duckdb_date_struct`).\n\n date: The date object, as obtained from a `DUCKDB_TYPE_DATE` column.\n returns: The `duckdb_date_struct` with the decomposed elements."]
    pub fn duckdb_from_date(date: duckdb_date) -> duckdb_date_struct;
}
extern "C" {
    #[doc = "Re-compose a `duckdb_date` from year, month and date (`duckdb_date_struct`).\n\n date: The year, month and date stored in a `duckdb_date_struct`.\n returns: The `duckdb_date` element."]
    pub fn duckdb_to_date(date: duckdb_date_struct) -> duckdb_date;
}
extern "C" {
    #[doc = "Test a `duckdb_date` to see if it is a finite value.\n\n date: The date object, as obtained from a `DUCKDB_TYPE_DATE` column.\n returns: True if the date is finite, false if it is ±infinity."]
    pub fn duckdb_is_finite_date(date: duckdb_date) -> bool;
}
extern "C" {
    #[doc = "Decompose a `duckdb_time` object into hour, minute, second and microsecond (stored as `duckdb_time_struct`).\n\n time: The time object, as obtained from a `DUCKDB_TYPE_TIME` column.\n returns: The `duckdb_time_struct` with the decomposed elements."]
    pub fn duckdb_from_time(time: duckdb_time) -> duckdb_time_struct;
}
extern "C" {
    #[doc = "Create a `duckdb_time_tz` object from micros and a timezone offset.\n\n micros: The microsecond component of the time.\n offset: The timezone offset component of the time.\n returns: The `duckdb_time_tz` element."]
    pub fn duckdb_create_time_tz(micros: i64, offset: i32) -> duckdb_time_tz;
}
extern "C" {
    #[doc = "Decompose a TIME_TZ objects into micros and a timezone offset.\n\nUse `duckdb_from_time` to further decompose the micros into hour, minute, second and microsecond.\n\n micros: The time object, as obtained from a `DUCKDB_TYPE_TIME_TZ` column.\n out_micros: The microsecond component of the time.\n out_offset: The timezone offset component of the time."]
    pub fn duckdb_from_time_tz(micros: duckdb_time_tz) -> duckdb_time_tz_struct;
}
extern "C" {
    #[doc = "Re-compose a `duckdb_time` from hour, minute, second and microsecond (`duckdb_time_struct`).\n\n time: The hour, minute, second and microsecond in a `duckdb_time_struct`.\n returns: The `duckdb_time` element."]
    pub fn duckdb_to_time(time: duckdb_time_struct) -> duckdb_time;
}
extern "C" {
    #[doc = "Decompose a `duckdb_timestamp` object into a `duckdb_timestamp_struct`.\n\n ts: The ts object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.\n returns: The `duckdb_timestamp_struct` with the decomposed elements."]
    pub fn duckdb_from_timestamp(ts: duckdb_timestamp) -> duckdb_timestamp_struct;
}
extern "C" {
    #[doc = "Re-compose a `duckdb_timestamp` from a duckdb_timestamp_struct.\n\n ts: The de-composed elements in a `duckdb_timestamp_struct`.\n returns: The `duckdb_timestamp` element."]
    pub fn duckdb_to_timestamp(ts: duckdb_timestamp_struct) -> duckdb_timestamp;
}
extern "C" {
    #[doc = "Test a `duckdb_timestamp` to see if it is a finite value.\n\n ts: The timestamp object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.\n returns: True if the timestamp is finite, false if it is ±infinity."]
    pub fn duckdb_is_finite_timestamp(ts: duckdb_timestamp) -> bool;
}
extern "C" {
    #[doc = "Converts a duckdb_hugeint object (as obtained from a `DUCKDB_TYPE_HUGEINT` column) into a double.\n\n val: The hugeint value.\n returns: The converted `double` element."]
    pub fn duckdb_hugeint_to_double(val: duckdb_hugeint) -> f64;
}
extern "C" {
    #[doc = "Converts a double value to a duckdb_hugeint object.\n\nIf the conversion fails because the double value is too big the result will be 0.\n\n val: The double value.\n returns: The converted `duckdb_hugeint` element."]
    pub fn duckdb_double_to_hugeint(val: f64) -> duckdb_hugeint;
}
extern "C" {
    #[doc = "Converts a duckdb_uhugeint object (as obtained from a `DUCKDB_TYPE_UHUGEINT` column) into a double.\n\n val: The uhugeint value.\n returns: The converted `double` element."]
    pub fn duckdb_uhugeint_to_double(val: duckdb_uhugeint) -> f64;
}
extern "C" {
    #[doc = "Converts a double value to a duckdb_uhugeint object.\n\nIf the conversion fails because the double value is too big the result will be 0.\n\n val: The double value.\n returns: The converted `duckdb_uhugeint` element."]
    pub fn duckdb_double_to_uhugeint(val: f64) -> duckdb_uhugeint;
}
extern "C" {
    #[doc = "Converts a double value to a duckdb_decimal object.\n\nIf the conversion fails because the double value is too big, or the width/scale are invalid the result will be 0.\n\n val: The double value.\n returns: The converted `duckdb_decimal` element."]
    pub fn duckdb_double_to_decimal(val: f64, width: u8, scale: u8) -> duckdb_decimal;
}
extern "C" {
    #[doc = "Converts a duckdb_decimal object (as obtained from a `DUCKDB_TYPE_DECIMAL` column) into a double.\n\n val: The decimal value.\n returns: The converted `double` element."]
    pub fn duckdb_decimal_to_double(val: duckdb_decimal) -> f64;
}
extern "C" {
    #[doc = "Create a prepared statement object from a query.\n\nNote that after calling `duckdb_prepare`, the prepared statement should always be destroyed using\n`duckdb_destroy_prepare`, even if the prepare fails.\n\nIf the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.\n\n connection: The connection object\n query: The SQL query to prepare\n out_prepared_statement: The resulting prepared statement object\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_prepare(
        connection: duckdb_connection,
        query: *const ::std::os::raw::c_char,
        out_prepared_statement: *mut duckdb_prepared_statement,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Closes the prepared statement and de-allocates all memory allocated for the statement.\n\n prepared_statement: The prepared statement to destroy."]
    pub fn duckdb_destroy_prepare(prepared_statement: *mut duckdb_prepared_statement);
}
extern "C" {
    #[doc = "Returns the error message associated with the given prepared statement.\nIf the prepared statement has no error message, this returns `nullptr` instead.\n\nThe error message should not be freed. It will be de-allocated when `duckdb_destroy_prepare` is called.\n\n prepared_statement: The prepared statement to obtain the error from.\n returns: The error message, or `nullptr` if there is none."]
    pub fn duckdb_prepare_error(prepared_statement: duckdb_prepared_statement) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Returns the number of parameters that can be provided to the given prepared statement.\n\nReturns 0 if the query was not successfully prepared.\n\n prepared_statement: The prepared statement to obtain the number of parameters for."]
    pub fn duckdb_nparams(prepared_statement: duckdb_prepared_statement) -> idx_t;
}
extern "C" {
    #[doc = "Returns the name used to identify the parameter\nThe returned string should be freed using `duckdb_free`.\n\nReturns NULL if the index is out of range for the provided prepared statement.\n\n prepared_statement: The prepared statement for which to get the parameter name from."]
    pub fn duckdb_parameter_name(
        prepared_statement: duckdb_prepared_statement,
        index: idx_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Returns the parameter type for the parameter at the given index.\n\nReturns `DUCKDB_TYPE_INVALID` if the parameter index is out of range or the statement was not successfully prepared.\n\n prepared_statement: The prepared statement.\n param_idx: The parameter index.\n returns: The parameter type"]
    pub fn duckdb_param_type(prepared_statement: duckdb_prepared_statement, param_idx: idx_t) -> duckdb_type;
}
extern "C" {
    #[doc = "Clear the params bind to the prepared statement."]
    pub fn duckdb_clear_bindings(prepared_statement: duckdb_prepared_statement) -> duckdb_state;
}
extern "C" {
    #[doc = "Returns the statement type of the statement to be executed\n\n statement: The prepared statement.\n returns: duckdb_statement_type value or DUCKDB_STATEMENT_TYPE_INVALID"]
    pub fn duckdb_prepared_statement_type(statement: duckdb_prepared_statement) -> duckdb_statement_type;
}
extern "C" {
    #[doc = "Binds a value to the prepared statement at the specified index."]
    pub fn duckdb_bind_value(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_value,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Retrieve the index of the parameter for the prepared statement, identified by name"]
    pub fn duckdb_bind_parameter_index(
        prepared_statement: duckdb_prepared_statement,
        param_idx_out: *mut idx_t,
        name: *const ::std::os::raw::c_char,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a bool value to the prepared statement at the specified index."]
    pub fn duckdb_bind_boolean(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: bool,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an int8_t value to the prepared statement at the specified index."]
    pub fn duckdb_bind_int8(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: i8) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an int16_t value to the prepared statement at the specified index."]
    pub fn duckdb_bind_int16(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: i16)
        -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an int32_t value to the prepared statement at the specified index."]
    pub fn duckdb_bind_int32(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: i32)
        -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an int64_t value to the prepared statement at the specified index."]
    pub fn duckdb_bind_int64(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: i64)
        -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a duckdb_hugeint value to the prepared statement at the specified index."]
    pub fn duckdb_bind_hugeint(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_hugeint,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an duckdb_uhugeint value to the prepared statement at the specified index."]
    pub fn duckdb_bind_uhugeint(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_uhugeint,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a duckdb_decimal value to the prepared statement at the specified index."]
    pub fn duckdb_bind_decimal(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_decimal,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an uint8_t value to the prepared statement at the specified index."]
    pub fn duckdb_bind_uint8(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: u8) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an uint16_t value to the prepared statement at the specified index."]
    pub fn duckdb_bind_uint16(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: u16,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an uint32_t value to the prepared statement at the specified index."]
    pub fn duckdb_bind_uint32(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: u32,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds an uint64_t value to the prepared statement at the specified index."]
    pub fn duckdb_bind_uint64(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: u64,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a float value to the prepared statement at the specified index."]
    pub fn duckdb_bind_float(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: f32)
        -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a double value to the prepared statement at the specified index."]
    pub fn duckdb_bind_double(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: f64,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a duckdb_date value to the prepared statement at the specified index."]
    pub fn duckdb_bind_date(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_date,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a duckdb_time value to the prepared statement at the specified index."]
    pub fn duckdb_bind_time(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_time,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a duckdb_timestamp value to the prepared statement at the specified index."]
    pub fn duckdb_bind_timestamp(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_timestamp,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a duckdb_interval value to the prepared statement at the specified index."]
    pub fn duckdb_bind_interval(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_interval,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a null-terminated varchar value to the prepared statement at the specified index."]
    pub fn duckdb_bind_varchar(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: *const ::std::os::raw::c_char,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a varchar value to the prepared statement at the specified index."]
    pub fn duckdb_bind_varchar_length(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: *const ::std::os::raw::c_char,
        length: idx_t,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a blob value to the prepared statement at the specified index."]
    pub fn duckdb_bind_blob(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        data: *const ::std::os::raw::c_void,
        length: idx_t,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Binds a NULL value to the prepared statement at the specified index."]
    pub fn duckdb_bind_null(prepared_statement: duckdb_prepared_statement, param_idx: idx_t) -> duckdb_state;
}
extern "C" {
    #[doc = "Executes the prepared statement with the given bound parameters, and returns a materialized query result.\n\nThis method can be called multiple times for each prepared statement, and the parameters can be modified\nbetween calls to this function.\n\nNote that the result must be freed with `duckdb_destroy_result`.\n\n prepared_statement: The prepared statement to execute.\n out_result: The query result.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_execute_prepared(
        prepared_statement: duckdb_prepared_statement,
        out_result: *mut duckdb_result,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Executes the prepared statement with the given bound parameters, and returns an optionally-streaming query result.\nTo determine if the resulting query was in fact streamed, use `duckdb_result_is_streaming`\n\nThis method can be called multiple times for each prepared statement, and the parameters can be modified\nbetween calls to this function.\n\nNote that the result must be freed with `duckdb_destroy_result`.\n\n prepared_statement: The prepared statement to execute.\n out_result: The query result.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_execute_prepared_streaming(
        prepared_statement: duckdb_prepared_statement,
        out_result: *mut duckdb_result,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Extract all statements from a query.\nNote that after calling `duckdb_extract_statements`, the extracted statements should always be destroyed using\n`duckdb_destroy_extracted`, even if no statements were extracted.\n\nIf the extract fails, `duckdb_extract_statements_error` can be called to obtain the reason why the extract failed.\n\n connection: The connection object\n query: The SQL query to extract\n out_extracted_statements: The resulting extracted statements object\n returns: The number of extracted statements or 0 on failure."]
    pub fn duckdb_extract_statements(
        connection: duckdb_connection,
        query: *const ::std::os::raw::c_char,
        out_extracted_statements: *mut duckdb_extracted_statements,
    ) -> idx_t;
}
extern "C" {
    #[doc = "Prepare an extracted statement.\nNote that after calling `duckdb_prepare_extracted_statement`, the prepared statement should always be destroyed using\n`duckdb_destroy_prepare`, even if the prepare fails.\n\nIf the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.\n\n connection: The connection object\n extracted_statements: The extracted statements object\n index: The index of the extracted statement to prepare\n out_prepared_statement: The resulting prepared statement object\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_prepare_extracted_statement(
        connection: duckdb_connection,
        extracted_statements: duckdb_extracted_statements,
        index: idx_t,
        out_prepared_statement: *mut duckdb_prepared_statement,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Returns the error message contained within the extracted statements.\nThe result of this function must not be freed. It will be cleaned up when `duckdb_destroy_extracted` is called.\n\n result: The extracted statements to fetch the error from.\n returns: The error of the extracted statements."]
    pub fn duckdb_extract_statements_error(
        extracted_statements: duckdb_extracted_statements,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "De-allocates all memory allocated for the extracted statements.\n extracted_statements: The extracted statements to destroy."]
    pub fn duckdb_destroy_extracted(extracted_statements: *mut duckdb_extracted_statements);
}
extern "C" {
    #[doc = "Executes the prepared statement with the given bound parameters, and returns a pending result.\nThe pending result represents an intermediate structure for a query that is not yet fully executed.\nThe pending result can be used to incrementally execute a query, returning control to the client between tasks.\n\nNote that after calling `duckdb_pending_prepared`, the pending result should always be destroyed using\n`duckdb_destroy_pending`, even if this function returns DuckDBError.\n\n prepared_statement: The prepared statement to execute.\n out_result: The pending query result.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_pending_prepared(
        prepared_statement: duckdb_prepared_statement,
        out_result: *mut duckdb_pending_result,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Executes the prepared statement with the given bound parameters, and returns a pending result.\nThis pending result will create a streaming duckdb_result when executed.\nThe pending result represents an intermediate structure for a query that is not yet fully executed.\n\nNote that after calling `duckdb_pending_prepared_streaming`, the pending result should always be destroyed using\n`duckdb_destroy_pending`, even if this function returns DuckDBError.\n\n prepared_statement: The prepared statement to execute.\n out_result: The pending query result.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_pending_prepared_streaming(
        prepared_statement: duckdb_prepared_statement,
        out_result: *mut duckdb_pending_result,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Closes the pending result and de-allocates all memory allocated for the result.\n\n pending_result: The pending result to destroy."]
    pub fn duckdb_destroy_pending(pending_result: *mut duckdb_pending_result);
}
extern "C" {
    #[doc = "Returns the error message contained within the pending result.\n\nThe result of this function must not be freed. It will be cleaned up when `duckdb_destroy_pending` is called.\n\n result: The pending result to fetch the error from.\n returns: The error of the pending result."]
    pub fn duckdb_pending_error(pending_result: duckdb_pending_result) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Executes a single task within the query, returning whether or not the query is ready.\n\nIf this returns DUCKDB_PENDING_RESULT_READY, the duckdb_execute_pending function can be called to obtain the result.\nIf this returns DUCKDB_PENDING_RESULT_NOT_READY, the duckdb_pending_execute_task function should be called again.\nIf this returns DUCKDB_PENDING_ERROR, an error occurred during execution.\n\nThe error message can be obtained by calling duckdb_pending_error on the pending_result.\n\n pending_result: The pending result to execute a task within.\n returns: The state of the pending result after the execution."]
    pub fn duckdb_pending_execute_task(pending_result: duckdb_pending_result) -> duckdb_pending_state;
}
extern "C" {
    #[doc = "If this returns DUCKDB_PENDING_RESULT_READY, the duckdb_execute_pending function can be called to obtain the result.\nIf this returns DUCKDB_PENDING_RESULT_NOT_READY, the duckdb_pending_execute_check_state function should be called again.\nIf this returns DUCKDB_PENDING_ERROR, an error occurred during execution.\n\nThe error message can be obtained by calling duckdb_pending_error on the pending_result.\n\n pending_result: The pending result.\n returns: The state of the pending result."]
    pub fn duckdb_pending_execute_check_state(pending_result: duckdb_pending_result) -> duckdb_pending_state;
}
extern "C" {
    #[doc = "Fully execute a pending query result, returning the final query result.\n\nIf duckdb_pending_execute_task has been called until DUCKDB_PENDING_RESULT_READY was returned, this will return fast.\nOtherwise, all remaining tasks must be executed first.\n\nNote that the result must be freed with `duckdb_destroy_result`.\n\n pending_result: The pending result to execute.\n out_result: The result object.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_execute_pending(
        pending_result: duckdb_pending_result,
        out_result: *mut duckdb_result,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Returns whether a duckdb_pending_state is finished executing. For example if `pending_state` is\nDUCKDB_PENDING_RESULT_READY, this function will return true.\n\n pending_state: The pending state on which to decide whether to finish execution.\n returns: Boolean indicating pending execution should be considered finished."]
    pub fn duckdb_pending_execution_is_finished(pending_state: duckdb_pending_state) -> bool;
}
extern "C" {
    #[doc = "Destroys the value and de-allocates all memory allocated for that type.\n\n value: The value to destroy."]
    pub fn duckdb_destroy_value(value: *mut duckdb_value);
}
extern "C" {
    #[doc = "Creates a value from a null-terminated string\n\n value: The null-terminated string\n returns: The value. This must be destroyed with `duckdb_destroy_value`."]
    pub fn duckdb_create_varchar(text: *const ::std::os::raw::c_char) -> duckdb_value;
}
extern "C" {
    #[doc = "Creates a value from a string\n\n value: The text\n length: The length of the text\n returns: The value. This must be destroyed with `duckdb_destroy_value`."]
    pub fn duckdb_create_varchar_length(text: *const ::std::os::raw::c_char, length: idx_t) -> duckdb_value;
}
extern "C" {
    #[doc = "Creates a value from an int64\n\n value: The bigint value\n returns: The value. This must be destroyed with `duckdb_destroy_value`."]
    pub fn duckdb_create_int64(val: i64) -> duckdb_value;
}
extern "C" {
    #[doc = "Creates a struct value from a type and an array of values\n\n type: The type of the struct\n values: The values for the struct fields\n returns: The value. This must be destroyed with `duckdb_destroy_value`."]
    pub fn duckdb_create_struct_value(type_: duckdb_logical_type, values: *mut duckdb_value) -> duckdb_value;
}
extern "C" {
    #[doc = "Creates a list value from a type and an array of values of length `value_count`\n\n type: The type of the list\n values: The values for the list\n value_count: The number of values in the list\n returns: The value. This must be destroyed with `duckdb_destroy_value`."]
    pub fn duckdb_create_list_value(
        type_: duckdb_logical_type,
        values: *mut duckdb_value,
        value_count: idx_t,
    ) -> duckdb_value;
}
extern "C" {
    #[doc = "Creates a array value from a type and an array of values of length `value_count`\n\n type: The type of the array\n values: The values for the array\n value_count: The number of values in the array\n returns: The value. This must be destroyed with `duckdb_destroy_value`."]
    pub fn duckdb_create_array_value(
        type_: duckdb_logical_type,
        values: *mut duckdb_value,
        value_count: idx_t,
    ) -> duckdb_value;
}
extern "C" {
    #[doc = "Obtains a string representation of the given value.\nThe result must be destroyed with `duckdb_free`.\n\n value: The value\n returns: The string value. This must be destroyed with `duckdb_free`."]
    pub fn duckdb_get_varchar(value: duckdb_value) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Obtains an int64 of the given value.\n\n value: The value\n returns: The int64 value, or 0 if no conversion is possible"]
    pub fn duckdb_get_int64(value: duckdb_value) -> i64;
}
extern "C" {
    #[doc = "Creates a `duckdb_logical_type` from a standard primitive type.\nThe resulting type should be destroyed with `duckdb_destroy_logical_type`.\n\nThis should not be used with `DUCKDB_TYPE_DECIMAL`.\n\n type: The primitive type to create.\n returns: The logical type."]
    pub fn duckdb_create_logical_type(type_: duckdb_type) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Returns the alias of a duckdb_logical_type, if one is set, else `NULL`.\nThe result must be destroyed with `duckdb_free`.\n\n type: The logical type to return the alias of\n returns: The alias or `NULL`"]
    pub fn duckdb_logical_type_get_alias(type_: duckdb_logical_type) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Creates a list type from its child type.\nThe resulting type should be destroyed with `duckdb_destroy_logical_type`.\n\n type: The child type of list type to create.\n returns: The logical type."]
    pub fn duckdb_create_list_type(type_: duckdb_logical_type) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Creates a array type from its child type.\nThe resulting type should be destroyed with `duckdb_destroy_logical_type`.\n\n type: The child type of array type to create.\n array_size: The number of elements in the array.\n returns: The logical type."]
    pub fn duckdb_create_array_type(type_: duckdb_logical_type, array_size: idx_t) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Creates a map type from its key type and value type.\nThe resulting type should be destroyed with `duckdb_destroy_logical_type`.\n\n type: The key type and value type of map type to create.\n returns: The logical type."]
    pub fn duckdb_create_map_type(
        key_type: duckdb_logical_type,
        value_type: duckdb_logical_type,
    ) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Creates a UNION type from the passed types array.\nThe resulting type should be destroyed with `duckdb_destroy_logical_type`.\n\n types: The array of types that the union should consist of.\n type_amount: The size of the types array.\n returns: The logical type."]
    pub fn duckdb_create_union_type(
        member_types: *mut duckdb_logical_type,
        member_names: *mut *const ::std::os::raw::c_char,
        member_count: idx_t,
    ) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Creates a STRUCT type from the passed member name and type arrays.\nThe resulting type should be destroyed with `duckdb_destroy_logical_type`.\n\n member_types: The array of types that the struct should consist of.\n member_names: The array of names that the struct should consist of.\n member_count: The number of members that were specified for both arrays.\n returns: The logical type."]
    pub fn duckdb_create_struct_type(
        member_types: *mut duckdb_logical_type,
        member_names: *mut *const ::std::os::raw::c_char,
        member_count: idx_t,
    ) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Creates an ENUM type from the passed member name array.\nThe resulting type should be destroyed with `duckdb_destroy_logical_type`.\n\n enum_name: The name of the enum.\n member_names: The array of names that the enum should consist of.\n member_count: The number of elements that were specified in the array.\n returns: The logical type."]
    pub fn duckdb_create_enum_type(
        member_names: *mut *const ::std::os::raw::c_char,
        member_count: idx_t,
    ) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Creates a `duckdb_logical_type` of type decimal with the specified width and scale.\nThe resulting type should be destroyed with `duckdb_destroy_logical_type`.\n\n width: The width of the decimal type\n scale: The scale of the decimal type\n returns: The logical type."]
    pub fn duckdb_create_decimal_type(width: u8, scale: u8) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Retrieves the enum type class of a `duckdb_logical_type`.\n\n type: The logical type object\n returns: The type id"]
    pub fn duckdb_get_type_id(type_: duckdb_logical_type) -> duckdb_type;
}
extern "C" {
    #[doc = "Retrieves the width of a decimal type.\n\n type: The logical type object\n returns: The width of the decimal type"]
    pub fn duckdb_decimal_width(type_: duckdb_logical_type) -> u8;
}
extern "C" {
    #[doc = "Retrieves the scale of a decimal type.\n\n type: The logical type object\n returns: The scale of the decimal type"]
    pub fn duckdb_decimal_scale(type_: duckdb_logical_type) -> u8;
}
extern "C" {
    #[doc = "Retrieves the internal storage type of a decimal type.\n\n type: The logical type object\n returns: The internal type of the decimal type"]
    pub fn duckdb_decimal_internal_type(type_: duckdb_logical_type) -> duckdb_type;
}
extern "C" {
    #[doc = "Retrieves the internal storage type of an enum type.\n\n type: The logical type object\n returns: The internal type of the enum type"]
    pub fn duckdb_enum_internal_type(type_: duckdb_logical_type) -> duckdb_type;
}
extern "C" {
    #[doc = "Retrieves the dictionary size of the enum type.\n\n type: The logical type object\n returns: The dictionary size of the enum type"]
    pub fn duckdb_enum_dictionary_size(type_: duckdb_logical_type) -> u32;
}
extern "C" {
    #[doc = "Retrieves the dictionary value at the specified position from the enum.\n\nThe result must be freed with `duckdb_free`.\n\n type: The logical type object\n index: The index in the dictionary\n returns: The string value of the enum type. Must be freed with `duckdb_free`."]
    pub fn duckdb_enum_dictionary_value(type_: duckdb_logical_type, index: idx_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Retrieves the child type of the given list type.\n\nThe result must be freed with `duckdb_destroy_logical_type`.\n\n type: The logical type object\n returns: The child type of the list type. Must be destroyed with `duckdb_destroy_logical_type`."]
    pub fn duckdb_list_type_child_type(type_: duckdb_logical_type) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Retrieves the child type of the given array type.\n\nThe result must be freed with `duckdb_destroy_logical_type`.\n\n type: The logical type object\n returns: The child type of the array type. Must be destroyed with `duckdb_destroy_logical_type`."]
    pub fn duckdb_array_type_child_type(type_: duckdb_logical_type) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Retrieves the array size of the given array type.\n\n type: The logical type object\n returns: The fixed number of elements the values of this array type can store."]
    pub fn duckdb_array_type_array_size(type_: duckdb_logical_type) -> idx_t;
}
extern "C" {
    #[doc = "Retrieves the key type of the given map type.\n\nThe result must be freed with `duckdb_destroy_logical_type`.\n\n type: The logical type object\n returns: The key type of the map type. Must be destroyed with `duckdb_destroy_logical_type`."]
    pub fn duckdb_map_type_key_type(type_: duckdb_logical_type) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Retrieves the value type of the given map type.\n\nThe result must be freed with `duckdb_destroy_logical_type`.\n\n type: The logical type object\n returns: The value type of the map type. Must be destroyed with `duckdb_destroy_logical_type`."]
    pub fn duckdb_map_type_value_type(type_: duckdb_logical_type) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Returns the number of children of a struct type.\n\n type: The logical type object\n returns: The number of children of a struct type."]
    pub fn duckdb_struct_type_child_count(type_: duckdb_logical_type) -> idx_t;
}
extern "C" {
    #[doc = "Retrieves the name of the struct child.\n\nThe result must be freed with `duckdb_free`.\n\n type: The logical type object\n index: The child index\n returns: The name of the struct type. Must be freed with `duckdb_free`."]
    pub fn duckdb_struct_type_child_name(type_: duckdb_logical_type, index: idx_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Retrieves the child type of the given struct type at the specified index.\n\nThe result must be freed with `duckdb_destroy_logical_type`.\n\n type: The logical type object\n index: The child index\n returns: The child type of the struct type. Must be destroyed with `duckdb_destroy_logical_type`."]
    pub fn duckdb_struct_type_child_type(type_: duckdb_logical_type, index: idx_t) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Returns the number of members that the union type has.\n\n type: The logical type (union) object\n returns: The number of members of a union type."]
    pub fn duckdb_union_type_member_count(type_: duckdb_logical_type) -> idx_t;
}
extern "C" {
    #[doc = "Retrieves the name of the union member.\n\nThe result must be freed with `duckdb_free`.\n\n type: The logical type object\n index: The child index\n returns: The name of the union member. Must be freed with `duckdb_free`."]
    pub fn duckdb_union_type_member_name(type_: duckdb_logical_type, index: idx_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Retrieves the child type of the given union member at the specified index.\n\nThe result must be freed with `duckdb_destroy_logical_type`.\n\n type: The logical type object\n index: The child index\n returns: The child type of the union member. Must be destroyed with `duckdb_destroy_logical_type`."]
    pub fn duckdb_union_type_member_type(type_: duckdb_logical_type, index: idx_t) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Destroys the logical type and de-allocates all memory allocated for that type.\n\n type: The logical type to destroy."]
    pub fn duckdb_destroy_logical_type(type_: *mut duckdb_logical_type);
}
extern "C" {
    #[doc = "Creates an empty DataChunk with the specified set of types.\n\nNote that the result must be destroyed with `duckdb_destroy_data_chunk`.\n\n types: An array of types of the data chunk.\n column_count: The number of columns.\n returns: The data chunk."]
    pub fn duckdb_create_data_chunk(types: *mut duckdb_logical_type, column_count: idx_t) -> duckdb_data_chunk;
}
extern "C" {
    #[doc = "Destroys the data chunk and de-allocates all memory allocated for that chunk.\n\n chunk: The data chunk to destroy."]
    pub fn duckdb_destroy_data_chunk(chunk: *mut duckdb_data_chunk);
}
extern "C" {
    #[doc = "Resets a data chunk, clearing the validity masks and setting the cardinality of the data chunk to 0.\n\n chunk: The data chunk to reset."]
    pub fn duckdb_data_chunk_reset(chunk: duckdb_data_chunk);
}
extern "C" {
    #[doc = "Retrieves the number of columns in a data chunk.\n\n chunk: The data chunk to get the data from\n returns: The number of columns in the data chunk"]
    pub fn duckdb_data_chunk_get_column_count(chunk: duckdb_data_chunk) -> idx_t;
}
extern "C" {
    #[doc = "Retrieves the vector at the specified column index in the data chunk.\n\nThe pointer to the vector is valid for as long as the chunk is alive.\nIt does NOT need to be destroyed.\n\n chunk: The data chunk to get the data from\n returns: The vector"]
    pub fn duckdb_data_chunk_get_vector(chunk: duckdb_data_chunk, col_idx: idx_t) -> duckdb_vector;
}
extern "C" {
    #[doc = "Retrieves the current number of tuples in a data chunk.\n\n chunk: The data chunk to get the data from\n returns: The number of tuples in the data chunk"]
    pub fn duckdb_data_chunk_get_size(chunk: duckdb_data_chunk) -> idx_t;
}
extern "C" {
    #[doc = "Sets the current number of tuples in a data chunk.\n\n chunk: The data chunk to set the size in\n size: The number of tuples in the data chunk"]
    pub fn duckdb_data_chunk_set_size(chunk: duckdb_data_chunk, size: idx_t);
}
extern "C" {
    #[doc = "Retrieves the column type of the specified vector.\n\nThe result must be destroyed with `duckdb_destroy_logical_type`.\n\n vector: The vector get the data from\n returns: The type of the vector"]
    pub fn duckdb_vector_get_column_type(vector: duckdb_vector) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Retrieves the data pointer of the vector.\n\nThe data pointer can be used to read or write values from the vector.\nHow to read or write values depends on the type of the vector.\n\n vector: The vector to get the data from\n returns: The data pointer"]
    pub fn duckdb_vector_get_data(vector: duckdb_vector) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Retrieves the validity mask pointer of the specified vector.\n\nIf all values are valid, this function MIGHT return NULL!\n\nThe validity mask is a bitset that signifies null-ness within the data chunk.\nIt is a series of uint64_t values, where each uint64_t value contains validity for 64 tuples.\nThe bit is set to 1 if the value is valid (i.e. not NULL) or 0 if the value is invalid (i.e. NULL).\n\nValidity of a specific value can be obtained like this:\n\nidx_t entry_idx = row_idx / 64;\nidx_t idx_in_entry = row_idx % 64;\nbool is_valid = validity_mask[entry_idx] & (1 << idx_in_entry);\n\nAlternatively, the (slower) duckdb_validity_row_is_valid function can be used.\n\n vector: The vector to get the data from\n returns: The pointer to the validity mask, or NULL if no validity mask is present"]
    pub fn duckdb_vector_get_validity(vector: duckdb_vector) -> *mut u64;
}
extern "C" {
    #[doc = "Ensures the validity mask is writable by allocating it.\n\nAfter this function is called, `duckdb_vector_get_validity` will ALWAYS return non-NULL.\nThis allows null values to be written to the vector, regardless of whether a validity mask was present before.\n\n vector: The vector to alter"]
    pub fn duckdb_vector_ensure_validity_writable(vector: duckdb_vector);
}
extern "C" {
    #[doc = "Assigns a string element in the vector at the specified location.\n\n vector: The vector to alter\n index: The row position in the vector to assign the string to\n str: The null-terminated string"]
    pub fn duckdb_vector_assign_string_element(
        vector: duckdb_vector,
        index: idx_t,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "Assigns a string element in the vector at the specified location. You may also use this function to assign BLOBs.\n\n vector: The vector to alter\n index: The row position in the vector to assign the string to\n str: The string\n str_len: The length of the string (in bytes)"]
    pub fn duckdb_vector_assign_string_element_len(
        vector: duckdb_vector,
        index: idx_t,
        str_: *const ::std::os::raw::c_char,
        str_len: idx_t,
    );
}
extern "C" {
    #[doc = "Retrieves the child vector of a list vector.\n\nThe resulting vector is valid as long as the parent vector is valid.\n\n vector: The vector\n returns: The child vector"]
    pub fn duckdb_list_vector_get_child(vector: duckdb_vector) -> duckdb_vector;
}
extern "C" {
    #[doc = "Returns the size of the child vector of the list.\n\n vector: The vector\n returns: The size of the child list"]
    pub fn duckdb_list_vector_get_size(vector: duckdb_vector) -> idx_t;
}
extern "C" {
    #[doc = "Sets the total size of the underlying child-vector of a list vector.\n\n vector: The list vector.\n size: The size of the child list.\n returns: The duckdb state. Returns DuckDBError if the vector is nullptr."]
    pub fn duckdb_list_vector_set_size(vector: duckdb_vector, size: idx_t) -> duckdb_state;
}
extern "C" {
    #[doc = "Sets the total capacity of the underlying child-vector of a list.\n\n vector: The list vector.\n required_capacity: the total capacity to reserve.\n return: The duckdb state. Returns DuckDBError if the vector is nullptr."]
    pub fn duckdb_list_vector_reserve(vector: duckdb_vector, required_capacity: idx_t) -> duckdb_state;
}
extern "C" {
    #[doc = "Retrieves the child vector of a struct vector.\n\nThe resulting vector is valid as long as the parent vector is valid.\n\n vector: The vector\n index: The child index\n returns: The child vector"]
    pub fn duckdb_struct_vector_get_child(vector: duckdb_vector, index: idx_t) -> duckdb_vector;
}
extern "C" {
    #[doc = "Retrieves the child vector of a array vector.\n\nThe resulting vector is valid as long as the parent vector is valid.\nThe resulting vector has the size of the parent vector multiplied by the array size.\n\n vector: The vector\n returns: The child vector"]
    pub fn duckdb_array_vector_get_child(vector: duckdb_vector) -> duckdb_vector;
}
extern "C" {
    #[doc = "Returns whether or not a row is valid (i.e. not NULL) in the given validity mask.\n\n validity: The validity mask, as obtained through `duckdb_vector_get_validity`\n row: The row index\n returns: true if the row is valid, false otherwise"]
    pub fn duckdb_validity_row_is_valid(validity: *mut u64, row: idx_t) -> bool;
}
extern "C" {
    #[doc = "In a validity mask, sets a specific row to either valid or invalid.\n\nNote that `duckdb_vector_ensure_validity_writable` should be called before calling `duckdb_vector_get_validity`,\nto ensure that there is a validity mask to write to.\n\n validity: The validity mask, as obtained through `duckdb_vector_get_validity`.\n row: The row index\n valid: Whether or not to set the row to valid, or invalid"]
    pub fn duckdb_validity_set_row_validity(validity: *mut u64, row: idx_t, valid: bool);
}
extern "C" {
    #[doc = "In a validity mask, sets a specific row to invalid.\n\nEquivalent to `duckdb_validity_set_row_validity` with valid set to false.\n\n validity: The validity mask\n row: The row index"]
    pub fn duckdb_validity_set_row_invalid(validity: *mut u64, row: idx_t);
}
extern "C" {
    #[doc = "In a validity mask, sets a specific row to valid.\n\nEquivalent to `duckdb_validity_set_row_validity` with valid set to true.\n\n validity: The validity mask\n row: The row index"]
    pub fn duckdb_validity_set_row_valid(validity: *mut u64, row: idx_t);
}
extern "C" {
    #[doc = "Creates a new empty table function.\n\nThe return value should be destroyed with `duckdb_destroy_table_function`.\n\n returns: The table function object."]
    pub fn duckdb_create_table_function() -> duckdb_table_function;
}
extern "C" {
    #[doc = "Destroys the given table function object.\n\n table_function: The table function to destroy"]
    pub fn duckdb_destroy_table_function(table_function: *mut duckdb_table_function);
}
extern "C" {
    #[doc = "Sets the name of the given table function.\n\n table_function: The table function\n name: The name of the table function"]
    pub fn duckdb_table_function_set_name(table_function: duckdb_table_function, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "Adds a parameter to the table function.\n\n table_function: The table function\n type: The type of the parameter to add."]
    pub fn duckdb_table_function_add_parameter(table_function: duckdb_table_function, type_: duckdb_logical_type);
}
extern "C" {
    #[doc = "Adds a named parameter to the table function.\n\n table_function: The table function\n name: The name of the parameter\n type: The type of the parameter to add."]
    pub fn duckdb_table_function_add_named_parameter(
        table_function: duckdb_table_function,
        name: *const ::std::os::raw::c_char,
        type_: duckdb_logical_type,
    );
}
extern "C" {
    #[doc = "Assigns extra information to the table function that can be fetched during binding, etc.\n\n table_function: The table function\n extra_info: The extra information\n destroy: The callback that will be called to destroy the bind data (if any)"]
    pub fn duckdb_table_function_set_extra_info(
        table_function: duckdb_table_function,
        extra_info: *mut ::std::os::raw::c_void,
        destroy: duckdb_delete_callback_t,
    );
}
extern "C" {
    #[doc = "Sets the bind function of the table function.\n\n table_function: The table function\n bind: The bind function"]
    pub fn duckdb_table_function_set_bind(table_function: duckdb_table_function, bind: duckdb_table_function_bind_t);
}
extern "C" {
    #[doc = "Sets the init function of the table function.\n\n table_function: The table function\n init: The init function"]
    pub fn duckdb_table_function_set_init(table_function: duckdb_table_function, init: duckdb_table_function_init_t);
}
extern "C" {
    #[doc = "Sets the thread-local init function of the table function.\n\n table_function: The table function\n init: The init function"]
    pub fn duckdb_table_function_set_local_init(
        table_function: duckdb_table_function,
        init: duckdb_table_function_init_t,
    );
}
extern "C" {
    #[doc = "Sets the main function of the table function.\n\n table_function: The table function\n function: The function"]
    pub fn duckdb_table_function_set_function(table_function: duckdb_table_function, function: duckdb_table_function_t);
}
extern "C" {
    #[doc = "Sets whether or not the given table function supports projection pushdown.\n\nIf this is set to true, the system will provide a list of all required columns in the `init` stage through\nthe `duckdb_init_get_column_count` and `duckdb_init_get_column_index` functions.\nIf this is set to false (the default), the system will expect all columns to be projected.\n\n table_function: The table function\n pushdown: True if the table function supports projection pushdown, false otherwise."]
    pub fn duckdb_table_function_supports_projection_pushdown(table_function: duckdb_table_function, pushdown: bool);
}
extern "C" {
    #[doc = "Register the table function object within the given connection.\n\nThe function requires at least a name, a bind function, an init function and a main function.\n\nIf the function is incomplete or a function with this name already exists DuckDBError is returned.\n\n con: The connection to register it in.\n function: The function pointer\n returns: Whether or not the registration was successful."]
    pub fn duckdb_register_table_function(con: duckdb_connection, function: duckdb_table_function) -> duckdb_state;
}
extern "C" {
    #[doc = "Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`.\n\n info: The info object\n returns: The extra info"]
    pub fn duckdb_bind_get_extra_info(info: duckdb_bind_info) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Adds a result column to the output of the table function.\n\n info: The info object\n name: The name of the column\n type: The logical type of the column"]
    pub fn duckdb_bind_add_result_column(
        info: duckdb_bind_info,
        name: *const ::std::os::raw::c_char,
        type_: duckdb_logical_type,
    );
}
extern "C" {
    #[doc = "Retrieves the number of regular (non-named) parameters to the function.\n\n info: The info object\n returns: The number of parameters"]
    pub fn duckdb_bind_get_parameter_count(info: duckdb_bind_info) -> idx_t;
}
extern "C" {
    #[doc = "Retrieves the parameter at the given index.\n\nThe result must be destroyed with `duckdb_destroy_value`.\n\n info: The info object\n index: The index of the parameter to get\n returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`."]
    pub fn duckdb_bind_get_parameter(info: duckdb_bind_info, index: idx_t) -> duckdb_value;
}
extern "C" {
    #[doc = "Retrieves a named parameter with the given name.\n\nThe result must be destroyed with `duckdb_destroy_value`.\n\n info: The info object\n name: The name of the parameter\n returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`."]
    pub fn duckdb_bind_get_named_parameter(info: duckdb_bind_info, name: *const ::std::os::raw::c_char)
        -> duckdb_value;
}
extern "C" {
    #[doc = "Sets the user-provided bind data in the bind object. This object can be retrieved again during execution.\n\n info: The info object\n extra_data: The bind data object.\n destroy: The callback that will be called to destroy the bind data (if any)"]
    pub fn duckdb_bind_set_bind_data(
        info: duckdb_bind_info,
        bind_data: *mut ::std::os::raw::c_void,
        destroy: duckdb_delete_callback_t,
    );
}
extern "C" {
    #[doc = "Sets the cardinality estimate for the table function, used for optimization.\n\n info: The bind data object.\n is_exact: Whether or not the cardinality estimate is exact, or an approximation"]
    pub fn duckdb_bind_set_cardinality(info: duckdb_bind_info, cardinality: idx_t, is_exact: bool);
}
extern "C" {
    #[doc = "Report that an error has occurred while calling bind.\n\n info: The info object\n error: The error message"]
    pub fn duckdb_bind_set_error(info: duckdb_bind_info, error: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`.\n\n info: The info object\n returns: The extra info"]
    pub fn duckdb_init_get_extra_info(info: duckdb_init_info) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.\n\nNote that the bind data should be considered as read-only.\nFor tracking state, use the init data instead.\n\n info: The info object\n returns: The bind data object"]
    pub fn duckdb_init_get_bind_data(info: duckdb_init_info) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Sets the user-provided init data in the init object. This object can be retrieved again during execution.\n\n info: The info object\n extra_data: The init data object.\n destroy: The callback that will be called to destroy the init data (if any)"]
    pub fn duckdb_init_set_init_data(
        info: duckdb_init_info,
        init_data: *mut ::std::os::raw::c_void,
        destroy: duckdb_delete_callback_t,
    );
}
extern "C" {
    #[doc = "Returns the number of projected columns.\n\nThis function must be used if projection pushdown is enabled to figure out which columns to emit.\n\n info: The info object\n returns: The number of projected columns."]
    pub fn duckdb_init_get_column_count(info: duckdb_init_info) -> idx_t;
}
extern "C" {
    #[doc = "Returns the column index of the projected column at the specified position.\n\nThis function must be used if projection pushdown is enabled to figure out which columns to emit.\n\n info: The info object\n column_index: The index at which to get the projected column index, from 0..duckdb_init_get_column_count(info)\n returns: The column index of the projected column."]
    pub fn duckdb_init_get_column_index(info: duckdb_init_info, column_index: idx_t) -> idx_t;
}
extern "C" {
    #[doc = "Sets how many threads can process this table function in parallel (default: 1)\n\n info: The info object\n max_threads: The maximum amount of threads that can process this table function"]
    pub fn duckdb_init_set_max_threads(info: duckdb_init_info, max_threads: idx_t);
}
extern "C" {
    #[doc = "Report that an error has occurred while calling init.\n\n info: The info object\n error: The error message"]
    pub fn duckdb_init_set_error(info: duckdb_init_info, error: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`.\n\n info: The info object\n returns: The extra info"]
    pub fn duckdb_function_get_extra_info(info: duckdb_function_info) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.\n\nNote that the bind data should be considered as read-only.\nFor tracking state, use the init data instead.\n\n info: The info object\n returns: The bind data object"]
    pub fn duckdb_function_get_bind_data(info: duckdb_function_info) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Gets the init data set by `duckdb_init_set_init_data` during the init.\n\n info: The info object\n returns: The init data object"]
    pub fn duckdb_function_get_init_data(info: duckdb_function_info) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Gets the thread-local init data set by `duckdb_init_set_init_data` during the local_init.\n\n info: The info object\n returns: The init data object"]
    pub fn duckdb_function_get_local_init_data(info: duckdb_function_info) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Report that an error has occurred while executing the function.\n\n info: The info object\n error: The error message"]
    pub fn duckdb_function_set_error(info: duckdb_function_info, error: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "Add a replacement scan definition to the specified database.\n\n db: The database object to add the replacement scan to\n replacement: The replacement scan callback\n extra_data: Extra data that is passed back into the specified callback\n delete_callback: The delete callback to call on the extra data, if any"]
    pub fn duckdb_add_replacement_scan(
        db: duckdb_database,
        replacement: duckdb_replacement_callback_t,
        extra_data: *mut ::std::os::raw::c_void,
        delete_callback: duckdb_delete_callback_t,
    );
}
extern "C" {
    #[doc = "Sets the replacement function name. If this function is called in the replacement callback,\nthe replacement scan is performed. If it is not called, the replacement callback is not performed.\n\n info: The info object\n function_name: The function name to substitute."]
    pub fn duckdb_replacement_scan_set_function_name(
        info: duckdb_replacement_scan_info,
        function_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "Adds a parameter to the replacement scan function.\n\n info: The info object\n parameter: The parameter to add."]
    pub fn duckdb_replacement_scan_add_parameter(info: duckdb_replacement_scan_info, parameter: duckdb_value);
}
extern "C" {
    #[doc = "Report that an error has occurred while executing the replacement scan.\n\n info: The info object\n error: The error message"]
    pub fn duckdb_replacement_scan_set_error(info: duckdb_replacement_scan_info, error: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "Creates an appender object.\n\nNote that the object must be destroyed with `duckdb_appender_destroy`.\n\n connection: The connection context to create the appender in.\n schema: The schema of the table to append to, or `nullptr` for the default schema.\n table: The table name to append to.\n out_appender: The resulting appender object.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_appender_create(
        connection: duckdb_connection,
        schema: *const ::std::os::raw::c_char,
        table: *const ::std::os::raw::c_char,
        out_appender: *mut duckdb_appender,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Returns the number of columns in the table that belongs to the appender.\n\n appender The appender to get the column count from.\n returns: The number of columns in the table."]
    pub fn duckdb_appender_column_count(appender: duckdb_appender) -> idx_t;
}
extern "C" {
    #[doc = "Returns the type of the column at the specified index.\n\nNote: The resulting type should be destroyed with `duckdb_destroy_logical_type`.\n\n appender The appender to get the column type from.\n col_idx The index of the column to get the type of.\n returns: The duckdb_logical_type of the column."]
    pub fn duckdb_appender_column_type(appender: duckdb_appender, col_idx: idx_t) -> duckdb_logical_type;
}
extern "C" {
    #[doc = "Returns the error message associated with the given appender.\nIf the appender has no error message, this returns `nullptr` instead.\n\nThe error message should not be freed. It will be de-allocated when `duckdb_appender_destroy` is called.\n\n appender: The appender to get the error from.\n returns: The error message, or `nullptr` if there is none."]
    pub fn duckdb_appender_error(appender: duckdb_appender) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Flush the appender to the table, forcing the cache of the appender to be cleared and the data to be appended to the\nbase table.\n\nThis should generally not be used unless you know what you are doing. Instead, call `duckdb_appender_destroy` when you\nare done with the appender.\n\n appender: The appender to flush.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_appender_flush(appender: duckdb_appender) -> duckdb_state;
}
extern "C" {
    #[doc = "Close the appender, flushing all intermediate state in the appender to the table and closing it for further appends.\n\nThis is generally not necessary. Call `duckdb_appender_destroy` instead.\n\n appender: The appender to flush and close.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_appender_close(appender: duckdb_appender) -> duckdb_state;
}
extern "C" {
    #[doc = "Close the appender and destroy it. Flushing all intermediate state in the appender to the table, and de-allocating\nall memory associated with the appender.\n\n appender: The appender to flush, close and destroy.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_appender_destroy(appender: *mut duckdb_appender) -> duckdb_state;
}
extern "C" {
    #[doc = "A nop function, provided for backwards compatibility reasons. Does nothing. Only `duckdb_appender_end_row` is required."]
    pub fn duckdb_appender_begin_row(appender: duckdb_appender) -> duckdb_state;
}
extern "C" {
    #[doc = "Finish the current row of appends. After end_row is called, the next row can be appended.\n\n appender: The appender.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_appender_end_row(appender: duckdb_appender) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a bool value to the appender."]
    pub fn duckdb_append_bool(appender: duckdb_appender, value: bool) -> duckdb_state;
}
extern "C" {
    #[doc = "Append an int8_t value to the appender."]
    pub fn duckdb_append_int8(appender: duckdb_appender, value: i8) -> duckdb_state;
}
extern "C" {
    #[doc = "Append an int16_t value to the appender."]
    pub fn duckdb_append_int16(appender: duckdb_appender, value: i16) -> duckdb_state;
}
extern "C" {
    #[doc = "Append an int32_t value to the appender."]
    pub fn duckdb_append_int32(appender: duckdb_appender, value: i32) -> duckdb_state;
}
extern "C" {
    #[doc = "Append an int64_t value to the appender."]
    pub fn duckdb_append_int64(appender: duckdb_appender, value: i64) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a duckdb_hugeint value to the appender."]
    pub fn duckdb_append_hugeint(appender: duckdb_appender, value: duckdb_hugeint) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a uint8_t value to the appender."]
    pub fn duckdb_append_uint8(appender: duckdb_appender, value: u8) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a uint16_t value to the appender."]
    pub fn duckdb_append_uint16(appender: duckdb_appender, value: u16) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a uint32_t value to the appender."]
    pub fn duckdb_append_uint32(appender: duckdb_appender, value: u32) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a uint64_t value to the appender."]
    pub fn duckdb_append_uint64(appender: duckdb_appender, value: u64) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a duckdb_uhugeint value to the appender."]
    pub fn duckdb_append_uhugeint(appender: duckdb_appender, value: duckdb_uhugeint) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a float value to the appender."]
    pub fn duckdb_append_float(appender: duckdb_appender, value: f32) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a double value to the appender."]
    pub fn duckdb_append_double(appender: duckdb_appender, value: f64) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a duckdb_date value to the appender."]
    pub fn duckdb_append_date(appender: duckdb_appender, value: duckdb_date) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a duckdb_time value to the appender."]
    pub fn duckdb_append_time(appender: duckdb_appender, value: duckdb_time) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a duckdb_timestamp value to the appender."]
    pub fn duckdb_append_timestamp(appender: duckdb_appender, value: duckdb_timestamp) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a duckdb_interval value to the appender."]
    pub fn duckdb_append_interval(appender: duckdb_appender, value: duckdb_interval) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a varchar value to the appender."]
    pub fn duckdb_append_varchar(appender: duckdb_appender, val: *const ::std::os::raw::c_char) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a varchar value to the appender."]
    pub fn duckdb_append_varchar_length(
        appender: duckdb_appender,
        val: *const ::std::os::raw::c_char,
        length: idx_t,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a blob value to the appender."]
    pub fn duckdb_append_blob(
        appender: duckdb_appender,
        data: *const ::std::os::raw::c_void,
        length: idx_t,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Append a NULL value to the appender (of any type)."]
    pub fn duckdb_append_null(appender: duckdb_appender) -> duckdb_state;
}
extern "C" {
    #[doc = "Appends a pre-filled data chunk to the specified appender.\n\nThe types of the data chunk must exactly match the types of the table, no casting is performed.\nIf the types do not match or the appender is in an invalid state, DuckDBError is returned.\nIf the append is successful, DuckDBSuccess is returned.\n\n appender: The appender to append to.\n chunk: The data chunk to append.\n returns: The return state."]
    pub fn duckdb_append_data_chunk(appender: duckdb_appender, chunk: duckdb_data_chunk) -> duckdb_state;
}
extern "C" {
    #[doc = "Executes a SQL query within a connection and stores the full (materialized) result in an arrow structure.\nIf the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling\n`duckdb_query_arrow_error`.\n\nNote that after running `duckdb_query_arrow`, `duckdb_destroy_arrow` must be called on the result object even if the\nquery fails, otherwise the error stored within the result will not be freed correctly.\n\n connection: The connection to perform the query in.\n query: The SQL query to run.\n out_result: The query result.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_query_arrow(
        connection: duckdb_connection,
        query: *const ::std::os::raw::c_char,
        out_result: *mut duckdb_arrow,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Fetch the internal arrow schema from the arrow result. Remember to call release on the respective\nArrowSchema object.\n\n result: The result to fetch the schema from.\n out_schema: The output schema.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_query_arrow_schema(result: duckdb_arrow, out_schema: *mut duckdb_arrow_schema) -> duckdb_state;
}
extern "C" {
    #[doc = "Fetch the internal arrow schema from the prepared statement. Remember to call release on the respective\nArrowSchema object.\n\n result: The prepared statement to fetch the schema from.\n out_schema: The output schema.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_prepared_arrow_schema(
        prepared: duckdb_prepared_statement,
        out_schema: *mut duckdb_arrow_schema,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Convert a data chunk into an arrow struct array. Remember to call release on the respective\nArrowArray object.\n\n result: The result object the data chunk have been fetched from.\n chunk: The data chunk to convert.\n out_array: The output array."]
    pub fn duckdb_result_arrow_array(
        result: duckdb_result,
        chunk: duckdb_data_chunk,
        out_array: *mut duckdb_arrow_array,
    );
}
extern "C" {
    #[doc = "Fetch an internal arrow struct array from the arrow result. Remember to call release on the respective\nArrowArray object.\n\nThis function can be called multiple time to get next chunks, which will free the previous out_array.\nSo consume the out_array before calling this function again.\n\n result: The result to fetch the array from.\n out_array: The output array.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_query_arrow_array(result: duckdb_arrow, out_array: *mut duckdb_arrow_array) -> duckdb_state;
}
extern "C" {
    #[doc = "Returns the number of columns present in the arrow result object.\n\n result: The result object.\n returns: The number of columns present in the result object."]
    pub fn duckdb_arrow_column_count(result: duckdb_arrow) -> idx_t;
}
extern "C" {
    #[doc = "Returns the number of rows present in the arrow result object.\n\n result: The result object.\n returns: The number of rows present in the result object."]
    pub fn duckdb_arrow_row_count(result: duckdb_arrow) -> idx_t;
}
extern "C" {
    #[doc = "Returns the number of rows changed by the query stored in the arrow result. This is relevant only for\nINSERT/UPDATE/DELETE queries. For other queries the rows_changed will be 0.\n\n result: The result object.\n returns: The number of rows changed."]
    pub fn duckdb_arrow_rows_changed(result: duckdb_arrow) -> idx_t;
}
extern "C" {
    #[doc = "Returns the error message contained within the result. The error is only set if `duckdb_query_arrow` returns\n`DuckDBError`.\n\nThe error message should not be freed. It will be de-allocated when `duckdb_destroy_arrow` is called.\n\n result: The result object to fetch the error from.\n returns: The error of the result."]
    pub fn duckdb_query_arrow_error(result: duckdb_arrow) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Closes the result and de-allocates all memory allocated for the arrow result.\n\n result: The result to destroy."]
    pub fn duckdb_destroy_arrow(result: *mut duckdb_arrow);
}
extern "C" {
    #[doc = "Releases the arrow array stream and de-allocates its memory.\n\n stream: The arrow array stream to destroy."]
    pub fn duckdb_destroy_arrow_stream(stream_p: *mut duckdb_arrow_stream);
}
extern "C" {
    #[doc = "Executes the prepared statement with the given bound parameters, and returns an arrow query result.\nNote that after running `duckdb_execute_prepared_arrow`, `duckdb_destroy_arrow` must be called on the result object.\n\n prepared_statement: The prepared statement to execute.\n out_result: The query result.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_execute_prepared_arrow(
        prepared_statement: duckdb_prepared_statement,
        out_result: *mut duckdb_arrow,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Scans the Arrow stream and creates a view with the given name.\n\n connection: The connection on which to execute the scan.\n table_name: Name of the temporary view to create.\n arrow: Arrow stream wrapper.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_arrow_scan(
        connection: duckdb_connection,
        table_name: *const ::std::os::raw::c_char,
        arrow: duckdb_arrow_stream,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Scans the Arrow array and creates a view with the given name.\nNote that after running `duckdb_arrow_array_scan`, `duckdb_destroy_arrow_stream` must be called on the out stream.\n\n connection: The connection on which to execute the scan.\n table_name: Name of the temporary view to create.\n arrow_schema: Arrow schema wrapper.\n arrow_array: Arrow array wrapper.\n out_stream: Output array stream that wraps around the passed schema, for releasing/deleting once done.\n returns: `DuckDBSuccess` on success or `DuckDBError` on failure."]
    pub fn duckdb_arrow_array_scan(
        connection: duckdb_connection,
        table_name: *const ::std::os::raw::c_char,
        arrow_schema: duckdb_arrow_schema,
        arrow_array: duckdb_arrow_array,
        out_stream: *mut duckdb_arrow_stream,
    ) -> duckdb_state;
}
extern "C" {
    #[doc = "Execute DuckDB tasks on this thread.\n\nWill return after `max_tasks` have been executed, or if there are no more tasks present.\n\n database: The database object to execute tasks for\n max_tasks: The maximum amount of tasks to execute"]
    pub fn duckdb_execute_tasks(database: duckdb_database, max_tasks: idx_t);
}
extern "C" {
    #[doc = "Creates a task state that can be used with duckdb_execute_tasks_state to execute tasks until\n`duckdb_finish_execution` is called on the state.\n\n`duckdb_destroy_state` must be called on the result.\n\n database: The database object to create the task state for\n returns: The task state that can be used with duckdb_execute_tasks_state."]
    pub fn duckdb_create_task_state(database: duckdb_database) -> duckdb_task_state;
}
extern "C" {
    #[doc = "Execute DuckDB tasks on this thread.\n\nThe thread will keep on executing tasks forever, until duckdb_finish_execution is called on the state.\nMultiple threads can share the same duckdb_task_state.\n\n state: The task state of the executor"]
    pub fn duckdb_execute_tasks_state(state: duckdb_task_state);
}
extern "C" {
    #[doc = "Execute DuckDB tasks on this thread.\n\nThe thread will keep on executing tasks until either duckdb_finish_execution is called on the state,\nmax_tasks tasks have been executed or there are no more tasks to be executed.\n\nMultiple threads can share the same duckdb_task_state.\n\n state: The task state of the executor\n max_tasks: The maximum amount of tasks to execute\n returns: The amount of tasks that have actually been executed"]
    pub fn duckdb_execute_n_tasks_state(state: duckdb_task_state, max_tasks: idx_t) -> idx_t;
}
extern "C" {
    #[doc = "Finish execution on a specific task.\n\n state: The task state to finish execution"]
    pub fn duckdb_finish_execution(state: duckdb_task_state);
}
extern "C" {
    #[doc = "Check if the provided duckdb_task_state has finished execution\n\n state: The task state to inspect\n returns: Whether or not duckdb_finish_execution has been called on the task state"]
    pub fn duckdb_task_state_is_finished(state: duckdb_task_state) -> bool;
}
extern "C" {
    #[doc = "Destroys the task state returned from duckdb_create_task_state.\n\nNote that this should not be called while there is an active duckdb_execute_tasks_state running\non the task state.\n\n state: The task state to clean up"]
    pub fn duckdb_destroy_task_state(state: duckdb_task_state);
}
extern "C" {
    #[doc = "Returns true if the execution of the current query is finished.\n\n con: The connection on which to check"]
    pub fn duckdb_execution_is_finished(con: duckdb_connection) -> bool;
}
extern "C" {
    #[doc = "Fetches a data chunk from the (streaming) duckdb_result. This function should be called repeatedly until the result is\nexhausted.\n\nThe result must be destroyed with `duckdb_destroy_data_chunk`.\n\nThis function can only be used on duckdb_results created with 'duckdb_pending_prepared_streaming'\n\nIf this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be\nmixed with the legacy result functions or the materialized result functions).\n\nIt is not known beforehand how many chunks will be returned by this result.\n\n result: The result object to fetch the data chunk from.\n returns: The resulting data chunk. Returns `NULL` if the result has an error."]
    pub fn duckdb_stream_fetch_chunk(result: duckdb_result) -> duckdb_data_chunk;
}
