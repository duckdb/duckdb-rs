/* automatically generated by rust-bindgen 0.69.4 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __WORDSIZE: u32 = 64;
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const DUCKDB_EXTENSION_API_VERSION_MAJOR: u32 = 0;
pub const DUCKDB_EXTENSION_API_VERSION_MINOR: u32 = 0;
pub const DUCKDB_EXTENSION_API_VERSION_PATCH: u32 = 2;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type rsize_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub const DUCKDB_TYPE_DUCKDB_TYPE_INVALID: DUCKDB_TYPE = 0;
pub const DUCKDB_TYPE_DUCKDB_TYPE_BOOLEAN: DUCKDB_TYPE = 1;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TINYINT: DUCKDB_TYPE = 2;
pub const DUCKDB_TYPE_DUCKDB_TYPE_SMALLINT: DUCKDB_TYPE = 3;
pub const DUCKDB_TYPE_DUCKDB_TYPE_INTEGER: DUCKDB_TYPE = 4;
pub const DUCKDB_TYPE_DUCKDB_TYPE_BIGINT: DUCKDB_TYPE = 5;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UTINYINT: DUCKDB_TYPE = 6;
pub const DUCKDB_TYPE_DUCKDB_TYPE_USMALLINT: DUCKDB_TYPE = 7;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UINTEGER: DUCKDB_TYPE = 8;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UBIGINT: DUCKDB_TYPE = 9;
pub const DUCKDB_TYPE_DUCKDB_TYPE_FLOAT: DUCKDB_TYPE = 10;
pub const DUCKDB_TYPE_DUCKDB_TYPE_DOUBLE: DUCKDB_TYPE = 11;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIMESTAMP: DUCKDB_TYPE = 12;
pub const DUCKDB_TYPE_DUCKDB_TYPE_DATE: DUCKDB_TYPE = 13;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIME: DUCKDB_TYPE = 14;
pub const DUCKDB_TYPE_DUCKDB_TYPE_INTERVAL: DUCKDB_TYPE = 15;
pub const DUCKDB_TYPE_DUCKDB_TYPE_HUGEINT: DUCKDB_TYPE = 16;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UHUGEINT: DUCKDB_TYPE = 32;
pub const DUCKDB_TYPE_DUCKDB_TYPE_VARCHAR: DUCKDB_TYPE = 17;
pub const DUCKDB_TYPE_DUCKDB_TYPE_BLOB: DUCKDB_TYPE = 18;
pub const DUCKDB_TYPE_DUCKDB_TYPE_DECIMAL: DUCKDB_TYPE = 19;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIMESTAMP_S: DUCKDB_TYPE = 20;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIMESTAMP_MS: DUCKDB_TYPE = 21;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIMESTAMP_NS: DUCKDB_TYPE = 22;
pub const DUCKDB_TYPE_DUCKDB_TYPE_ENUM: DUCKDB_TYPE = 23;
pub const DUCKDB_TYPE_DUCKDB_TYPE_LIST: DUCKDB_TYPE = 24;
pub const DUCKDB_TYPE_DUCKDB_TYPE_STRUCT: DUCKDB_TYPE = 25;
pub const DUCKDB_TYPE_DUCKDB_TYPE_MAP: DUCKDB_TYPE = 26;
pub const DUCKDB_TYPE_DUCKDB_TYPE_ARRAY: DUCKDB_TYPE = 33;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UUID: DUCKDB_TYPE = 27;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UNION: DUCKDB_TYPE = 28;
pub const DUCKDB_TYPE_DUCKDB_TYPE_BIT: DUCKDB_TYPE = 29;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIME_TZ: DUCKDB_TYPE = 30;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIMESTAMP_TZ: DUCKDB_TYPE = 31;
pub const DUCKDB_TYPE_DUCKDB_TYPE_ANY: DUCKDB_TYPE = 34;
pub const DUCKDB_TYPE_DUCKDB_TYPE_VARINT: DUCKDB_TYPE = 35;
#[doc = "! An enum over DuckDB's internal types."]
pub type DUCKDB_TYPE = ::std::os::raw::c_uint;
#[doc = "! An enum over DuckDB's internal types."]
pub use self::DUCKDB_TYPE as duckdb_type;
pub const duckdb_state_DuckDBSuccess: duckdb_state = 0;
pub const duckdb_state_DuckDBError: duckdb_state = 1;
#[doc = "! An enum over the returned state of different functions."]
pub type duckdb_state = ::std::os::raw::c_uint;
pub const duckdb_pending_state_DUCKDB_PENDING_RESULT_READY: duckdb_pending_state = 0;
pub const duckdb_pending_state_DUCKDB_PENDING_RESULT_NOT_READY: duckdb_pending_state = 1;
pub const duckdb_pending_state_DUCKDB_PENDING_ERROR: duckdb_pending_state = 2;
pub const duckdb_pending_state_DUCKDB_PENDING_NO_TASKS_AVAILABLE: duckdb_pending_state = 3;
#[doc = "! An enum over the pending state of a pending query result."]
pub type duckdb_pending_state = ::std::os::raw::c_uint;
pub const duckdb_result_type_DUCKDB_RESULT_TYPE_INVALID: duckdb_result_type = 0;
pub const duckdb_result_type_DUCKDB_RESULT_TYPE_CHANGED_ROWS: duckdb_result_type = 1;
pub const duckdb_result_type_DUCKDB_RESULT_TYPE_NOTHING: duckdb_result_type = 2;
pub const duckdb_result_type_DUCKDB_RESULT_TYPE_QUERY_RESULT: duckdb_result_type = 3;
#[doc = "! An enum over DuckDB's different result types."]
pub type duckdb_result_type = ::std::os::raw::c_uint;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_INVALID: duckdb_statement_type = 0;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_SELECT: duckdb_statement_type = 1;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_INSERT: duckdb_statement_type = 2;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_UPDATE: duckdb_statement_type = 3;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_EXPLAIN: duckdb_statement_type = 4;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_DELETE: duckdb_statement_type = 5;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_PREPARE: duckdb_statement_type = 6;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_CREATE: duckdb_statement_type = 7;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_EXECUTE: duckdb_statement_type = 8;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_ALTER: duckdb_statement_type = 9;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_TRANSACTION: duckdb_statement_type = 10;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_COPY: duckdb_statement_type = 11;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_ANALYZE: duckdb_statement_type = 12;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_VARIABLE_SET: duckdb_statement_type = 13;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_CREATE_FUNC: duckdb_statement_type = 14;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_DROP: duckdb_statement_type = 15;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_EXPORT: duckdb_statement_type = 16;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_PRAGMA: duckdb_statement_type = 17;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_VACUUM: duckdb_statement_type = 18;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_CALL: duckdb_statement_type = 19;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_SET: duckdb_statement_type = 20;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_LOAD: duckdb_statement_type = 21;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_RELATION: duckdb_statement_type = 22;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_EXTENSION: duckdb_statement_type = 23;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_LOGICAL_PLAN: duckdb_statement_type = 24;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_ATTACH: duckdb_statement_type = 25;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_DETACH: duckdb_statement_type = 26;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_MULTI: duckdb_statement_type = 27;
#[doc = "! An enum over DuckDB's different statement types."]
pub type duckdb_statement_type = ::std::os::raw::c_uint;
pub const duckdb_error_type_DUCKDB_ERROR_INVALID: duckdb_error_type = 0;
pub const duckdb_error_type_DUCKDB_ERROR_OUT_OF_RANGE: duckdb_error_type = 1;
pub const duckdb_error_type_DUCKDB_ERROR_CONVERSION: duckdb_error_type = 2;
pub const duckdb_error_type_DUCKDB_ERROR_UNKNOWN_TYPE: duckdb_error_type = 3;
pub const duckdb_error_type_DUCKDB_ERROR_DECIMAL: duckdb_error_type = 4;
pub const duckdb_error_type_DUCKDB_ERROR_MISMATCH_TYPE: duckdb_error_type = 5;
pub const duckdb_error_type_DUCKDB_ERROR_DIVIDE_BY_ZERO: duckdb_error_type = 6;
pub const duckdb_error_type_DUCKDB_ERROR_OBJECT_SIZE: duckdb_error_type = 7;
pub const duckdb_error_type_DUCKDB_ERROR_INVALID_TYPE: duckdb_error_type = 8;
pub const duckdb_error_type_DUCKDB_ERROR_SERIALIZATION: duckdb_error_type = 9;
pub const duckdb_error_type_DUCKDB_ERROR_TRANSACTION: duckdb_error_type = 10;
pub const duckdb_error_type_DUCKDB_ERROR_NOT_IMPLEMENTED: duckdb_error_type = 11;
pub const duckdb_error_type_DUCKDB_ERROR_EXPRESSION: duckdb_error_type = 12;
pub const duckdb_error_type_DUCKDB_ERROR_CATALOG: duckdb_error_type = 13;
pub const duckdb_error_type_DUCKDB_ERROR_PARSER: duckdb_error_type = 14;
pub const duckdb_error_type_DUCKDB_ERROR_PLANNER: duckdb_error_type = 15;
pub const duckdb_error_type_DUCKDB_ERROR_SCHEDULER: duckdb_error_type = 16;
pub const duckdb_error_type_DUCKDB_ERROR_EXECUTOR: duckdb_error_type = 17;
pub const duckdb_error_type_DUCKDB_ERROR_CONSTRAINT: duckdb_error_type = 18;
pub const duckdb_error_type_DUCKDB_ERROR_INDEX: duckdb_error_type = 19;
pub const duckdb_error_type_DUCKDB_ERROR_STAT: duckdb_error_type = 20;
pub const duckdb_error_type_DUCKDB_ERROR_CONNECTION: duckdb_error_type = 21;
pub const duckdb_error_type_DUCKDB_ERROR_SYNTAX: duckdb_error_type = 22;
pub const duckdb_error_type_DUCKDB_ERROR_SETTINGS: duckdb_error_type = 23;
pub const duckdb_error_type_DUCKDB_ERROR_BINDER: duckdb_error_type = 24;
pub const duckdb_error_type_DUCKDB_ERROR_NETWORK: duckdb_error_type = 25;
pub const duckdb_error_type_DUCKDB_ERROR_OPTIMIZER: duckdb_error_type = 26;
pub const duckdb_error_type_DUCKDB_ERROR_NULL_POINTER: duckdb_error_type = 27;
pub const duckdb_error_type_DUCKDB_ERROR_IO: duckdb_error_type = 28;
pub const duckdb_error_type_DUCKDB_ERROR_INTERRUPT: duckdb_error_type = 29;
pub const duckdb_error_type_DUCKDB_ERROR_FATAL: duckdb_error_type = 30;
pub const duckdb_error_type_DUCKDB_ERROR_INTERNAL: duckdb_error_type = 31;
pub const duckdb_error_type_DUCKDB_ERROR_INVALID_INPUT: duckdb_error_type = 32;
pub const duckdb_error_type_DUCKDB_ERROR_OUT_OF_MEMORY: duckdb_error_type = 33;
pub const duckdb_error_type_DUCKDB_ERROR_PERMISSION: duckdb_error_type = 34;
pub const duckdb_error_type_DUCKDB_ERROR_PARAMETER_NOT_RESOLVED: duckdb_error_type = 35;
pub const duckdb_error_type_DUCKDB_ERROR_PARAMETER_NOT_ALLOWED: duckdb_error_type = 36;
pub const duckdb_error_type_DUCKDB_ERROR_DEPENDENCY: duckdb_error_type = 37;
pub const duckdb_error_type_DUCKDB_ERROR_HTTP: duckdb_error_type = 38;
pub const duckdb_error_type_DUCKDB_ERROR_MISSING_EXTENSION: duckdb_error_type = 39;
pub const duckdb_error_type_DUCKDB_ERROR_AUTOLOAD: duckdb_error_type = 40;
pub const duckdb_error_type_DUCKDB_ERROR_SEQUENCE: duckdb_error_type = 41;
pub const duckdb_error_type_DUCKDB_INVALID_CONFIGURATION: duckdb_error_type = 42;
#[doc = "! An enum over DuckDB's different result types."]
pub type duckdb_error_type = ::std::os::raw::c_uint;
#[doc = "! DuckDB's index type."]
pub type idx_t = u64;
#[doc = "! The callback that will be called to destroy data, e.g.,\n! bind data (if any), init data (if any), extra data for replacement scans (if any)"]
pub type duckdb_delete_callback_t = ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
#[doc = "! Used for threading, contains a task state. Must be destroyed with `duckdb_destroy_state`."]
pub type duckdb_task_state = *mut ::std::os::raw::c_void;
#[doc = "! Days are stored as days since 1970-01-01\n! Use the duckdb_from_date/duckdb_to_date function to extract individual information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_date {
    pub days: i32,
}
#[test]
fn bindgen_test_layout_duckdb_date() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_date> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_date>(),
        4usize,
        concat!("Size of: ", stringify!(duckdb_date))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_date>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_date))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).days) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_date), "::", stringify!(days))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_date_struct {
    pub year: i32,
    pub month: i8,
    pub day: i8,
}
#[test]
fn bindgen_test_layout_duckdb_date_struct() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_date_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_date_struct>(),
        8usize,
        concat!("Size of: ", stringify!(duckdb_date_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_date_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_date_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).year) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_date_struct),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_date_struct),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_date_struct),
            "::",
            stringify!(day)
        )
    );
}
#[doc = "! Time is stored as microseconds since 00:00:00\n! Use the duckdb_from_time/duckdb_to_time function to extract individual information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_time {
    pub micros: i64,
}
#[test]
fn bindgen_test_layout_duckdb_time() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_time> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_time>(),
        8usize,
        concat!("Size of: ", stringify!(duckdb_time))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_time>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_time))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).micros) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_time), "::", stringify!(micros))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_time_struct {
    pub hour: i8,
    pub min: i8,
    pub sec: i8,
    pub micros: i32,
}
#[test]
fn bindgen_test_layout_duckdb_time_struct() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_time_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_time_struct>(),
        8usize,
        concat!("Size of: ", stringify!(duckdb_time_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_time_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_time_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hour) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_struct),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_struct),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sec) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_struct),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).micros) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_struct),
            "::",
            stringify!(micros)
        )
    );
}
#[doc = "! TIME_TZ is stored as 40 bits for int64_t micros, and 24 bits for int32_t offset"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_time_tz {
    pub bits: u64,
}
#[test]
fn bindgen_test_layout_duckdb_time_tz() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_time_tz> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_time_tz>(),
        8usize,
        concat!("Size of: ", stringify!(duckdb_time_tz))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_time_tz>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_time_tz))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_time_tz), "::", stringify!(bits))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_time_tz_struct {
    pub time: duckdb_time_struct,
    pub offset: i32,
}
#[test]
fn bindgen_test_layout_duckdb_time_tz_struct() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_time_tz_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_time_tz_struct>(),
        12usize,
        concat!("Size of: ", stringify!(duckdb_time_tz_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_time_tz_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_time_tz_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_tz_struct),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_tz_struct),
            "::",
            stringify!(offset)
        )
    );
}
#[doc = "! Timestamps are stored as microseconds since 1970-01-01\n! Use the duckdb_from_timestamp/duckdb_to_timestamp function to extract individual information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_timestamp {
    pub micros: i64,
}
#[test]
fn bindgen_test_layout_duckdb_timestamp() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_timestamp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_timestamp>(),
        8usize,
        concat!("Size of: ", stringify!(duckdb_timestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_timestamp>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_timestamp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).micros) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_timestamp),
            "::",
            stringify!(micros)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_timestamp_struct {
    pub date: duckdb_date_struct,
    pub time: duckdb_time_struct,
}
#[test]
fn bindgen_test_layout_duckdb_timestamp_struct() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_timestamp_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_timestamp_struct>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_timestamp_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_timestamp_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_timestamp_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).date) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_timestamp_struct),
            "::",
            stringify!(date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_timestamp_struct),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_interval {
    pub months: i32,
    pub days: i32,
    pub micros: i64,
}
#[test]
fn bindgen_test_layout_duckdb_interval() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_interval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_interval>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_interval))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_interval>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_interval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).months) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_interval),
            "::",
            stringify!(months)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).days) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(duckdb_interval), "::", stringify!(days))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).micros) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_interval),
            "::",
            stringify!(micros)
        )
    );
}
#[doc = "! Hugeints are composed of a (lower, upper) component\n! The value of the hugeint is upper * 2^64 + lower\n! For easy usage, the functions duckdb_hugeint_to_double/duckdb_double_to_hugeint are recommended"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_hugeint {
    pub lower: u64,
    pub upper: i64,
}
#[test]
fn bindgen_test_layout_duckdb_hugeint() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_hugeint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_hugeint>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_hugeint))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_hugeint>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_hugeint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lower) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_hugeint), "::", stringify!(lower))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).upper) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(duckdb_hugeint), "::", stringify!(upper))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_uhugeint {
    pub lower: u64,
    pub upper: u64,
}
#[test]
fn bindgen_test_layout_duckdb_uhugeint() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_uhugeint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_uhugeint>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_uhugeint))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_uhugeint>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_uhugeint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lower) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_uhugeint),
            "::",
            stringify!(lower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).upper) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_uhugeint),
            "::",
            stringify!(upper)
        )
    );
}
#[doc = "! Decimals are composed of a width and a scale, and are stored in a hugeint"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_decimal {
    pub width: u8,
    pub scale: u8,
    pub value: duckdb_hugeint,
}
#[test]
fn bindgen_test_layout_duckdb_decimal() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_decimal> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_decimal>(),
        24usize,
        concat!("Size of: ", stringify!(duckdb_decimal))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_decimal>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_decimal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_decimal), "::", stringify!(width))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        1usize,
        concat!("Offset of field: ", stringify!(duckdb_decimal), "::", stringify!(scale))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(duckdb_decimal), "::", stringify!(value))
    );
}
#[doc = "! A type holding information about the query execution progress"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_query_progress_type {
    pub percentage: f64,
    pub rows_processed: u64,
    pub total_rows_to_process: u64,
}
#[test]
fn bindgen_test_layout_duckdb_query_progress_type() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_query_progress_type> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_query_progress_type>(),
        24usize,
        concat!("Size of: ", stringify!(duckdb_query_progress_type))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_query_progress_type>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_query_progress_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).percentage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_query_progress_type),
            "::",
            stringify!(percentage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rows_processed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_query_progress_type),
            "::",
            stringify!(rows_processed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_rows_to_process) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_query_progress_type),
            "::",
            stringify!(total_rows_to_process)
        )
    );
}
#[doc = "! The internal representation of a VARCHAR (string_t). If the VARCHAR does not\n! exceed 12 characters, then we inline it. Otherwise, we inline a prefix for faster\n! string comparisons and store a pointer to the remaining characters. This is a non-\n! owning structure, i.e., it does not have to be freed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct duckdb_string_t {
    pub value: duckdb_string_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union duckdb_string_t__bindgen_ty_1 {
    pub pointer: duckdb_string_t__bindgen_ty_1__bindgen_ty_1,
    pub inlined: duckdb_string_t__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_string_t__bindgen_ty_1__bindgen_ty_1 {
    pub length: u32,
    pub prefix: [::std::os::raw::c_char; 4usize],
    pub ptr: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_duckdb_string_t__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string_t__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string_t__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_string_t__bindgen_ty_1__bindgen_ty_2 {
    pub length: u32,
    pub inlined: [::std::os::raw::c_char; 12usize],
}
#[test]
fn bindgen_test_layout_duckdb_string_t__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string_t__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string_t__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string_t__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inlined) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(inlined)
        )
    );
}
#[test]
fn bindgen_test_layout_duckdb_string_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string_t__bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_string_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1),
            "::",
            stringify!(pointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inlined) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1),
            "::",
            stringify!(inlined)
        )
    );
}
#[test]
fn bindgen_test_layout_duckdb_string_t() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string_t>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string_t))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string_t>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_string_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t),
            "::",
            stringify!(value)
        )
    );
}
#[doc = "! The internal representation of a list metadata entry contains the list's offset in\n! the child vector, and its length. The parent vector holds these metadata entries,\n! whereas the child vector holds the data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_list_entry {
    pub offset: u64,
    pub length: u64,
}
#[test]
fn bindgen_test_layout_duckdb_list_entry() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_list_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_list_entry>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_list_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_list_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_list_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_list_entry),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_list_entry),
            "::",
            stringify!(length)
        )
    );
}
#[doc = "! A column consists of a pointer to its internal data. Don't operate on this type directly.\n! Instead, use functions such as duckdb_column_data, duckdb_nullmask_data,\n! duckdb_column_type, and duckdb_column_name, which take the result and the column index\n! as their parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_column {
    pub deprecated_data: *mut ::std::os::raw::c_void,
    pub deprecated_nullmask: *mut bool,
    pub deprecated_type: duckdb_type,
    pub deprecated_name: *mut ::std::os::raw::c_char,
    pub internal_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_duckdb_column() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_column> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_column>(),
        40usize,
        concat!("Size of: ", stringify!(duckdb_column))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_column>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_column))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(deprecated_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated_nullmask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(deprecated_nullmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(deprecated_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(deprecated_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(internal_data)
        )
    );
}
#[doc = "! A vector to a specified column in a data chunk. Lives as long as the\n! data chunk lives, i.e., must not be destroyed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_vector {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_vector() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_vector> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_vector>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_vector>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_vector))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_vector),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! A vector to a specified column in a data chunk. Lives as long as the\n! data chunk lives, i.e., must not be destroyed."]
pub type duckdb_vector = *mut _duckdb_vector;
#[doc = "! Strings are composed of a char pointer and a size. You must free string.data\n! with `duckdb_free`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_string {
    pub data: *mut ::std::os::raw::c_char,
    pub size: idx_t,
}
#[test]
fn bindgen_test_layout_duckdb_string() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_string))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_string), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(duckdb_string), "::", stringify!(size))
    );
}
#[doc = "! BLOBs are composed of a byte pointer and a size. You must free blob.data\n! with `duckdb_free`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_blob {
    pub data: *mut ::std::os::raw::c_void,
    pub size: idx_t,
}
#[test]
fn bindgen_test_layout_duckdb_blob() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_blob> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_blob>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_blob))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_blob>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_blob))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_blob), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(duckdb_blob), "::", stringify!(size))
    );
}
#[doc = "! A query result consists of a pointer to its internal data.\n! Must be freed with 'duckdb_destroy_result'."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_result {
    pub deprecated_column_count: idx_t,
    pub deprecated_row_count: idx_t,
    pub deprecated_rows_changed: idx_t,
    pub deprecated_columns: *mut duckdb_column,
    pub deprecated_error_message: *mut ::std::os::raw::c_char,
    pub internal_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_duckdb_result() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_result> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_result>(),
        48usize,
        concat!("Size of: ", stringify!(duckdb_result))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_result>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_result))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated_column_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(deprecated_column_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated_row_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(deprecated_row_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated_rows_changed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(deprecated_rows_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated_columns) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(deprecated_columns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated_error_message) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(deprecated_error_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(internal_data)
        )
    );
}
#[doc = "! A database object. Should be closed with `duckdb_close`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_database {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_database() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_database> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_database>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_database))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_database>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_database))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_database),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! A database object. Should be closed with `duckdb_close`."]
pub type duckdb_database = *mut _duckdb_database;
#[doc = "! A connection to a duckdb database. Must be closed with `duckdb_disconnect`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_connection {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_connection() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_connection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_connection>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_connection))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_connection>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_connection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_connection),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! A connection to a duckdb database. Must be closed with `duckdb_disconnect`."]
pub type duckdb_connection = *mut _duckdb_connection;
#[doc = "! A prepared statement is a parameterized query that allows you to bind parameters to it.\n! Must be destroyed with `duckdb_destroy_prepare`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_prepared_statement {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_prepared_statement() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_prepared_statement> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_prepared_statement>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_prepared_statement))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_prepared_statement>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_prepared_statement))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_prepared_statement),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! A prepared statement is a parameterized query that allows you to bind parameters to it.\n! Must be destroyed with `duckdb_destroy_prepare`."]
pub type duckdb_prepared_statement = *mut _duckdb_prepared_statement;
#[doc = "! Extracted statements. Must be destroyed with `duckdb_destroy_extracted`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_extracted_statements {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_extracted_statements() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_extracted_statements> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_extracted_statements>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_extracted_statements))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_extracted_statements>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_extracted_statements))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_extracted_statements),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Extracted statements. Must be destroyed with `duckdb_destroy_extracted`."]
pub type duckdb_extracted_statements = *mut _duckdb_extracted_statements;
#[doc = "! The pending result represents an intermediate structure for a query that is not yet fully executed.\n! Must be destroyed with `duckdb_destroy_pending`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_pending_result {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_pending_result() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_pending_result> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_pending_result>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_pending_result))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_pending_result>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_pending_result))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_pending_result),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! The pending result represents an intermediate structure for a query that is not yet fully executed.\n! Must be destroyed with `duckdb_destroy_pending`."]
pub type duckdb_pending_result = *mut _duckdb_pending_result;
#[doc = "! The appender enables fast data loading into DuckDB.\n! Must be destroyed with `duckdb_appender_destroy`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_appender {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_appender() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_appender> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_appender>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_appender))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_appender>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_appender))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_appender),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! The appender enables fast data loading into DuckDB.\n! Must be destroyed with `duckdb_appender_destroy`."]
pub type duckdb_appender = *mut _duckdb_appender;
#[doc = "! The table description allows querying info about the table.\n! Must be destroyed with `duckdb_table_description_destroy`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_table_description {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_table_description() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_table_description> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_table_description>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_table_description))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_table_description>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_table_description))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_table_description),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! The table description allows querying info about the table.\n! Must be destroyed with `duckdb_table_description_destroy`."]
pub type duckdb_table_description = *mut _duckdb_table_description;
#[doc = "! Can be used to provide start-up options for the DuckDB instance.\n! Must be destroyed with `duckdb_destroy_config`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_config {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_config() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_config> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_config>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_config))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_config>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_config),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Can be used to provide start-up options for the DuckDB instance.\n! Must be destroyed with `duckdb_destroy_config`."]
pub type duckdb_config = *mut _duckdb_config;
#[doc = "! Holds an internal logical type.\n! Must be destroyed with `duckdb_destroy_logical_type`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_logical_type {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_logical_type() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_logical_type> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_logical_type>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_logical_type))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_logical_type>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_logical_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_logical_type),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Holds an internal logical type.\n! Must be destroyed with `duckdb_destroy_logical_type`."]
pub type duckdb_logical_type = *mut _duckdb_logical_type;
#[doc = "! Contains a data chunk from a duckdb_result.\n! Must be destroyed with `duckdb_destroy_data_chunk`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_data_chunk {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_data_chunk() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_data_chunk> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_data_chunk>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_data_chunk))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_data_chunk>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_data_chunk))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_data_chunk),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Contains a data chunk from a duckdb_result.\n! Must be destroyed with `duckdb_destroy_data_chunk`."]
pub type duckdb_data_chunk = *mut _duckdb_data_chunk;
#[doc = "! Holds a DuckDB value, which wraps a type.\n! Must be destroyed with `duckdb_destroy_value`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_value {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_value() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_value>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_value))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_value>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_value),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Holds a DuckDB value, which wraps a type.\n! Must be destroyed with `duckdb_destroy_value`."]
pub type duckdb_value = *mut _duckdb_value;
#[doc = "! Holds a recursive tree that matches the query plan."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_profiling_info {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_profiling_info() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_profiling_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_profiling_info>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_profiling_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_profiling_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_profiling_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_profiling_info),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Holds a recursive tree that matches the query plan."]
pub type duckdb_profiling_info = *mut _duckdb_profiling_info;
#[doc = "! Holds state during the C API extension intialization process"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_extension_info {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_extension_info() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_extension_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_extension_info>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_extension_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_extension_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_extension_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_extension_info),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Holds state during the C API extension intialization process"]
pub type duckdb_extension_info = *mut _duckdb_extension_info;
#[doc = "! Additional function info. When setting this info, it is necessary to pass a destroy-callback function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_function_info {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_function_info() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_function_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_function_info>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_function_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_function_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_function_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_function_info),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Additional function info. When setting this info, it is necessary to pass a destroy-callback function."]
pub type duckdb_function_info = *mut _duckdb_function_info;
#[doc = "! A scalar function. Must be destroyed with `duckdb_destroy_scalar_function`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_scalar_function {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_scalar_function() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_scalar_function> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_scalar_function>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_scalar_function))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_scalar_function>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_scalar_function))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_scalar_function),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! A scalar function. Must be destroyed with `duckdb_destroy_scalar_function`."]
pub type duckdb_scalar_function = *mut _duckdb_scalar_function;
#[doc = "! A scalar function set. Must be destroyed with `duckdb_destroy_scalar_function_set`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_scalar_function_set {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_scalar_function_set() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_scalar_function_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_scalar_function_set>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_scalar_function_set))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_scalar_function_set>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_scalar_function_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_scalar_function_set),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! A scalar function set. Must be destroyed with `duckdb_destroy_scalar_function_set`."]
pub type duckdb_scalar_function_set = *mut _duckdb_scalar_function_set;
#[doc = "! The main function of the scalar function."]
pub type duckdb_scalar_function_t = ::std::option::Option<
    unsafe extern "C" fn(info: duckdb_function_info, input: duckdb_data_chunk, output: duckdb_vector),
>;
#[doc = "! An aggregate function. Must be destroyed with `duckdb_destroy_aggregate_function`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_aggregate_function {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_aggregate_function() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_aggregate_function> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_aggregate_function>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_aggregate_function))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_aggregate_function>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_aggregate_function))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_aggregate_function),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! An aggregate function. Must be destroyed with `duckdb_destroy_aggregate_function`."]
pub type duckdb_aggregate_function = *mut _duckdb_aggregate_function;
#[doc = "! A aggregate function set. Must be destroyed with `duckdb_destroy_aggregate_function_set`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_aggregate_function_set {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_aggregate_function_set() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_aggregate_function_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_aggregate_function_set>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_aggregate_function_set))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_aggregate_function_set>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_aggregate_function_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_aggregate_function_set),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! A aggregate function set. Must be destroyed with `duckdb_destroy_aggregate_function_set`."]
pub type duckdb_aggregate_function_set = *mut _duckdb_aggregate_function_set;
#[doc = "! Aggregate state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_aggregate_state {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_aggregate_state() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_aggregate_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_aggregate_state>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_aggregate_state))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_aggregate_state>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_aggregate_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_aggregate_state),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Aggregate state"]
pub type duckdb_aggregate_state = *mut _duckdb_aggregate_state;
#[doc = "! Returns the aggregate state size"]
pub type duckdb_aggregate_state_size = ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info) -> idx_t>;
#[doc = "! Initialize the aggregate state"]
pub type duckdb_aggregate_init_t =
    ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info, state: duckdb_aggregate_state)>;
#[doc = "! Destroy aggregate state (optional)"]
pub type duckdb_aggregate_destroy_t =
    ::std::option::Option<unsafe extern "C" fn(states: *mut duckdb_aggregate_state, count: idx_t)>;
#[doc = "! Update a set of aggregate states with new values"]
pub type duckdb_aggregate_update_t = ::std::option::Option<
    unsafe extern "C" fn(info: duckdb_function_info, input: duckdb_data_chunk, states: *mut duckdb_aggregate_state),
>;
#[doc = "! Combine aggregate states"]
pub type duckdb_aggregate_combine_t = ::std::option::Option<
    unsafe extern "C" fn(
        info: duckdb_function_info,
        source: *mut duckdb_aggregate_state,
        target: *mut duckdb_aggregate_state,
        count: idx_t,
    ),
>;
#[doc = "! Finalize aggregate states into a result vector"]
pub type duckdb_aggregate_finalize_t = ::std::option::Option<
    unsafe extern "C" fn(
        info: duckdb_function_info,
        source: *mut duckdb_aggregate_state,
        result: duckdb_vector,
        count: idx_t,
        offset: idx_t,
    ),
>;
#[doc = "! A table function. Must be destroyed with `duckdb_destroy_table_function`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_table_function {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_table_function() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_table_function> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_table_function>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_table_function))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_table_function>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_table_function))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_table_function),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! A table function. Must be destroyed with `duckdb_destroy_table_function`."]
pub type duckdb_table_function = *mut _duckdb_table_function;
#[doc = "! The bind info of the function. When setting this info, it is necessary to pass a destroy-callback function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_bind_info {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_bind_info() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_bind_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_bind_info>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_bind_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_bind_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_bind_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_bind_info),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! The bind info of the function. When setting this info, it is necessary to pass a destroy-callback function."]
pub type duckdb_bind_info = *mut _duckdb_bind_info;
#[doc = "! Additional function init info. When setting this info, it is necessary to pass a destroy-callback function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_init_info {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_init_info() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_init_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_init_info>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_init_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_init_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_init_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_init_info),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Additional function init info. When setting this info, it is necessary to pass a destroy-callback function."]
pub type duckdb_init_info = *mut _duckdb_init_info;
#[doc = "! The bind function of the table function."]
pub type duckdb_table_function_bind_t = ::std::option::Option<unsafe extern "C" fn(info: duckdb_bind_info)>;
#[doc = "! The (possibly thread-local) init function of the table function."]
pub type duckdb_table_function_init_t = ::std::option::Option<unsafe extern "C" fn(info: duckdb_init_info)>;
#[doc = "! The main function of the table function."]
pub type duckdb_table_function_t =
    ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info, output: duckdb_data_chunk)>;
#[doc = "! Additional replacement scan info. When setting this info, it is necessary to pass a destroy-callback function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_replacement_scan_info {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_replacement_scan_info() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_replacement_scan_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_replacement_scan_info>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_replacement_scan_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_replacement_scan_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_replacement_scan_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_replacement_scan_info),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Additional replacement scan info. When setting this info, it is necessary to pass a destroy-callback function."]
pub type duckdb_replacement_scan_info = *mut _duckdb_replacement_scan_info;
#[doc = "! A replacement scan function that can be added to a database."]
pub type duckdb_replacement_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        info: duckdb_replacement_scan_info,
        table_name: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = "! Holds an arrow query result. Must be destroyed with `duckdb_destroy_arrow`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_arrow {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_arrow() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_arrow> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_arrow>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_arrow))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_arrow>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_arrow))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_arrow),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Holds an arrow query result. Must be destroyed with `duckdb_destroy_arrow`."]
pub type duckdb_arrow = *mut _duckdb_arrow;
#[doc = "! Holds an arrow array stream. Must be destroyed with `duckdb_destroy_arrow_stream`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_arrow_stream {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_arrow_stream() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_arrow_stream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_arrow_stream>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_arrow_stream))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_arrow_stream>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_arrow_stream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_arrow_stream),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Holds an arrow array stream. Must be destroyed with `duckdb_destroy_arrow_stream`."]
pub type duckdb_arrow_stream = *mut _duckdb_arrow_stream;
#[doc = "! Holds an arrow schema. Remember to release the respective ArrowSchema object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_arrow_schema {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_arrow_schema() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_arrow_schema> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_arrow_schema>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_arrow_schema))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_arrow_schema>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_arrow_schema))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_arrow_schema),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Holds an arrow schema. Remember to release the respective ArrowSchema object."]
pub type duckdb_arrow_schema = *mut _duckdb_arrow_schema;
#[doc = "! Holds an arrow array. Remember to release the respective ArrowArray object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_arrow_array {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_arrow_array() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_arrow_array> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_arrow_array>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_arrow_array))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_arrow_array>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_arrow_array))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_arrow_array),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Holds an arrow array. Remember to release the respective ArrowArray object."]
pub type duckdb_arrow_array = *mut _duckdb_arrow_array;
#[doc = "! Passed to C API extension as parameter to the entrypoint"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_extension_access {
    #[doc = "! Indicate that an error has occured"]
    pub set_error:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_extension_info, error: *const ::std::os::raw::c_char)>,
    #[doc = "! Fetch the database from duckdb to register extensions to"]
    pub get_database: ::std::option::Option<unsafe extern "C" fn(info: duckdb_extension_info) -> *mut duckdb_database>,
    #[doc = "! Fetch the API"]
    pub get_api: ::std::option::Option<
        unsafe extern "C" fn(
            info: duckdb_extension_info,
            version: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_void,
    >,
}
#[test]
fn bindgen_test_layout_duckdb_extension_access() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_extension_access> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_extension_access>(),
        24usize,
        concat!("Size of: ", stringify!(duckdb_extension_access))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_extension_access>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_extension_access))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_extension_access),
            "::",
            stringify!(set_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_database) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_extension_access),
            "::",
            stringify!(get_database)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_api) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_extension_access),
            "::",
            stringify!(get_api)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_ext_api_v0 {
    pub duckdb_open: ::std::option::Option<
        unsafe extern "C" fn(path: *const ::std::os::raw::c_char, out_database: *mut duckdb_database) -> duckdb_state,
    >,
    pub duckdb_open_ext: ::std::option::Option<
        unsafe extern "C" fn(
            path: *const ::std::os::raw::c_char,
            out_database: *mut duckdb_database,
            config: duckdb_config,
            out_error: *mut *mut ::std::os::raw::c_char,
        ) -> duckdb_state,
    >,
    pub duckdb_close: ::std::option::Option<unsafe extern "C" fn(database: *mut duckdb_database)>,
    pub duckdb_connect: ::std::option::Option<
        unsafe extern "C" fn(database: duckdb_database, out_connection: *mut duckdb_connection) -> duckdb_state,
    >,
    pub duckdb_interrupt: ::std::option::Option<unsafe extern "C" fn(connection: duckdb_connection)>,
    pub duckdb_query_progress:
        ::std::option::Option<unsafe extern "C" fn(connection: duckdb_connection) -> duckdb_query_progress_type>,
    pub duckdb_disconnect: ::std::option::Option<unsafe extern "C" fn(connection: *mut duckdb_connection)>,
    pub duckdb_library_version: ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>,
    pub duckdb_create_config:
        ::std::option::Option<unsafe extern "C" fn(out_config: *mut duckdb_config) -> duckdb_state>,
    pub duckdb_config_count: ::std::option::Option<unsafe extern "C" fn() -> usize>,
    pub duckdb_get_config_flag: ::std::option::Option<
        unsafe extern "C" fn(
            index: usize,
            out_name: *mut *const ::std::os::raw::c_char,
            out_description: *mut *const ::std::os::raw::c_char,
        ) -> duckdb_state,
    >,
    pub duckdb_set_config: ::std::option::Option<
        unsafe extern "C" fn(
            config: duckdb_config,
            name: *const ::std::os::raw::c_char,
            option: *const ::std::os::raw::c_char,
        ) -> duckdb_state,
    >,
    pub duckdb_destroy_config: ::std::option::Option<unsafe extern "C" fn(config: *mut duckdb_config)>,
    pub duckdb_query: ::std::option::Option<
        unsafe extern "C" fn(
            connection: duckdb_connection,
            query: *const ::std::os::raw::c_char,
            out_result: *mut duckdb_result,
        ) -> duckdb_state,
    >,
    pub duckdb_destroy_result: ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result)>,
    pub duckdb_column_name: ::std::option::Option<
        unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t) -> *const ::std::os::raw::c_char,
    >,
    pub duckdb_column_type:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t) -> duckdb_type>,
    pub duckdb_result_statement_type:
        ::std::option::Option<unsafe extern "C" fn(result: duckdb_result) -> duckdb_statement_type>,
    pub duckdb_column_logical_type:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t) -> duckdb_logical_type>,
    pub duckdb_column_count: ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result) -> idx_t>,
    pub duckdb_rows_changed: ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result) -> idx_t>,
    pub duckdb_result_error:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result) -> *const ::std::os::raw::c_char>,
    pub duckdb_malloc: ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void>,
    pub duckdb_free: ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>,
    pub duckdb_vector_size: ::std::option::Option<unsafe extern "C" fn() -> idx_t>,
    pub duckdb_string_is_inlined: ::std::option::Option<unsafe extern "C" fn(string: duckdb_string_t) -> bool>,
    pub duckdb_from_date: ::std::option::Option<unsafe extern "C" fn(date: duckdb_date) -> duckdb_date_struct>,
    pub duckdb_to_date: ::std::option::Option<unsafe extern "C" fn(date: duckdb_date_struct) -> duckdb_date>,
    pub duckdb_is_finite_date: ::std::option::Option<unsafe extern "C" fn(date: duckdb_date) -> bool>,
    pub duckdb_from_time: ::std::option::Option<unsafe extern "C" fn(time: duckdb_time) -> duckdb_time_struct>,
    pub duckdb_create_time_tz: ::std::option::Option<unsafe extern "C" fn(micros: i64, offset: i32) -> duckdb_time_tz>,
    pub duckdb_from_time_tz:
        ::std::option::Option<unsafe extern "C" fn(micros: duckdb_time_tz) -> duckdb_time_tz_struct>,
    pub duckdb_to_time: ::std::option::Option<unsafe extern "C" fn(time: duckdb_time_struct) -> duckdb_time>,
    pub duckdb_from_timestamp:
        ::std::option::Option<unsafe extern "C" fn(ts: duckdb_timestamp) -> duckdb_timestamp_struct>,
    pub duckdb_to_timestamp:
        ::std::option::Option<unsafe extern "C" fn(ts: duckdb_timestamp_struct) -> duckdb_timestamp>,
    pub duckdb_is_finite_timestamp: ::std::option::Option<unsafe extern "C" fn(ts: duckdb_timestamp) -> bool>,
    pub duckdb_hugeint_to_double: ::std::option::Option<unsafe extern "C" fn(val: duckdb_hugeint) -> f64>,
    pub duckdb_double_to_hugeint: ::std::option::Option<unsafe extern "C" fn(val: f64) -> duckdb_hugeint>,
    pub duckdb_uhugeint_to_double: ::std::option::Option<unsafe extern "C" fn(val: duckdb_uhugeint) -> f64>,
    pub duckdb_double_to_uhugeint: ::std::option::Option<unsafe extern "C" fn(val: f64) -> duckdb_uhugeint>,
    pub duckdb_double_to_decimal:
        ::std::option::Option<unsafe extern "C" fn(val: f64, width: u8, scale: u8) -> duckdb_decimal>,
    pub duckdb_decimal_to_double: ::std::option::Option<unsafe extern "C" fn(val: duckdb_decimal) -> f64>,
    pub duckdb_prepare: ::std::option::Option<
        unsafe extern "C" fn(
            connection: duckdb_connection,
            query: *const ::std::os::raw::c_char,
            out_prepared_statement: *mut duckdb_prepared_statement,
        ) -> duckdb_state,
    >,
    pub duckdb_destroy_prepare:
        ::std::option::Option<unsafe extern "C" fn(prepared_statement: *mut duckdb_prepared_statement)>,
    pub duckdb_prepare_error: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement) -> *const ::std::os::raw::c_char,
    >,
    pub duckdb_nparams:
        ::std::option::Option<unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement) -> idx_t>,
    pub duckdb_parameter_name: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            index: idx_t,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub duckdb_param_type: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t) -> duckdb_type,
    >,
    pub duckdb_clear_bindings:
        ::std::option::Option<unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement) -> duckdb_state>,
    pub duckdb_prepared_statement_type:
        ::std::option::Option<unsafe extern "C" fn(statement: duckdb_prepared_statement) -> duckdb_statement_type>,
    pub duckdb_bind_value: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: duckdb_value,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_parameter_index: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx_out: *mut idx_t,
            name: *const ::std::os::raw::c_char,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_boolean: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: bool,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_int8: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: i8) -> duckdb_state,
    >,
    pub duckdb_bind_int16: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: i16) -> duckdb_state,
    >,
    pub duckdb_bind_int32: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: i32) -> duckdb_state,
    >,
    pub duckdb_bind_int64: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: i64) -> duckdb_state,
    >,
    pub duckdb_bind_hugeint: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: duckdb_hugeint,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_uhugeint: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: duckdb_uhugeint,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_decimal: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: duckdb_decimal,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_uint8: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: u8) -> duckdb_state,
    >,
    pub duckdb_bind_uint16: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: u16) -> duckdb_state,
    >,
    pub duckdb_bind_uint32: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: u32) -> duckdb_state,
    >,
    pub duckdb_bind_uint64: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: u64) -> duckdb_state,
    >,
    pub duckdb_bind_float: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: f32) -> duckdb_state,
    >,
    pub duckdb_bind_double: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: f64) -> duckdb_state,
    >,
    pub duckdb_bind_date: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: duckdb_date,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_time: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: duckdb_time,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_timestamp: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: duckdb_timestamp,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_timestamp_tz: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: duckdb_timestamp,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_interval: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: duckdb_interval,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_varchar: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: *const ::std::os::raw::c_char,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_varchar_length: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: *const ::std::os::raw::c_char,
            length: idx_t,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_blob: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            data: *const ::std::os::raw::c_void,
            length: idx_t,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_null: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t) -> duckdb_state,
    >,
    pub duckdb_execute_prepared: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            out_result: *mut duckdb_result,
        ) -> duckdb_state,
    >,
    pub duckdb_extract_statements: ::std::option::Option<
        unsafe extern "C" fn(
            connection: duckdb_connection,
            query: *const ::std::os::raw::c_char,
            out_extracted_statements: *mut duckdb_extracted_statements,
        ) -> idx_t,
    >,
    pub duckdb_prepare_extracted_statement: ::std::option::Option<
        unsafe extern "C" fn(
            connection: duckdb_connection,
            extracted_statements: duckdb_extracted_statements,
            index: idx_t,
            out_prepared_statement: *mut duckdb_prepared_statement,
        ) -> duckdb_state,
    >,
    pub duckdb_extract_statements_error: ::std::option::Option<
        unsafe extern "C" fn(extracted_statements: duckdb_extracted_statements) -> *const ::std::os::raw::c_char,
    >,
    pub duckdb_destroy_extracted:
        ::std::option::Option<unsafe extern "C" fn(extracted_statements: *mut duckdb_extracted_statements)>,
    pub duckdb_pending_prepared: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            out_result: *mut duckdb_pending_result,
        ) -> duckdb_state,
    >,
    pub duckdb_destroy_pending: ::std::option::Option<unsafe extern "C" fn(pending_result: *mut duckdb_pending_result)>,
    pub duckdb_pending_error: ::std::option::Option<
        unsafe extern "C" fn(pending_result: duckdb_pending_result) -> *const ::std::os::raw::c_char,
    >,
    pub duckdb_pending_execute_task:
        ::std::option::Option<unsafe extern "C" fn(pending_result: duckdb_pending_result) -> duckdb_pending_state>,
    pub duckdb_pending_execute_check_state:
        ::std::option::Option<unsafe extern "C" fn(pending_result: duckdb_pending_result) -> duckdb_pending_state>,
    pub duckdb_execute_pending: ::std::option::Option<
        unsafe extern "C" fn(pending_result: duckdb_pending_result, out_result: *mut duckdb_result) -> duckdb_state,
    >,
    pub duckdb_pending_execution_is_finished:
        ::std::option::Option<unsafe extern "C" fn(pending_state: duckdb_pending_state) -> bool>,
    pub duckdb_destroy_value: ::std::option::Option<unsafe extern "C" fn(value: *mut duckdb_value)>,
    pub duckdb_create_varchar:
        ::std::option::Option<unsafe extern "C" fn(text: *const ::std::os::raw::c_char) -> duckdb_value>,
    pub duckdb_create_varchar_length:
        ::std::option::Option<unsafe extern "C" fn(text: *const ::std::os::raw::c_char, length: idx_t) -> duckdb_value>,
    pub duckdb_create_int64: ::std::option::Option<unsafe extern "C" fn(val: i64) -> duckdb_value>,
    pub duckdb_create_struct_value: ::std::option::Option<
        unsafe extern "C" fn(type_: duckdb_logical_type, values: *mut duckdb_value) -> duckdb_value,
    >,
    pub duckdb_create_list_value: ::std::option::Option<
        unsafe extern "C" fn(type_: duckdb_logical_type, values: *mut duckdb_value, value_count: idx_t) -> duckdb_value,
    >,
    pub duckdb_create_array_value: ::std::option::Option<
        unsafe extern "C" fn(type_: duckdb_logical_type, values: *mut duckdb_value, value_count: idx_t) -> duckdb_value,
    >,
    pub duckdb_get_varchar:
        ::std::option::Option<unsafe extern "C" fn(value: duckdb_value) -> *mut ::std::os::raw::c_char>,
    pub duckdb_get_int64: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> i64>,
    pub duckdb_create_logical_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_type) -> duckdb_logical_type>,
    pub duckdb_logical_type_get_alias:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> *mut ::std::os::raw::c_char>,
    pub duckdb_create_list_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type>,
    pub duckdb_create_array_type: ::std::option::Option<
        unsafe extern "C" fn(type_: duckdb_logical_type, array_size: idx_t) -> duckdb_logical_type,
    >,
    pub duckdb_create_map_type: ::std::option::Option<
        unsafe extern "C" fn(key_type: duckdb_logical_type, value_type: duckdb_logical_type) -> duckdb_logical_type,
    >,
    pub duckdb_create_union_type: ::std::option::Option<
        unsafe extern "C" fn(
            member_types: *mut duckdb_logical_type,
            member_names: *mut *const ::std::os::raw::c_char,
            member_count: idx_t,
        ) -> duckdb_logical_type,
    >,
    pub duckdb_create_struct_type: ::std::option::Option<
        unsafe extern "C" fn(
            member_types: *mut duckdb_logical_type,
            member_names: *mut *const ::std::os::raw::c_char,
            member_count: idx_t,
        ) -> duckdb_logical_type,
    >,
    pub duckdb_create_enum_type: ::std::option::Option<
        unsafe extern "C" fn(
            member_names: *mut *const ::std::os::raw::c_char,
            member_count: idx_t,
        ) -> duckdb_logical_type,
    >,
    pub duckdb_create_decimal_type:
        ::std::option::Option<unsafe extern "C" fn(width: u8, scale: u8) -> duckdb_logical_type>,
    pub duckdb_get_type_id: ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_type>,
    pub duckdb_decimal_width: ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> u8>,
    pub duckdb_decimal_scale: ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> u8>,
    pub duckdb_decimal_internal_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_type>,
    pub duckdb_enum_internal_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_type>,
    pub duckdb_enum_dictionary_size: ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> u32>,
    pub duckdb_enum_dictionary_value: ::std::option::Option<
        unsafe extern "C" fn(type_: duckdb_logical_type, index: idx_t) -> *mut ::std::os::raw::c_char,
    >,
    pub duckdb_list_type_child_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type>,
    pub duckdb_array_type_child_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type>,
    pub duckdb_array_type_array_size: ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> idx_t>,
    pub duckdb_map_type_key_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type>,
    pub duckdb_map_type_value_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type>,
    pub duckdb_struct_type_child_count:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> idx_t>,
    pub duckdb_struct_type_child_name: ::std::option::Option<
        unsafe extern "C" fn(type_: duckdb_logical_type, index: idx_t) -> *mut ::std::os::raw::c_char,
    >,
    pub duckdb_struct_type_child_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type, index: idx_t) -> duckdb_logical_type>,
    pub duckdb_union_type_member_count:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> idx_t>,
    pub duckdb_union_type_member_name: ::std::option::Option<
        unsafe extern "C" fn(type_: duckdb_logical_type, index: idx_t) -> *mut ::std::os::raw::c_char,
    >,
    pub duckdb_union_type_member_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type, index: idx_t) -> duckdb_logical_type>,
    pub duckdb_destroy_logical_type: ::std::option::Option<unsafe extern "C" fn(type_: *mut duckdb_logical_type)>,
    pub duckdb_fetch_chunk: ::std::option::Option<unsafe extern "C" fn(result: duckdb_result) -> duckdb_data_chunk>,
    pub duckdb_create_data_chunk: ::std::option::Option<
        unsafe extern "C" fn(types: *mut duckdb_logical_type, column_count: idx_t) -> duckdb_data_chunk,
    >,
    pub duckdb_destroy_data_chunk: ::std::option::Option<unsafe extern "C" fn(chunk: *mut duckdb_data_chunk)>,
    pub duckdb_data_chunk_reset: ::std::option::Option<unsafe extern "C" fn(chunk: duckdb_data_chunk)>,
    pub duckdb_data_chunk_get_column_count:
        ::std::option::Option<unsafe extern "C" fn(chunk: duckdb_data_chunk) -> idx_t>,
    pub duckdb_data_chunk_get_vector:
        ::std::option::Option<unsafe extern "C" fn(chunk: duckdb_data_chunk, col_idx: idx_t) -> duckdb_vector>,
    pub duckdb_data_chunk_get_size: ::std::option::Option<unsafe extern "C" fn(chunk: duckdb_data_chunk) -> idx_t>,
    pub duckdb_data_chunk_set_size: ::std::option::Option<unsafe extern "C" fn(chunk: duckdb_data_chunk, size: idx_t)>,
    pub duckdb_vector_get_column_type:
        ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector) -> duckdb_logical_type>,
    pub duckdb_vector_get_data:
        ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector) -> *mut ::std::os::raw::c_void>,
    pub duckdb_vector_get_validity: ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector) -> *mut u64>,
    pub duckdb_vector_ensure_validity_writable: ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector)>,
    pub duckdb_vector_assign_string_element: ::std::option::Option<
        unsafe extern "C" fn(vector: duckdb_vector, index: idx_t, str_: *const ::std::os::raw::c_char),
    >,
    pub duckdb_vector_assign_string_element_len: ::std::option::Option<
        unsafe extern "C" fn(vector: duckdb_vector, index: idx_t, str_: *const ::std::os::raw::c_char, str_len: idx_t),
    >,
    pub duckdb_list_vector_get_child:
        ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector) -> duckdb_vector>,
    pub duckdb_list_vector_get_size: ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector) -> idx_t>,
    pub duckdb_list_vector_set_size:
        ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector, size: idx_t) -> duckdb_state>,
    pub duckdb_list_vector_reserve:
        ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector, required_capacity: idx_t) -> duckdb_state>,
    pub duckdb_struct_vector_get_child:
        ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector, index: idx_t) -> duckdb_vector>,
    pub duckdb_array_vector_get_child:
        ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector) -> duckdb_vector>,
    pub duckdb_validity_row_is_valid:
        ::std::option::Option<unsafe extern "C" fn(validity: *mut u64, row: idx_t) -> bool>,
    pub duckdb_validity_set_row_validity:
        ::std::option::Option<unsafe extern "C" fn(validity: *mut u64, row: idx_t, valid: bool)>,
    pub duckdb_validity_set_row_invalid: ::std::option::Option<unsafe extern "C" fn(validity: *mut u64, row: idx_t)>,
    pub duckdb_validity_set_row_valid: ::std::option::Option<unsafe extern "C" fn(validity: *mut u64, row: idx_t)>,
    pub duckdb_create_scalar_function: ::std::option::Option<unsafe extern "C" fn() -> duckdb_scalar_function>,
    pub duckdb_destroy_scalar_function:
        ::std::option::Option<unsafe extern "C" fn(scalar_function: *mut duckdb_scalar_function)>,
    pub duckdb_scalar_function_set_name: ::std::option::Option<
        unsafe extern "C" fn(scalar_function: duckdb_scalar_function, name: *const ::std::os::raw::c_char),
    >,
    pub duckdb_scalar_function_add_parameter: ::std::option::Option<
        unsafe extern "C" fn(scalar_function: duckdb_scalar_function, type_: duckdb_logical_type),
    >,
    pub duckdb_scalar_function_set_return_type: ::std::option::Option<
        unsafe extern "C" fn(scalar_function: duckdb_scalar_function, type_: duckdb_logical_type),
    >,
    pub duckdb_scalar_function_set_extra_info: ::std::option::Option<
        unsafe extern "C" fn(
            scalar_function: duckdb_scalar_function,
            extra_info: *mut ::std::os::raw::c_void,
            destroy: duckdb_delete_callback_t,
        ),
    >,
    pub duckdb_scalar_function_set_function: ::std::option::Option<
        unsafe extern "C" fn(scalar_function: duckdb_scalar_function, function: duckdb_scalar_function_t),
    >,
    pub duckdb_register_scalar_function: ::std::option::Option<
        unsafe extern "C" fn(con: duckdb_connection, scalar_function: duckdb_scalar_function) -> duckdb_state,
    >,
    pub duckdb_create_table_function: ::std::option::Option<unsafe extern "C" fn() -> duckdb_table_function>,
    pub duckdb_destroy_table_function:
        ::std::option::Option<unsafe extern "C" fn(table_function: *mut duckdb_table_function)>,
    pub duckdb_table_function_set_name: ::std::option::Option<
        unsafe extern "C" fn(table_function: duckdb_table_function, name: *const ::std::os::raw::c_char),
    >,
    pub duckdb_table_function_add_parameter:
        ::std::option::Option<unsafe extern "C" fn(table_function: duckdb_table_function, type_: duckdb_logical_type)>,
    pub duckdb_table_function_add_named_parameter: ::std::option::Option<
        unsafe extern "C" fn(
            table_function: duckdb_table_function,
            name: *const ::std::os::raw::c_char,
            type_: duckdb_logical_type,
        ),
    >,
    pub duckdb_table_function_set_extra_info: ::std::option::Option<
        unsafe extern "C" fn(
            table_function: duckdb_table_function,
            extra_info: *mut ::std::os::raw::c_void,
            destroy: duckdb_delete_callback_t,
        ),
    >,
    pub duckdb_table_function_set_bind: ::std::option::Option<
        unsafe extern "C" fn(table_function: duckdb_table_function, bind: duckdb_table_function_bind_t),
    >,
    pub duckdb_table_function_set_init: ::std::option::Option<
        unsafe extern "C" fn(table_function: duckdb_table_function, init: duckdb_table_function_init_t),
    >,
    pub duckdb_table_function_set_local_init: ::std::option::Option<
        unsafe extern "C" fn(table_function: duckdb_table_function, init: duckdb_table_function_init_t),
    >,
    pub duckdb_table_function_set_function: ::std::option::Option<
        unsafe extern "C" fn(table_function: duckdb_table_function, function: duckdb_table_function_t),
    >,
    pub duckdb_table_function_supports_projection_pushdown:
        ::std::option::Option<unsafe extern "C" fn(table_function: duckdb_table_function, pushdown: bool)>,
    pub duckdb_register_table_function: ::std::option::Option<
        unsafe extern "C" fn(con: duckdb_connection, function: duckdb_table_function) -> duckdb_state,
    >,
    pub duckdb_bind_get_extra_info:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_bind_info) -> *mut ::std::os::raw::c_void>,
    pub duckdb_bind_add_result_column: ::std::option::Option<
        unsafe extern "C" fn(info: duckdb_bind_info, name: *const ::std::os::raw::c_char, type_: duckdb_logical_type),
    >,
    pub duckdb_bind_get_parameter_count: ::std::option::Option<unsafe extern "C" fn(info: duckdb_bind_info) -> idx_t>,
    pub duckdb_bind_get_parameter:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_bind_info, index: idx_t) -> duckdb_value>,
    pub duckdb_bind_get_named_parameter: ::std::option::Option<
        unsafe extern "C" fn(info: duckdb_bind_info, name: *const ::std::os::raw::c_char) -> duckdb_value,
    >,
    pub duckdb_bind_set_bind_data: ::std::option::Option<
        unsafe extern "C" fn(
            info: duckdb_bind_info,
            bind_data: *mut ::std::os::raw::c_void,
            destroy: duckdb_delete_callback_t,
        ),
    >,
    pub duckdb_bind_set_cardinality:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_bind_info, cardinality: idx_t, is_exact: bool)>,
    pub duckdb_bind_set_error:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_bind_info, error: *const ::std::os::raw::c_char)>,
    pub duckdb_init_get_extra_info:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_init_info) -> *mut ::std::os::raw::c_void>,
    pub duckdb_init_get_bind_data:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_init_info) -> *mut ::std::os::raw::c_void>,
    pub duckdb_init_set_init_data: ::std::option::Option<
        unsafe extern "C" fn(
            info: duckdb_init_info,
            init_data: *mut ::std::os::raw::c_void,
            destroy: duckdb_delete_callback_t,
        ),
    >,
    pub duckdb_init_get_column_count: ::std::option::Option<unsafe extern "C" fn(info: duckdb_init_info) -> idx_t>,
    pub duckdb_init_get_column_index:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_init_info, column_index: idx_t) -> idx_t>,
    pub duckdb_init_set_max_threads:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_init_info, max_threads: idx_t)>,
    pub duckdb_init_set_error:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_init_info, error: *const ::std::os::raw::c_char)>,
    pub duckdb_function_get_extra_info:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info) -> *mut ::std::os::raw::c_void>,
    pub duckdb_function_get_bind_data:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info) -> *mut ::std::os::raw::c_void>,
    pub duckdb_function_get_init_data:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info) -> *mut ::std::os::raw::c_void>,
    pub duckdb_function_get_local_init_data:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info) -> *mut ::std::os::raw::c_void>,
    pub duckdb_function_set_error:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info, error: *const ::std::os::raw::c_char)>,
    pub duckdb_add_replacement_scan: ::std::option::Option<
        unsafe extern "C" fn(
            db: duckdb_database,
            replacement: duckdb_replacement_callback_t,
            extra_data: *mut ::std::os::raw::c_void,
            delete_callback: duckdb_delete_callback_t,
        ),
    >,
    pub duckdb_replacement_scan_set_function_name: ::std::option::Option<
        unsafe extern "C" fn(info: duckdb_replacement_scan_info, function_name: *const ::std::os::raw::c_char),
    >,
    pub duckdb_replacement_scan_add_parameter:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_replacement_scan_info, parameter: duckdb_value)>,
    pub duckdb_replacement_scan_set_error: ::std::option::Option<
        unsafe extern "C" fn(info: duckdb_replacement_scan_info, error: *const ::std::os::raw::c_char),
    >,
    pub duckdb_appender_create: ::std::option::Option<
        unsafe extern "C" fn(
            connection: duckdb_connection,
            schema: *const ::std::os::raw::c_char,
            table: *const ::std::os::raw::c_char,
            out_appender: *mut duckdb_appender,
        ) -> duckdb_state,
    >,
    pub duckdb_appender_column_count: ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender) -> idx_t>,
    pub duckdb_appender_column_type:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, col_idx: idx_t) -> duckdb_logical_type>,
    pub duckdb_appender_error:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender) -> *const ::std::os::raw::c_char>,
    pub duckdb_appender_flush: ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state>,
    pub duckdb_appender_close: ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state>,
    pub duckdb_appender_destroy:
        ::std::option::Option<unsafe extern "C" fn(appender: *mut duckdb_appender) -> duckdb_state>,
    pub duckdb_appender_begin_row:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state>,
    pub duckdb_appender_end_row: ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state>,
    pub duckdb_append_default: ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state>,
    pub duckdb_append_bool:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: bool) -> duckdb_state>,
    pub duckdb_append_int8:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: i8) -> duckdb_state>,
    pub duckdb_append_int16:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: i16) -> duckdb_state>,
    pub duckdb_append_int32:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: i32) -> duckdb_state>,
    pub duckdb_append_int64:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: i64) -> duckdb_state>,
    pub duckdb_append_hugeint:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: duckdb_hugeint) -> duckdb_state>,
    pub duckdb_append_uint8:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: u8) -> duckdb_state>,
    pub duckdb_append_uint16:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: u16) -> duckdb_state>,
    pub duckdb_append_uint32:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: u32) -> duckdb_state>,
    pub duckdb_append_uint64:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: u64) -> duckdb_state>,
    pub duckdb_append_uhugeint:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: duckdb_uhugeint) -> duckdb_state>,
    pub duckdb_append_float:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: f32) -> duckdb_state>,
    pub duckdb_append_double:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: f64) -> duckdb_state>,
    pub duckdb_append_date:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: duckdb_date) -> duckdb_state>,
    pub duckdb_append_time:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: duckdb_time) -> duckdb_state>,
    pub duckdb_append_timestamp:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: duckdb_timestamp) -> duckdb_state>,
    pub duckdb_append_interval:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: duckdb_interval) -> duckdb_state>,
    pub duckdb_append_varchar: ::std::option::Option<
        unsafe extern "C" fn(appender: duckdb_appender, val: *const ::std::os::raw::c_char) -> duckdb_state,
    >,
    pub duckdb_append_varchar_length: ::std::option::Option<
        unsafe extern "C" fn(
            appender: duckdb_appender,
            val: *const ::std::os::raw::c_char,
            length: idx_t,
        ) -> duckdb_state,
    >,
    pub duckdb_append_blob: ::std::option::Option<
        unsafe extern "C" fn(
            appender: duckdb_appender,
            data: *const ::std::os::raw::c_void,
            length: idx_t,
        ) -> duckdb_state,
    >,
    pub duckdb_append_null: ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state>,
    pub duckdb_append_data_chunk: ::std::option::Option<
        unsafe extern "C" fn(appender: duckdb_appender, chunk: duckdb_data_chunk) -> duckdb_state,
    >,
    pub duckdb_execute_tasks: ::std::option::Option<unsafe extern "C" fn(database: duckdb_database, max_tasks: idx_t)>,
    pub duckdb_create_task_state:
        ::std::option::Option<unsafe extern "C" fn(database: duckdb_database) -> duckdb_task_state>,
    pub duckdb_execute_tasks_state: ::std::option::Option<unsafe extern "C" fn(state: duckdb_task_state)>,
    pub duckdb_execute_n_tasks_state:
        ::std::option::Option<unsafe extern "C" fn(state: duckdb_task_state, max_tasks: idx_t) -> idx_t>,
    pub duckdb_finish_execution: ::std::option::Option<unsafe extern "C" fn(state: duckdb_task_state)>,
    pub duckdb_task_state_is_finished: ::std::option::Option<unsafe extern "C" fn(state: duckdb_task_state) -> bool>,
    pub duckdb_destroy_task_state: ::std::option::Option<unsafe extern "C" fn(state: duckdb_task_state)>,
    pub duckdb_execution_is_finished: ::std::option::Option<unsafe extern "C" fn(con: duckdb_connection) -> bool>,
    pub duckdb_get_profiling_info:
        ::std::option::Option<unsafe extern "C" fn(connection: duckdb_connection) -> duckdb_profiling_info>,
    pub duckdb_profiling_info_get_value: ::std::option::Option<
        unsafe extern "C" fn(info: duckdb_profiling_info, key: *const ::std::os::raw::c_char) -> duckdb_value,
    >,
    pub duckdb_profiling_info_get_child_count:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_profiling_info) -> idx_t>,
    pub duckdb_profiling_info_get_child:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_profiling_info, index: idx_t) -> duckdb_profiling_info>,
    pub duckdb_profiling_info_get_name:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_profiling_info) -> *const ::std::os::raw::c_char>,
    pub duckdb_profiling_info_get_query:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_profiling_info) -> *const ::std::os::raw::c_char>,
    pub duckdb_scalar_function_set_varargs: ::std::option::Option<
        unsafe extern "C" fn(scalar_function: duckdb_scalar_function, type_: duckdb_logical_type),
    >,
    pub duckdb_scalar_function_set_special_handling:
        ::std::option::Option<unsafe extern "C" fn(scalar_function: duckdb_scalar_function)>,
    pub duckdb_scalar_function_set_volatile:
        ::std::option::Option<unsafe extern "C" fn(scalar_function: duckdb_scalar_function)>,
    pub duckdb_scalar_function_get_extra_info:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info) -> *mut ::std::os::raw::c_void>,
    pub duckdb_scalar_function_set_error:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info, error: *const ::std::os::raw::c_char)>,
    pub duckdb_table_description_create: ::std::option::Option<
        unsafe extern "C" fn(
            connection: duckdb_connection,
            schema: *const ::std::os::raw::c_char,
            table: *const ::std::os::raw::c_char,
            out: *mut duckdb_table_description,
        ) -> duckdb_state,
    >,
    pub duckdb_table_description_destroy:
        ::std::option::Option<unsafe extern "C" fn(table_description: *mut duckdb_table_description)>,
    pub duckdb_table_description_error: ::std::option::Option<
        unsafe extern "C" fn(table_description: duckdb_table_description) -> *const ::std::os::raw::c_char,
    >,
    pub duckdb_result_error_type:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result) -> duckdb_error_type>,
    pub duckdb_string_t_length: ::std::option::Option<unsafe extern "C" fn(string: duckdb_string_t) -> u32>,
    pub duckdb_string_t_data:
        ::std::option::Option<unsafe extern "C" fn(string: *mut duckdb_string_t) -> *const ::std::os::raw::c_char>,
    pub duckdb_create_bool: ::std::option::Option<unsafe extern "C" fn(input: bool) -> duckdb_value>,
    pub duckdb_create_int8: ::std::option::Option<unsafe extern "C" fn(input: i8) -> duckdb_value>,
    pub duckdb_create_uint8: ::std::option::Option<unsafe extern "C" fn(input: u8) -> duckdb_value>,
    pub duckdb_create_int16: ::std::option::Option<unsafe extern "C" fn(input: i16) -> duckdb_value>,
    pub duckdb_create_uint16: ::std::option::Option<unsafe extern "C" fn(input: u16) -> duckdb_value>,
    pub duckdb_create_int32: ::std::option::Option<unsafe extern "C" fn(input: i32) -> duckdb_value>,
    pub duckdb_create_uint32: ::std::option::Option<unsafe extern "C" fn(input: u32) -> duckdb_value>,
    pub duckdb_create_uint64: ::std::option::Option<unsafe extern "C" fn(input: u64) -> duckdb_value>,
    pub duckdb_create_hugeint: ::std::option::Option<unsafe extern "C" fn(input: duckdb_hugeint) -> duckdb_value>,
    pub duckdb_create_uhugeint: ::std::option::Option<unsafe extern "C" fn(input: duckdb_uhugeint) -> duckdb_value>,
    pub duckdb_create_float: ::std::option::Option<unsafe extern "C" fn(input: f32) -> duckdb_value>,
    pub duckdb_create_double: ::std::option::Option<unsafe extern "C" fn(input: f64) -> duckdb_value>,
    pub duckdb_create_date: ::std::option::Option<unsafe extern "C" fn(input: duckdb_date) -> duckdb_value>,
    pub duckdb_create_time: ::std::option::Option<unsafe extern "C" fn(input: duckdb_time) -> duckdb_value>,
    pub duckdb_create_time_tz_value: ::std::option::Option<unsafe extern "C" fn(value: duckdb_time_tz) -> duckdb_value>,
    pub duckdb_create_timestamp: ::std::option::Option<unsafe extern "C" fn(input: duckdb_timestamp) -> duckdb_value>,
    pub duckdb_create_interval: ::std::option::Option<unsafe extern "C" fn(input: duckdb_interval) -> duckdb_value>,
    pub duckdb_create_blob: ::std::option::Option<unsafe extern "C" fn(data: *const u8, length: idx_t) -> duckdb_value>,
    pub duckdb_get_bool: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> bool>,
    pub duckdb_get_int8: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> i8>,
    pub duckdb_get_uint8: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> u8>,
    pub duckdb_get_int16: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> i16>,
    pub duckdb_get_uint16: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> u16>,
    pub duckdb_get_int32: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> i32>,
    pub duckdb_get_uint32: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> u32>,
    pub duckdb_get_uint64: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> u64>,
    pub duckdb_get_hugeint: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> duckdb_hugeint>,
    pub duckdb_get_uhugeint: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> duckdb_uhugeint>,
    pub duckdb_get_float: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> f32>,
    pub duckdb_get_double: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> f64>,
    pub duckdb_get_date: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> duckdb_date>,
    pub duckdb_get_time: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> duckdb_time>,
    pub duckdb_get_time_tz: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> duckdb_time_tz>,
    pub duckdb_get_timestamp: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> duckdb_timestamp>,
    pub duckdb_get_interval: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> duckdb_interval>,
    pub duckdb_get_value_type: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> duckdb_logical_type>,
    pub duckdb_get_blob: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> duckdb_blob>,
    pub duckdb_create_scalar_function_set:
        ::std::option::Option<unsafe extern "C" fn(name: *const ::std::os::raw::c_char) -> duckdb_scalar_function_set>,
    pub duckdb_destroy_scalar_function_set:
        ::std::option::Option<unsafe extern "C" fn(scalar_function_set: *mut duckdb_scalar_function_set)>,
    pub duckdb_add_scalar_function_to_set: ::std::option::Option<
        unsafe extern "C" fn(set: duckdb_scalar_function_set, function: duckdb_scalar_function) -> duckdb_state,
    >,
    pub duckdb_register_scalar_function_set: ::std::option::Option<
        unsafe extern "C" fn(con: duckdb_connection, set: duckdb_scalar_function_set) -> duckdb_state,
    >,
    pub duckdb_create_aggregate_function_set: ::std::option::Option<
        unsafe extern "C" fn(name: *const ::std::os::raw::c_char) -> duckdb_aggregate_function_set,
    >,
    pub duckdb_destroy_aggregate_function_set:
        ::std::option::Option<unsafe extern "C" fn(aggregate_function_set: *mut duckdb_aggregate_function_set)>,
    pub duckdb_add_aggregate_function_to_set: ::std::option::Option<
        unsafe extern "C" fn(set: duckdb_aggregate_function_set, function: duckdb_aggregate_function) -> duckdb_state,
    >,
    pub duckdb_register_aggregate_function_set: ::std::option::Option<
        unsafe extern "C" fn(con: duckdb_connection, set: duckdb_aggregate_function_set) -> duckdb_state,
    >,
}
#[test]
fn bindgen_test_layout_duckdb_ext_api_v0() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_ext_api_v0> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_ext_api_v0>(),
        2352usize,
        concat!("Size of: ", stringify!(duckdb_ext_api_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_ext_api_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_ext_api_v0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_open) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_open_ext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_open_ext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_close) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_connect) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_connect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_interrupt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_interrupt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_query_progress) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_query_progress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_disconnect) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_disconnect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_library_version) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_library_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_config) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_config_count) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_config_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_config_flag) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_config_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_set_config) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_set_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_config) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_query) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_query)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_result) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_column_name) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_column_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_column_type) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_column_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_result_statement_type) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_result_statement_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_column_logical_type) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_column_logical_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_column_count) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_column_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_rows_changed) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_rows_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_result_error) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_result_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_malloc) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_malloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_free) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_vector_size) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_vector_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_string_is_inlined) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_string_is_inlined)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_from_date) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_from_date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_to_date) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_to_date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_is_finite_date) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_is_finite_date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_from_time) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_from_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_time_tz) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_time_tz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_from_time_tz) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_from_time_tz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_to_time) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_to_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_from_timestamp) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_from_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_to_timestamp) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_to_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_is_finite_timestamp) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_is_finite_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_hugeint_to_double) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_hugeint_to_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_double_to_hugeint) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_double_to_hugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_uhugeint_to_double) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_uhugeint_to_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_double_to_uhugeint) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_double_to_uhugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_double_to_decimal) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_double_to_decimal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_decimal_to_double) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_decimal_to_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_prepare) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_prepare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_prepare) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_prepare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_prepare_error) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_prepare_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_nparams) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_nparams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_parameter_name) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_parameter_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_param_type) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_param_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_clear_bindings) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_clear_bindings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_prepared_statement_type) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_prepared_statement_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_value) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_parameter_index) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_parameter_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_boolean) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_int8) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_int8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_int16) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_int16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_int32) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_int32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_int64) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_hugeint) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_hugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_uhugeint) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_uhugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_decimal) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_decimal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_uint8) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_uint8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_uint16) as usize - ptr as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_uint16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_uint32) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_uint32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_uint64) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_uint64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_float) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_double) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_date) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_time) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_timestamp) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_timestamp_tz) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_timestamp_tz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_interval) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_varchar) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_varchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_varchar_length) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_varchar_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_blob) as usize - ptr as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_blob)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_null) as usize - ptr as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_null)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_execute_prepared) as usize - ptr as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_execute_prepared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_extract_statements) as usize - ptr as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_extract_statements)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_prepare_extracted_statement) as usize - ptr as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_prepare_extracted_statement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_extract_statements_error) as usize - ptr as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_extract_statements_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_extracted) as usize - ptr as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_extracted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_pending_prepared) as usize - ptr as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_pending_prepared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_pending) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_pending)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_pending_error) as usize - ptr as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_pending_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_pending_execute_task) as usize - ptr as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_pending_execute_task)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_pending_execute_check_state) as usize - ptr as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_pending_execute_check_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_execute_pending) as usize - ptr as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_execute_pending)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_pending_execution_is_finished) as usize - ptr as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_pending_execution_is_finished)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_value) as usize - ptr as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_varchar) as usize - ptr as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_varchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_varchar_length) as usize - ptr as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_varchar_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_int64) as usize - ptr as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_struct_value) as usize - ptr as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_struct_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_list_value) as usize - ptr as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_list_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_array_value) as usize - ptr as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_array_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_varchar) as usize - ptr as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_varchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_int64) as usize - ptr as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_logical_type) as usize - ptr as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_logical_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_logical_type_get_alias) as usize - ptr as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_logical_type_get_alias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_list_type) as usize - ptr as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_list_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_array_type) as usize - ptr as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_array_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_map_type) as usize - ptr as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_map_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_union_type) as usize - ptr as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_union_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_struct_type) as usize - ptr as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_struct_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_enum_type) as usize - ptr as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_enum_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_decimal_type) as usize - ptr as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_decimal_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_type_id) as usize - ptr as usize },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_type_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_decimal_width) as usize - ptr as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_decimal_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_decimal_scale) as usize - ptr as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_decimal_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_decimal_internal_type) as usize - ptr as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_decimal_internal_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_enum_internal_type) as usize - ptr as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_enum_internal_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_enum_dictionary_size) as usize - ptr as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_enum_dictionary_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_enum_dictionary_value) as usize - ptr as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_enum_dictionary_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_list_type_child_type) as usize - ptr as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_list_type_child_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_array_type_child_type) as usize - ptr as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_array_type_child_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_array_type_array_size) as usize - ptr as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_array_type_array_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_map_type_key_type) as usize - ptr as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_map_type_key_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_map_type_value_type) as usize - ptr as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_map_type_value_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_struct_type_child_count) as usize - ptr as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_struct_type_child_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_struct_type_child_name) as usize - ptr as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_struct_type_child_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_struct_type_child_type) as usize - ptr as usize },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_struct_type_child_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_union_type_member_count) as usize - ptr as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_union_type_member_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_union_type_member_name) as usize - ptr as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_union_type_member_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_union_type_member_type) as usize - ptr as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_union_type_member_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_logical_type) as usize - ptr as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_logical_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_fetch_chunk) as usize - ptr as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_fetch_chunk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_data_chunk) as usize - ptr as usize },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_data_chunk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_data_chunk) as usize - ptr as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_data_chunk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_data_chunk_reset) as usize - ptr as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_data_chunk_reset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_data_chunk_get_column_count) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_data_chunk_get_column_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_data_chunk_get_vector) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_data_chunk_get_vector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_data_chunk_get_size) as usize - ptr as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_data_chunk_get_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_data_chunk_set_size) as usize - ptr as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_data_chunk_set_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_vector_get_column_type) as usize - ptr as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_vector_get_column_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_vector_get_data) as usize - ptr as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_vector_get_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_vector_get_validity) as usize - ptr as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_vector_get_validity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_vector_ensure_validity_writable) as usize - ptr as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_vector_ensure_validity_writable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_vector_assign_string_element) as usize - ptr as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_vector_assign_string_element)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_vector_assign_string_element_len) as usize - ptr as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_vector_assign_string_element_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_list_vector_get_child) as usize - ptr as usize },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_list_vector_get_child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_list_vector_get_size) as usize - ptr as usize },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_list_vector_get_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_list_vector_set_size) as usize - ptr as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_list_vector_set_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_list_vector_reserve) as usize - ptr as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_list_vector_reserve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_struct_vector_get_child) as usize - ptr as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_struct_vector_get_child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_array_vector_get_child) as usize - ptr as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_array_vector_get_child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_validity_row_is_valid) as usize - ptr as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_validity_row_is_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_validity_set_row_validity) as usize - ptr as usize },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_validity_set_row_validity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_validity_set_row_invalid) as usize - ptr as usize },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_validity_set_row_invalid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_validity_set_row_valid) as usize - ptr as usize },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_validity_set_row_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_scalar_function) as usize - ptr as usize },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_scalar_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_scalar_function) as usize - ptr as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_scalar_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_set_name) as usize - ptr as usize },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_set_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_add_parameter) as usize - ptr as usize },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_add_parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_set_return_type) as usize - ptr as usize },
        1216usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_set_return_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_set_extra_info) as usize - ptr as usize },
        1224usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_set_extra_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_set_function) as usize - ptr as usize },
        1232usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_set_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_register_scalar_function) as usize - ptr as usize },
        1240usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_register_scalar_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_table_function) as usize - ptr as usize },
        1248usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_table_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_table_function) as usize - ptr as usize },
        1256usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_table_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_function_set_name) as usize - ptr as usize },
        1264usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_function_set_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_function_add_parameter) as usize - ptr as usize },
        1272usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_function_add_parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_function_add_named_parameter) as usize - ptr as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_function_add_named_parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_function_set_extra_info) as usize - ptr as usize },
        1288usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_function_set_extra_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_function_set_bind) as usize - ptr as usize },
        1296usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_function_set_bind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_function_set_init) as usize - ptr as usize },
        1304usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_function_set_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_function_set_local_init) as usize - ptr as usize },
        1312usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_function_set_local_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_function_set_function) as usize - ptr as usize },
        1320usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_function_set_function)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).duckdb_table_function_supports_projection_pushdown) as usize - ptr as usize
        },
        1328usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_function_supports_projection_pushdown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_register_table_function) as usize - ptr as usize },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_register_table_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_get_extra_info) as usize - ptr as usize },
        1344usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_get_extra_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_add_result_column) as usize - ptr as usize },
        1352usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_add_result_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_get_parameter_count) as usize - ptr as usize },
        1360usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_get_parameter_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_get_parameter) as usize - ptr as usize },
        1368usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_get_parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_get_named_parameter) as usize - ptr as usize },
        1376usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_get_named_parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_set_bind_data) as usize - ptr as usize },
        1384usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_set_bind_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_set_cardinality) as usize - ptr as usize },
        1392usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_set_cardinality)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_set_error) as usize - ptr as usize },
        1400usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_set_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_init_get_extra_info) as usize - ptr as usize },
        1408usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_init_get_extra_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_init_get_bind_data) as usize - ptr as usize },
        1416usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_init_get_bind_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_init_set_init_data) as usize - ptr as usize },
        1424usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_init_set_init_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_init_get_column_count) as usize - ptr as usize },
        1432usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_init_get_column_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_init_get_column_index) as usize - ptr as usize },
        1440usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_init_get_column_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_init_set_max_threads) as usize - ptr as usize },
        1448usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_init_set_max_threads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_init_set_error) as usize - ptr as usize },
        1456usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_init_set_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_function_get_extra_info) as usize - ptr as usize },
        1464usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_function_get_extra_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_function_get_bind_data) as usize - ptr as usize },
        1472usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_function_get_bind_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_function_get_init_data) as usize - ptr as usize },
        1480usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_function_get_init_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_function_get_local_init_data) as usize - ptr as usize },
        1488usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_function_get_local_init_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_function_set_error) as usize - ptr as usize },
        1496usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_function_set_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_add_replacement_scan) as usize - ptr as usize },
        1504usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_add_replacement_scan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_replacement_scan_set_function_name) as usize - ptr as usize },
        1512usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_replacement_scan_set_function_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_replacement_scan_add_parameter) as usize - ptr as usize },
        1520usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_replacement_scan_add_parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_replacement_scan_set_error) as usize - ptr as usize },
        1528usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_replacement_scan_set_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_appender_create) as usize - ptr as usize },
        1536usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_appender_create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_appender_column_count) as usize - ptr as usize },
        1544usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_appender_column_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_appender_column_type) as usize - ptr as usize },
        1552usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_appender_column_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_appender_error) as usize - ptr as usize },
        1560usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_appender_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_appender_flush) as usize - ptr as usize },
        1568usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_appender_flush)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_appender_close) as usize - ptr as usize },
        1576usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_appender_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_appender_destroy) as usize - ptr as usize },
        1584usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_appender_destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_appender_begin_row) as usize - ptr as usize },
        1592usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_appender_begin_row)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_appender_end_row) as usize - ptr as usize },
        1600usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_appender_end_row)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_default) as usize - ptr as usize },
        1608usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_bool) as usize - ptr as usize },
        1616usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_bool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_int8) as usize - ptr as usize },
        1624usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_int8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_int16) as usize - ptr as usize },
        1632usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_int16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_int32) as usize - ptr as usize },
        1640usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_int32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_int64) as usize - ptr as usize },
        1648usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_hugeint) as usize - ptr as usize },
        1656usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_hugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_uint8) as usize - ptr as usize },
        1664usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_uint8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_uint16) as usize - ptr as usize },
        1672usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_uint16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_uint32) as usize - ptr as usize },
        1680usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_uint32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_uint64) as usize - ptr as usize },
        1688usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_uint64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_uhugeint) as usize - ptr as usize },
        1696usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_uhugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_float) as usize - ptr as usize },
        1704usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_double) as usize - ptr as usize },
        1712usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_date) as usize - ptr as usize },
        1720usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_time) as usize - ptr as usize },
        1728usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_timestamp) as usize - ptr as usize },
        1736usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_interval) as usize - ptr as usize },
        1744usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_varchar) as usize - ptr as usize },
        1752usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_varchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_varchar_length) as usize - ptr as usize },
        1760usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_varchar_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_blob) as usize - ptr as usize },
        1768usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_blob)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_null) as usize - ptr as usize },
        1776usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_null)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_data_chunk) as usize - ptr as usize },
        1784usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_data_chunk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_execute_tasks) as usize - ptr as usize },
        1792usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_execute_tasks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_task_state) as usize - ptr as usize },
        1800usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_task_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_execute_tasks_state) as usize - ptr as usize },
        1808usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_execute_tasks_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_execute_n_tasks_state) as usize - ptr as usize },
        1816usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_execute_n_tasks_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_finish_execution) as usize - ptr as usize },
        1824usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_finish_execution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_task_state_is_finished) as usize - ptr as usize },
        1832usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_task_state_is_finished)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_task_state) as usize - ptr as usize },
        1840usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_task_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_execution_is_finished) as usize - ptr as usize },
        1848usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_execution_is_finished)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_profiling_info) as usize - ptr as usize },
        1856usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_profiling_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_profiling_info_get_value) as usize - ptr as usize },
        1864usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_profiling_info_get_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_profiling_info_get_child_count) as usize - ptr as usize },
        1872usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_profiling_info_get_child_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_profiling_info_get_child) as usize - ptr as usize },
        1880usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_profiling_info_get_child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_profiling_info_get_name) as usize - ptr as usize },
        1888usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_profiling_info_get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_profiling_info_get_query) as usize - ptr as usize },
        1896usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_profiling_info_get_query)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_set_varargs) as usize - ptr as usize },
        1904usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_set_varargs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_set_special_handling) as usize - ptr as usize },
        1912usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_set_special_handling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_set_volatile) as usize - ptr as usize },
        1920usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_set_volatile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_get_extra_info) as usize - ptr as usize },
        1928usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_get_extra_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_set_error) as usize - ptr as usize },
        1936usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_set_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_description_create) as usize - ptr as usize },
        1944usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_description_create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_description_destroy) as usize - ptr as usize },
        1952usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_description_destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_description_error) as usize - ptr as usize },
        1960usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_description_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_result_error_type) as usize - ptr as usize },
        1968usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_result_error_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_string_t_length) as usize - ptr as usize },
        1976usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_string_t_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_string_t_data) as usize - ptr as usize },
        1984usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_string_t_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_bool) as usize - ptr as usize },
        1992usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_bool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_int8) as usize - ptr as usize },
        2000usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_int8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_uint8) as usize - ptr as usize },
        2008usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_uint8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_int16) as usize - ptr as usize },
        2016usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_int16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_uint16) as usize - ptr as usize },
        2024usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_uint16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_int32) as usize - ptr as usize },
        2032usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_int32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_uint32) as usize - ptr as usize },
        2040usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_uint32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_uint64) as usize - ptr as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_uint64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_hugeint) as usize - ptr as usize },
        2056usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_hugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_uhugeint) as usize - ptr as usize },
        2064usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_uhugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_float) as usize - ptr as usize },
        2072usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_double) as usize - ptr as usize },
        2080usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_date) as usize - ptr as usize },
        2088usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_time) as usize - ptr as usize },
        2096usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_time_tz_value) as usize - ptr as usize },
        2104usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_time_tz_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_timestamp) as usize - ptr as usize },
        2112usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_interval) as usize - ptr as usize },
        2120usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_blob) as usize - ptr as usize },
        2128usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_blob)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_bool) as usize - ptr as usize },
        2136usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_bool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_int8) as usize - ptr as usize },
        2144usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_int8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_uint8) as usize - ptr as usize },
        2152usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_uint8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_int16) as usize - ptr as usize },
        2160usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_int16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_uint16) as usize - ptr as usize },
        2168usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_uint16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_int32) as usize - ptr as usize },
        2176usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_int32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_uint32) as usize - ptr as usize },
        2184usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_uint32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_uint64) as usize - ptr as usize },
        2192usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_uint64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_hugeint) as usize - ptr as usize },
        2200usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_hugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_uhugeint) as usize - ptr as usize },
        2208usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_uhugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_float) as usize - ptr as usize },
        2216usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_double) as usize - ptr as usize },
        2224usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_date) as usize - ptr as usize },
        2232usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_time) as usize - ptr as usize },
        2240usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_time_tz) as usize - ptr as usize },
        2248usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_time_tz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_timestamp) as usize - ptr as usize },
        2256usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_interval) as usize - ptr as usize },
        2264usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_value_type) as usize - ptr as usize },
        2272usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_value_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_blob) as usize - ptr as usize },
        2280usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_blob)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_scalar_function_set) as usize - ptr as usize },
        2288usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_scalar_function_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_scalar_function_set) as usize - ptr as usize },
        2296usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_scalar_function_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_add_scalar_function_to_set) as usize - ptr as usize },
        2304usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_add_scalar_function_to_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_register_scalar_function_set) as usize - ptr as usize },
        2312usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_register_scalar_function_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_aggregate_function_set) as usize - ptr as usize },
        2320usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_aggregate_function_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_aggregate_function_set) as usize - ptr as usize },
        2328usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_aggregate_function_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_add_aggregate_function_to_set) as usize - ptr as usize },
        2336usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_add_aggregate_function_to_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_register_aggregate_function_set) as usize - ptr as usize },
        2344usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_register_aggregate_function_set)
        )
    );
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
static __DUCKDB_OPEN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_open(
    path: *const ::std::os::raw::c_char,
    out_database: *mut duckdb_database,
) -> duckdb_state {
    let function_ptr = __DUCKDB_OPEN.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        path: *const ::std::os::raw::c_char,
        out_database: *mut duckdb_database,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(path, out_database)
}

static __DUCKDB_OPEN_EXT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_open_ext(
    path: *const ::std::os::raw::c_char,
    out_database: *mut duckdb_database,
    config: duckdb_config,
    out_error: *mut *mut ::std::os::raw::c_char,
) -> duckdb_state {
    let function_ptr = __DUCKDB_OPEN_EXT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        path: *const ::std::os::raw::c_char,
        out_database: *mut duckdb_database,
        config: duckdb_config,
        out_error: *mut *mut ::std::os::raw::c_char,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(path, out_database, config, out_error)
}

static __DUCKDB_CLOSE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_close(database: *mut duckdb_database) {
    let function_ptr = __DUCKDB_CLOSE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(database: *mut duckdb_database) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(database)
}

static __DUCKDB_CONNECT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_connect(
    database: duckdb_database,
    out_connection: *mut duckdb_connection,
) -> duckdb_state {
    let function_ptr = __DUCKDB_CONNECT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        database: duckdb_database,
        out_connection: *mut duckdb_connection,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(database, out_connection)
}

static __DUCKDB_INTERRUPT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_interrupt(connection: duckdb_connection) {
    let function_ptr = __DUCKDB_INTERRUPT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(connection: duckdb_connection) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(connection)
}

static __DUCKDB_QUERY_PROGRESS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_query_progress(
    connection: duckdb_connection,
) -> duckdb_query_progress_type {
    let function_ptr = __DUCKDB_QUERY_PROGRESS
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        connection: duckdb_connection,
    ) -> duckdb_query_progress_type = ::std::mem::transmute(function_ptr);
    (fun)(connection)
}

static __DUCKDB_DISCONNECT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_disconnect(connection: *mut duckdb_connection) {
    let function_ptr = __DUCKDB_DISCONNECT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(connection: *mut duckdb_connection) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(connection)
}

static __DUCKDB_LIBRARY_VERSION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_library_version() -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_LIBRARY_VERSION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn() -> *const ::std::os::raw::c_char = ::std::mem::transmute(
        function_ptr,
    );
    (fun)()
}

static __DUCKDB_CREATE_CONFIG: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_config(out_config: *mut duckdb_config) -> duckdb_state {
    let function_ptr = __DUCKDB_CREATE_CONFIG
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(out_config: *mut duckdb_config) -> duckdb_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(out_config)
}

static __DUCKDB_CONFIG_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_config_count() -> usize {
    let function_ptr = __DUCKDB_CONFIG_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn() -> usize = ::std::mem::transmute(function_ptr);
    (fun)()
}

static __DUCKDB_GET_CONFIG_FLAG: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_config_flag(
    index: usize,
    out_name: *mut *const ::std::os::raw::c_char,
    out_description: *mut *const ::std::os::raw::c_char,
) -> duckdb_state {
    let function_ptr = __DUCKDB_GET_CONFIG_FLAG
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        index: usize,
        out_name: *mut *const ::std::os::raw::c_char,
        out_description: *mut *const ::std::os::raw::c_char,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(index, out_name, out_description)
}

static __DUCKDB_SET_CONFIG: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_set_config(
    config: duckdb_config,
    name: *const ::std::os::raw::c_char,
    option: *const ::std::os::raw::c_char,
) -> duckdb_state {
    let function_ptr = __DUCKDB_SET_CONFIG.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        config: duckdb_config,
        name: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(config, name, option)
}

static __DUCKDB_DESTROY_CONFIG: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_config(config: *mut duckdb_config) {
    let function_ptr = __DUCKDB_DESTROY_CONFIG
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(config: *mut duckdb_config) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(config)
}

static __DUCKDB_QUERY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_query(
    connection: duckdb_connection,
    query: *const ::std::os::raw::c_char,
    out_result: *mut duckdb_result,
) -> duckdb_state {
    let function_ptr = __DUCKDB_QUERY.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        connection: duckdb_connection,
        query: *const ::std::os::raw::c_char,
        out_result: *mut duckdb_result,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(connection, query, out_result)
}

static __DUCKDB_DESTROY_RESULT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_result(result: *mut duckdb_result) {
    let function_ptr = __DUCKDB_DESTROY_RESULT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: *mut duckdb_result) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_COLUMN_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_column_name(
    result: *mut duckdb_result,
    col: idx_t,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_COLUMN_NAME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(result, col)
}

static __DUCKDB_COLUMN_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_column_type(result: *mut duckdb_result, col: idx_t) -> duckdb_type {
    let function_ptr = __DUCKDB_COLUMN_TYPE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
    ) -> duckdb_type = ::std::mem::transmute(function_ptr);
    (fun)(result, col)
}

static __DUCKDB_RESULT_STATEMENT_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_result_statement_type(
    result: duckdb_result,
) -> duckdb_statement_type {
    let function_ptr = __DUCKDB_RESULT_STATEMENT_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: duckdb_result) -> duckdb_statement_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_COLUMN_LOGICAL_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_column_logical_type(
    result: *mut duckdb_result,
    col: idx_t,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_COLUMN_LOGICAL_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
    ) -> duckdb_logical_type = ::std::mem::transmute(function_ptr);
    (fun)(result, col)
}

static __DUCKDB_COLUMN_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_column_count(result: *mut duckdb_result) -> idx_t {
    let function_ptr = __DUCKDB_COLUMN_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: *mut duckdb_result) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_ROWS_CHANGED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_rows_changed(result: *mut duckdb_result) -> idx_t {
    let function_ptr = __DUCKDB_ROWS_CHANGED
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: *mut duckdb_result) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_RESULT_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_result_error(
    result: *mut duckdb_result,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_RESULT_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(result)
}

static __DUCKDB_MALLOC: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_malloc(size: usize) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_MALLOC.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(size)
}

static __DUCKDB_FREE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_free(ptr: *mut ::std::os::raw::c_void) {
    let function_ptr = __DUCKDB_FREE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(ptr)
}

static __DUCKDB_VECTOR_SIZE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_vector_size() -> idx_t {
    let function_ptr = __DUCKDB_VECTOR_SIZE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn() -> idx_t = ::std::mem::transmute(function_ptr);
    (fun)()
}

static __DUCKDB_STRING_IS_INLINED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_string_is_inlined(string: duckdb_string_t) -> bool {
    let function_ptr = __DUCKDB_STRING_IS_INLINED
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(string: duckdb_string_t) -> bool = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(string)
}

static __DUCKDB_FROM_DATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_from_date(date: duckdb_date) -> duckdb_date_struct {
    let function_ptr = __DUCKDB_FROM_DATE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(date: duckdb_date) -> duckdb_date_struct = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(date)
}

static __DUCKDB_TO_DATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_to_date(date: duckdb_date_struct) -> duckdb_date {
    let function_ptr = __DUCKDB_TO_DATE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(date: duckdb_date_struct) -> duckdb_date = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(date)
}

static __DUCKDB_IS_FINITE_DATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_is_finite_date(date: duckdb_date) -> bool {
    let function_ptr = __DUCKDB_IS_FINITE_DATE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(date: duckdb_date) -> bool = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(date)
}

static __DUCKDB_FROM_TIME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_from_time(time: duckdb_time) -> duckdb_time_struct {
    let function_ptr = __DUCKDB_FROM_TIME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(time: duckdb_time) -> duckdb_time_struct = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(time)
}

static __DUCKDB_CREATE_TIME_TZ: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_time_tz(micros: i64, offset: i32) -> duckdb_time_tz {
    let function_ptr = __DUCKDB_CREATE_TIME_TZ
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(micros: i64, offset: i32) -> duckdb_time_tz = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(micros, offset)
}

static __DUCKDB_FROM_TIME_TZ: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_from_time_tz(micros: duckdb_time_tz) -> duckdb_time_tz_struct {
    let function_ptr = __DUCKDB_FROM_TIME_TZ
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(micros: duckdb_time_tz) -> duckdb_time_tz_struct = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(micros)
}

static __DUCKDB_TO_TIME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_to_time(time: duckdb_time_struct) -> duckdb_time {
    let function_ptr = __DUCKDB_TO_TIME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(time: duckdb_time_struct) -> duckdb_time = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(time)
}

static __DUCKDB_FROM_TIMESTAMP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_from_timestamp(ts: duckdb_timestamp) -> duckdb_timestamp_struct {
    let function_ptr = __DUCKDB_FROM_TIMESTAMP
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(ts: duckdb_timestamp) -> duckdb_timestamp_struct = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(ts)
}

static __DUCKDB_TO_TIMESTAMP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_to_timestamp(ts: duckdb_timestamp_struct) -> duckdb_timestamp {
    let function_ptr = __DUCKDB_TO_TIMESTAMP
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(ts: duckdb_timestamp_struct) -> duckdb_timestamp = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(ts)
}

static __DUCKDB_IS_FINITE_TIMESTAMP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_is_finite_timestamp(ts: duckdb_timestamp) -> bool {
    let function_ptr = __DUCKDB_IS_FINITE_TIMESTAMP
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(ts: duckdb_timestamp) -> bool = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(ts)
}

static __DUCKDB_HUGEINT_TO_DOUBLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_hugeint_to_double(val: duckdb_hugeint) -> f64 {
    let function_ptr = __DUCKDB_HUGEINT_TO_DOUBLE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_hugeint) -> f64 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_DOUBLE_TO_HUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_double_to_hugeint(val: f64) -> duckdb_hugeint {
    let function_ptr = __DUCKDB_DOUBLE_TO_HUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: f64) -> duckdb_hugeint = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_UHUGEINT_TO_DOUBLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_uhugeint_to_double(val: duckdb_uhugeint) -> f64 {
    let function_ptr = __DUCKDB_UHUGEINT_TO_DOUBLE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_uhugeint) -> f64 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_DOUBLE_TO_UHUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_double_to_uhugeint(val: f64) -> duckdb_uhugeint {
    let function_ptr = __DUCKDB_DOUBLE_TO_UHUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: f64) -> duckdb_uhugeint = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_DOUBLE_TO_DECIMAL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_double_to_decimal(
    val: f64,
    width: u8,
    scale: u8,
) -> duckdb_decimal {
    let function_ptr = __DUCKDB_DOUBLE_TO_DECIMAL
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: f64, width: u8, scale: u8) -> duckdb_decimal = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val, width, scale)
}

static __DUCKDB_DECIMAL_TO_DOUBLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_decimal_to_double(val: duckdb_decimal) -> f64 {
    let function_ptr = __DUCKDB_DECIMAL_TO_DOUBLE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_decimal) -> f64 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_PREPARE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_prepare(
    connection: duckdb_connection,
    query: *const ::std::os::raw::c_char,
    out_prepared_statement: *mut duckdb_prepared_statement,
) -> duckdb_state {
    let function_ptr = __DUCKDB_PREPARE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        connection: duckdb_connection,
        query: *const ::std::os::raw::c_char,
        out_prepared_statement: *mut duckdb_prepared_statement,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(connection, query, out_prepared_statement)
}

static __DUCKDB_DESTROY_PREPARE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_prepare(
    prepared_statement: *mut duckdb_prepared_statement,
) {
    let function_ptr = __DUCKDB_DESTROY_PREPARE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(prepared_statement: *mut duckdb_prepared_statement) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(prepared_statement)
}

static __DUCKDB_PREPARE_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_prepare_error(
    prepared_statement: duckdb_prepared_statement,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_PREPARE_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement)
}

static __DUCKDB_NPARAMS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_nparams(prepared_statement: duckdb_prepared_statement) -> idx_t {
    let function_ptr = __DUCKDB_NPARAMS.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
    ) -> idx_t = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement)
}

static __DUCKDB_PARAMETER_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_parameter_name(
    prepared_statement: duckdb_prepared_statement,
    index: idx_t,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_PARAMETER_NAME
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        index: idx_t,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, index)
}

static __DUCKDB_PARAM_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_param_type(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
) -> duckdb_type {
    let function_ptr = __DUCKDB_PARAM_TYPE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
    ) -> duckdb_type = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx)
}

static __DUCKDB_CLEAR_BINDINGS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_clear_bindings(
    prepared_statement: duckdb_prepared_statement,
) -> duckdb_state {
    let function_ptr = __DUCKDB_CLEAR_BINDINGS
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement)
}

static __DUCKDB_PREPARED_STATEMENT_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_prepared_statement_type(
    statement: duckdb_prepared_statement,
) -> duckdb_statement_type {
    let function_ptr = __DUCKDB_PREPARED_STATEMENT_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        statement: duckdb_prepared_statement,
    ) -> duckdb_statement_type = ::std::mem::transmute(function_ptr);
    (fun)(statement)
}

static __DUCKDB_BIND_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_value(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: duckdb_value,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_VALUE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_value,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_PARAMETER_INDEX: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_parameter_index(
    prepared_statement: duckdb_prepared_statement,
    param_idx_out: *mut idx_t,
    name: *const ::std::os::raw::c_char,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_PARAMETER_INDEX
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx_out: *mut idx_t,
        name: *const ::std::os::raw::c_char,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx_out, name)
}

static __DUCKDB_BIND_BOOLEAN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_boolean(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: bool,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_BOOLEAN
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: bool,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_INT8: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_int8(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: i8,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_INT8.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: i8,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_INT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_int16(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: i16,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_INT16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: i16,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_INT32: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_int32(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: i32,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_INT32.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: i32,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_INT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_int64(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: i64,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_INT64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: i64,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_HUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_hugeint(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: duckdb_hugeint,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_HUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_hugeint,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_UHUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_uhugeint(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: duckdb_uhugeint,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_UHUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_uhugeint,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_DECIMAL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_decimal(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: duckdb_decimal,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_DECIMAL
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_decimal,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_UINT8: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_uint8(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: u8,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_UINT8.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: u8,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_UINT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_uint16(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: u16,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_UINT16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: u16,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_UINT32: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_uint32(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: u32,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_UINT32.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: u32,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_UINT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_uint64(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: u64,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_UINT64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: u64,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_FLOAT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_float(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: f32,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_FLOAT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: f32,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_DOUBLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_double(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: f64,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_DOUBLE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: f64,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_DATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_date(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: duckdb_date,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_DATE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_date,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_TIME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_time(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: duckdb_time,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_TIME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_time,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_TIMESTAMP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_timestamp(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: duckdb_timestamp,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_TIMESTAMP
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_timestamp,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_TIMESTAMP_TZ: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_timestamp_tz(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: duckdb_timestamp,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_TIMESTAMP_TZ
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_timestamp,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_INTERVAL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_interval(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: duckdb_interval,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_INTERVAL
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_interval,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_VARCHAR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_varchar(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: *const ::std::os::raw::c_char,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_VARCHAR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: *const ::std::os::raw::c_char,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_VARCHAR_LENGTH: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_varchar_length(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: *const ::std::os::raw::c_char,
    length: idx_t,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_VARCHAR_LENGTH
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: *const ::std::os::raw::c_char,
        length: idx_t,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val, length)
}

static __DUCKDB_BIND_BLOB: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_blob(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    data: *const ::std::os::raw::c_void,
    length: idx_t,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_BLOB.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        data: *const ::std::os::raw::c_void,
        length: idx_t,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, data, length)
}

static __DUCKDB_BIND_NULL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_null(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_NULL.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx)
}

static __DUCKDB_EXECUTE_PREPARED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_execute_prepared(
    prepared_statement: duckdb_prepared_statement,
    out_result: *mut duckdb_result,
) -> duckdb_state {
    let function_ptr = __DUCKDB_EXECUTE_PREPARED
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        out_result: *mut duckdb_result,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, out_result)
}

static __DUCKDB_EXTRACT_STATEMENTS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_extract_statements(
    connection: duckdb_connection,
    query: *const ::std::os::raw::c_char,
    out_extracted_statements: *mut duckdb_extracted_statements,
) -> idx_t {
    let function_ptr = __DUCKDB_EXTRACT_STATEMENTS
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        connection: duckdb_connection,
        query: *const ::std::os::raw::c_char,
        out_extracted_statements: *mut duckdb_extracted_statements,
    ) -> idx_t = ::std::mem::transmute(function_ptr);
    (fun)(connection, query, out_extracted_statements)
}

static __DUCKDB_PREPARE_EXTRACTED_STATEMENT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_prepare_extracted_statement(
    connection: duckdb_connection,
    extracted_statements: duckdb_extracted_statements,
    index: idx_t,
    out_prepared_statement: *mut duckdb_prepared_statement,
) -> duckdb_state {
    let function_ptr = __DUCKDB_PREPARE_EXTRACTED_STATEMENT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        connection: duckdb_connection,
        extracted_statements: duckdb_extracted_statements,
        index: idx_t,
        out_prepared_statement: *mut duckdb_prepared_statement,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(connection, extracted_statements, index, out_prepared_statement)
}

static __DUCKDB_EXTRACT_STATEMENTS_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_extract_statements_error(
    extracted_statements: duckdb_extracted_statements,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_EXTRACT_STATEMENTS_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        extracted_statements: duckdb_extracted_statements,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(extracted_statements)
}

static __DUCKDB_DESTROY_EXTRACTED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_extracted(
    extracted_statements: *mut duckdb_extracted_statements,
) {
    let function_ptr = __DUCKDB_DESTROY_EXTRACTED
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        extracted_statements: *mut duckdb_extracted_statements,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(extracted_statements)
}

static __DUCKDB_PENDING_PREPARED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_pending_prepared(
    prepared_statement: duckdb_prepared_statement,
    out_result: *mut duckdb_pending_result,
) -> duckdb_state {
    let function_ptr = __DUCKDB_PENDING_PREPARED
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        out_result: *mut duckdb_pending_result,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, out_result)
}

static __DUCKDB_DESTROY_PENDING: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_pending(pending_result: *mut duckdb_pending_result) {
    let function_ptr = __DUCKDB_DESTROY_PENDING
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(pending_result: *mut duckdb_pending_result) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(pending_result)
}

static __DUCKDB_PENDING_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_pending_error(
    pending_result: duckdb_pending_result,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_PENDING_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        pending_result: duckdb_pending_result,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(pending_result)
}

static __DUCKDB_PENDING_EXECUTE_TASK: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_pending_execute_task(
    pending_result: duckdb_pending_result,
) -> duckdb_pending_state {
    let function_ptr = __DUCKDB_PENDING_EXECUTE_TASK
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        pending_result: duckdb_pending_result,
    ) -> duckdb_pending_state = ::std::mem::transmute(function_ptr);
    (fun)(pending_result)
}

static __DUCKDB_PENDING_EXECUTE_CHECK_STATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_pending_execute_check_state(
    pending_result: duckdb_pending_result,
) -> duckdb_pending_state {
    let function_ptr = __DUCKDB_PENDING_EXECUTE_CHECK_STATE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        pending_result: duckdb_pending_result,
    ) -> duckdb_pending_state = ::std::mem::transmute(function_ptr);
    (fun)(pending_result)
}

static __DUCKDB_EXECUTE_PENDING: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_execute_pending(
    pending_result: duckdb_pending_result,
    out_result: *mut duckdb_result,
) -> duckdb_state {
    let function_ptr = __DUCKDB_EXECUTE_PENDING
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        pending_result: duckdb_pending_result,
        out_result: *mut duckdb_result,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(pending_result, out_result)
}

static __DUCKDB_PENDING_EXECUTION_IS_FINISHED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_pending_execution_is_finished(
    pending_state: duckdb_pending_state,
) -> bool {
    let function_ptr = __DUCKDB_PENDING_EXECUTION_IS_FINISHED
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(pending_state: duckdb_pending_state) -> bool = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(pending_state)
}

static __DUCKDB_DESTROY_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_value(value: *mut duckdb_value) {
    let function_ptr = __DUCKDB_DESTROY_VALUE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(value: *mut duckdb_value) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(value)
}

static __DUCKDB_CREATE_VARCHAR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_varchar(
    text: *const ::std::os::raw::c_char,
) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_VARCHAR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(text: *const ::std::os::raw::c_char) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(text)
}

static __DUCKDB_CREATE_VARCHAR_LENGTH: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_varchar_length(
    text: *const ::std::os::raw::c_char,
    length: idx_t,
) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_VARCHAR_LENGTH
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        text: *const ::std::os::raw::c_char,
        length: idx_t,
    ) -> duckdb_value = ::std::mem::transmute(function_ptr);
    (fun)(text, length)
}

static __DUCKDB_CREATE_INT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_int64(val: i64) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_INT64
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: i64) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_CREATE_STRUCT_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_struct_value(
    type_: duckdb_logical_type,
    values: *mut duckdb_value,
) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_STRUCT_VALUE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
        values: *mut duckdb_value,
    ) -> duckdb_value = ::std::mem::transmute(function_ptr);
    (fun)(type_, values)
}

static __DUCKDB_CREATE_LIST_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_list_value(
    type_: duckdb_logical_type,
    values: *mut duckdb_value,
    value_count: idx_t,
) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_LIST_VALUE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
        values: *mut duckdb_value,
        value_count: idx_t,
    ) -> duckdb_value = ::std::mem::transmute(function_ptr);
    (fun)(type_, values, value_count)
}

static __DUCKDB_CREATE_ARRAY_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_array_value(
    type_: duckdb_logical_type,
    values: *mut duckdb_value,
    value_count: idx_t,
) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_ARRAY_VALUE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
        values: *mut duckdb_value,
        value_count: idx_t,
    ) -> duckdb_value = ::std::mem::transmute(function_ptr);
    (fun)(type_, values, value_count)
}

static __DUCKDB_GET_VARCHAR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_varchar(value: duckdb_value) -> *mut ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_GET_VARCHAR.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(value: duckdb_value) -> *mut ::std::os::raw::c_char = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(value)
}

static __DUCKDB_GET_INT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_int64(val: duckdb_value) -> i64 {
    let function_ptr = __DUCKDB_GET_INT64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> i64 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_CREATE_LOGICAL_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_logical_type(type_: duckdb_type) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_CREATE_LOGICAL_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_type) -> duckdb_logical_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_LOGICAL_TYPE_GET_ALIAS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_logical_type_get_alias(
    type_: duckdb_logical_type,
) -> *mut ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_LOGICAL_TYPE_GET_ALIAS
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
    ) -> *mut ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(type_)
}

static __DUCKDB_CREATE_LIST_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_list_type(
    type_: duckdb_logical_type,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_CREATE_LIST_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_CREATE_ARRAY_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_array_type(
    type_: duckdb_logical_type,
    array_size: idx_t,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_CREATE_ARRAY_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
        array_size: idx_t,
    ) -> duckdb_logical_type = ::std::mem::transmute(function_ptr);
    (fun)(type_, array_size)
}

static __DUCKDB_CREATE_MAP_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_map_type(
    key_type: duckdb_logical_type,
    value_type: duckdb_logical_type,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_CREATE_MAP_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        key_type: duckdb_logical_type,
        value_type: duckdb_logical_type,
    ) -> duckdb_logical_type = ::std::mem::transmute(function_ptr);
    (fun)(key_type, value_type)
}

static __DUCKDB_CREATE_UNION_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_union_type(
    member_types: *mut duckdb_logical_type,
    member_names: *mut *const ::std::os::raw::c_char,
    member_count: idx_t,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_CREATE_UNION_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        member_types: *mut duckdb_logical_type,
        member_names: *mut *const ::std::os::raw::c_char,
        member_count: idx_t,
    ) -> duckdb_logical_type = ::std::mem::transmute(function_ptr);
    (fun)(member_types, member_names, member_count)
}

static __DUCKDB_CREATE_STRUCT_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_struct_type(
    member_types: *mut duckdb_logical_type,
    member_names: *mut *const ::std::os::raw::c_char,
    member_count: idx_t,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_CREATE_STRUCT_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        member_types: *mut duckdb_logical_type,
        member_names: *mut *const ::std::os::raw::c_char,
        member_count: idx_t,
    ) -> duckdb_logical_type = ::std::mem::transmute(function_ptr);
    (fun)(member_types, member_names, member_count)
}

static __DUCKDB_CREATE_ENUM_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_enum_type(
    member_names: *mut *const ::std::os::raw::c_char,
    member_count: idx_t,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_CREATE_ENUM_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        member_names: *mut *const ::std::os::raw::c_char,
        member_count: idx_t,
    ) -> duckdb_logical_type = ::std::mem::transmute(function_ptr);
    (fun)(member_names, member_count)
}

static __DUCKDB_CREATE_DECIMAL_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_decimal_type(width: u8, scale: u8) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_CREATE_DECIMAL_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(width: u8, scale: u8) -> duckdb_logical_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(width, scale)
}

static __DUCKDB_GET_TYPE_ID: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_type_id(type_: duckdb_logical_type) -> duckdb_type {
    let function_ptr = __DUCKDB_GET_TYPE_ID.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_DECIMAL_WIDTH: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_decimal_width(type_: duckdb_logical_type) -> u8 {
    let function_ptr = __DUCKDB_DECIMAL_WIDTH
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> u8 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_DECIMAL_SCALE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_decimal_scale(type_: duckdb_logical_type) -> u8 {
    let function_ptr = __DUCKDB_DECIMAL_SCALE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> u8 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_DECIMAL_INTERNAL_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_decimal_internal_type(type_: duckdb_logical_type) -> duckdb_type {
    let function_ptr = __DUCKDB_DECIMAL_INTERNAL_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_ENUM_INTERNAL_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_enum_internal_type(type_: duckdb_logical_type) -> duckdb_type {
    let function_ptr = __DUCKDB_ENUM_INTERNAL_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_ENUM_DICTIONARY_SIZE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_enum_dictionary_size(type_: duckdb_logical_type) -> u32 {
    let function_ptr = __DUCKDB_ENUM_DICTIONARY_SIZE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> u32 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_ENUM_DICTIONARY_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_enum_dictionary_value(
    type_: duckdb_logical_type,
    index: idx_t,
) -> *mut ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_ENUM_DICTIONARY_VALUE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
        index: idx_t,
    ) -> *mut ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(type_, index)
}

static __DUCKDB_LIST_TYPE_CHILD_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_list_type_child_type(
    type_: duckdb_logical_type,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_LIST_TYPE_CHILD_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_ARRAY_TYPE_CHILD_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_array_type_child_type(
    type_: duckdb_logical_type,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_ARRAY_TYPE_CHILD_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_ARRAY_TYPE_ARRAY_SIZE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_array_type_array_size(type_: duckdb_logical_type) -> idx_t {
    let function_ptr = __DUCKDB_ARRAY_TYPE_ARRAY_SIZE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_MAP_TYPE_KEY_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_map_type_key_type(
    type_: duckdb_logical_type,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_MAP_TYPE_KEY_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_MAP_TYPE_VALUE_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_map_type_value_type(
    type_: duckdb_logical_type,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_MAP_TYPE_VALUE_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_STRUCT_TYPE_CHILD_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_struct_type_child_count(type_: duckdb_logical_type) -> idx_t {
    let function_ptr = __DUCKDB_STRUCT_TYPE_CHILD_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_STRUCT_TYPE_CHILD_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_struct_type_child_name(
    type_: duckdb_logical_type,
    index: idx_t,
) -> *mut ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_STRUCT_TYPE_CHILD_NAME
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
        index: idx_t,
    ) -> *mut ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(type_, index)
}

static __DUCKDB_STRUCT_TYPE_CHILD_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_struct_type_child_type(
    type_: duckdb_logical_type,
    index: idx_t,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_STRUCT_TYPE_CHILD_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
        index: idx_t,
    ) -> duckdb_logical_type = ::std::mem::transmute(function_ptr);
    (fun)(type_, index)
}

static __DUCKDB_UNION_TYPE_MEMBER_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_union_type_member_count(type_: duckdb_logical_type) -> idx_t {
    let function_ptr = __DUCKDB_UNION_TYPE_MEMBER_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_UNION_TYPE_MEMBER_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_union_type_member_name(
    type_: duckdb_logical_type,
    index: idx_t,
) -> *mut ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_UNION_TYPE_MEMBER_NAME
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
        index: idx_t,
    ) -> *mut ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(type_, index)
}

static __DUCKDB_UNION_TYPE_MEMBER_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_union_type_member_type(
    type_: duckdb_logical_type,
    index: idx_t,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_UNION_TYPE_MEMBER_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
        index: idx_t,
    ) -> duckdb_logical_type = ::std::mem::transmute(function_ptr);
    (fun)(type_, index)
}

static __DUCKDB_DESTROY_LOGICAL_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_logical_type(type_: *mut duckdb_logical_type) {
    let function_ptr = __DUCKDB_DESTROY_LOGICAL_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: *mut duckdb_logical_type) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_FETCH_CHUNK: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_fetch_chunk(result: duckdb_result) -> duckdb_data_chunk {
    let function_ptr = __DUCKDB_FETCH_CHUNK.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: duckdb_result) -> duckdb_data_chunk = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_CREATE_DATA_CHUNK: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_data_chunk(
    types: *mut duckdb_logical_type,
    column_count: idx_t,
) -> duckdb_data_chunk {
    let function_ptr = __DUCKDB_CREATE_DATA_CHUNK
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        types: *mut duckdb_logical_type,
        column_count: idx_t,
    ) -> duckdb_data_chunk = ::std::mem::transmute(function_ptr);
    (fun)(types, column_count)
}

static __DUCKDB_DESTROY_DATA_CHUNK: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_data_chunk(chunk: *mut duckdb_data_chunk) {
    let function_ptr = __DUCKDB_DESTROY_DATA_CHUNK
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(chunk: *mut duckdb_data_chunk) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(chunk)
}

static __DUCKDB_DATA_CHUNK_RESET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_data_chunk_reset(chunk: duckdb_data_chunk) {
    let function_ptr = __DUCKDB_DATA_CHUNK_RESET
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(chunk: duckdb_data_chunk) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(chunk)
}

static __DUCKDB_DATA_CHUNK_GET_COLUMN_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_data_chunk_get_column_count(chunk: duckdb_data_chunk) -> idx_t {
    let function_ptr = __DUCKDB_DATA_CHUNK_GET_COLUMN_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(chunk: duckdb_data_chunk) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(chunk)
}

static __DUCKDB_DATA_CHUNK_GET_VECTOR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_data_chunk_get_vector(
    chunk: duckdb_data_chunk,
    col_idx: idx_t,
) -> duckdb_vector {
    let function_ptr = __DUCKDB_DATA_CHUNK_GET_VECTOR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        chunk: duckdb_data_chunk,
        col_idx: idx_t,
    ) -> duckdb_vector = ::std::mem::transmute(function_ptr);
    (fun)(chunk, col_idx)
}

static __DUCKDB_DATA_CHUNK_GET_SIZE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_data_chunk_get_size(chunk: duckdb_data_chunk) -> idx_t {
    let function_ptr = __DUCKDB_DATA_CHUNK_GET_SIZE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(chunk: duckdb_data_chunk) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(chunk)
}

static __DUCKDB_DATA_CHUNK_SET_SIZE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_data_chunk_set_size(chunk: duckdb_data_chunk, size: idx_t) {
    let function_ptr = __DUCKDB_DATA_CHUNK_SET_SIZE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(chunk: duckdb_data_chunk, size: idx_t) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(chunk, size)
}

static __DUCKDB_VECTOR_GET_COLUMN_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_vector_get_column_type(
    vector: duckdb_vector,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_VECTOR_GET_COLUMN_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(vector: duckdb_vector) -> duckdb_logical_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(vector)
}

static __DUCKDB_VECTOR_GET_DATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_vector_get_data(
    vector: duckdb_vector,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_VECTOR_GET_DATA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        vector: duckdb_vector,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(vector)
}

static __DUCKDB_VECTOR_GET_VALIDITY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_vector_get_validity(vector: duckdb_vector) -> *mut u64 {
    let function_ptr = __DUCKDB_VECTOR_GET_VALIDITY
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(vector: duckdb_vector) -> *mut u64 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(vector)
}

static __DUCKDB_VECTOR_ENSURE_VALIDITY_WRITABLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_vector_ensure_validity_writable(vector: duckdb_vector) {
    let function_ptr = __DUCKDB_VECTOR_ENSURE_VALIDITY_WRITABLE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(vector: duckdb_vector) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(vector)
}

static __DUCKDB_VECTOR_ASSIGN_STRING_ELEMENT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_vector_assign_string_element(
    vector: duckdb_vector,
    index: idx_t,
    str_: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_VECTOR_ASSIGN_STRING_ELEMENT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        vector: duckdb_vector,
        index: idx_t,
        str_: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(vector, index, str_)
}

static __DUCKDB_VECTOR_ASSIGN_STRING_ELEMENT_LEN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_vector_assign_string_element_len(
    vector: duckdb_vector,
    index: idx_t,
    str_: *const ::std::os::raw::c_char,
    str_len: idx_t,
) {
    let function_ptr = __DUCKDB_VECTOR_ASSIGN_STRING_ELEMENT_LEN
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        vector: duckdb_vector,
        index: idx_t,
        str_: *const ::std::os::raw::c_char,
        str_len: idx_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(vector, index, str_, str_len)
}

static __DUCKDB_LIST_VECTOR_GET_CHILD: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_list_vector_get_child(vector: duckdb_vector) -> duckdb_vector {
    let function_ptr = __DUCKDB_LIST_VECTOR_GET_CHILD
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(vector: duckdb_vector) -> duckdb_vector = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(vector)
}

static __DUCKDB_LIST_VECTOR_GET_SIZE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_list_vector_get_size(vector: duckdb_vector) -> idx_t {
    let function_ptr = __DUCKDB_LIST_VECTOR_GET_SIZE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(vector: duckdb_vector) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(vector)
}

static __DUCKDB_LIST_VECTOR_SET_SIZE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_list_vector_set_size(
    vector: duckdb_vector,
    size: idx_t,
) -> duckdb_state {
    let function_ptr = __DUCKDB_LIST_VECTOR_SET_SIZE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(vector: duckdb_vector, size: idx_t) -> duckdb_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(vector, size)
}

static __DUCKDB_LIST_VECTOR_RESERVE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_list_vector_reserve(
    vector: duckdb_vector,
    required_capacity: idx_t,
) -> duckdb_state {
    let function_ptr = __DUCKDB_LIST_VECTOR_RESERVE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        vector: duckdb_vector,
        required_capacity: idx_t,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(vector, required_capacity)
}

static __DUCKDB_STRUCT_VECTOR_GET_CHILD: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_struct_vector_get_child(
    vector: duckdb_vector,
    index: idx_t,
) -> duckdb_vector {
    let function_ptr = __DUCKDB_STRUCT_VECTOR_GET_CHILD
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        vector: duckdb_vector,
        index: idx_t,
    ) -> duckdb_vector = ::std::mem::transmute(function_ptr);
    (fun)(vector, index)
}

static __DUCKDB_ARRAY_VECTOR_GET_CHILD: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_array_vector_get_child(vector: duckdb_vector) -> duckdb_vector {
    let function_ptr = __DUCKDB_ARRAY_VECTOR_GET_CHILD
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(vector: duckdb_vector) -> duckdb_vector = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(vector)
}

static __DUCKDB_VALIDITY_ROW_IS_VALID: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_validity_row_is_valid(validity: *mut u64, row: idx_t) -> bool {
    let function_ptr = __DUCKDB_VALIDITY_ROW_IS_VALID
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(validity: *mut u64, row: idx_t) -> bool = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(validity, row)
}

static __DUCKDB_VALIDITY_SET_ROW_VALIDITY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_validity_set_row_validity(
    validity: *mut u64,
    row: idx_t,
    valid: bool,
) {
    let function_ptr = __DUCKDB_VALIDITY_SET_ROW_VALIDITY
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(validity: *mut u64, row: idx_t, valid: bool) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(validity, row, valid)
}

static __DUCKDB_VALIDITY_SET_ROW_INVALID: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_validity_set_row_invalid(validity: *mut u64, row: idx_t) {
    let function_ptr = __DUCKDB_VALIDITY_SET_ROW_INVALID
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(validity: *mut u64, row: idx_t) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(validity, row)
}

static __DUCKDB_VALIDITY_SET_ROW_VALID: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_validity_set_row_valid(validity: *mut u64, row: idx_t) {
    let function_ptr = __DUCKDB_VALIDITY_SET_ROW_VALID
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(validity: *mut u64, row: idx_t) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(validity, row)
}

static __DUCKDB_CREATE_SCALAR_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_scalar_function() -> duckdb_scalar_function {
    let function_ptr = __DUCKDB_CREATE_SCALAR_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn() -> duckdb_scalar_function = ::std::mem::transmute(
        function_ptr,
    );
    (fun)()
}

static __DUCKDB_DESTROY_SCALAR_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_scalar_function(
    scalar_function: *mut duckdb_scalar_function,
) {
    let function_ptr = __DUCKDB_DESTROY_SCALAR_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(scalar_function: *mut duckdb_scalar_function) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(scalar_function)
}

static __DUCKDB_SCALAR_FUNCTION_SET_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_scalar_function_set_name(
    scalar_function: duckdb_scalar_function,
    name: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_SET_NAME
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        scalar_function: duckdb_scalar_function,
        name: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(scalar_function, name)
}

static __DUCKDB_SCALAR_FUNCTION_ADD_PARAMETER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_scalar_function_add_parameter(
    scalar_function: duckdb_scalar_function,
    type_: duckdb_logical_type,
) {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_ADD_PARAMETER
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        scalar_function: duckdb_scalar_function,
        type_: duckdb_logical_type,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(scalar_function, type_)
}

static __DUCKDB_SCALAR_FUNCTION_SET_RETURN_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_scalar_function_set_return_type(
    scalar_function: duckdb_scalar_function,
    type_: duckdb_logical_type,
) {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_SET_RETURN_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        scalar_function: duckdb_scalar_function,
        type_: duckdb_logical_type,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(scalar_function, type_)
}

static __DUCKDB_SCALAR_FUNCTION_SET_EXTRA_INFO: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_scalar_function_set_extra_info(
    scalar_function: duckdb_scalar_function,
    extra_info: *mut ::std::os::raw::c_void,
    destroy: duckdb_delete_callback_t,
) {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_SET_EXTRA_INFO
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        scalar_function: duckdb_scalar_function,
        extra_info: *mut ::std::os::raw::c_void,
        destroy: duckdb_delete_callback_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(scalar_function, extra_info, destroy)
}

static __DUCKDB_SCALAR_FUNCTION_SET_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_scalar_function_set_function(
    scalar_function: duckdb_scalar_function,
    function: duckdb_scalar_function_t,
) {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_SET_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        scalar_function: duckdb_scalar_function,
        function: duckdb_scalar_function_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(scalar_function, function)
}

static __DUCKDB_REGISTER_SCALAR_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_register_scalar_function(
    con: duckdb_connection,
    scalar_function: duckdb_scalar_function,
) -> duckdb_state {
    let function_ptr = __DUCKDB_REGISTER_SCALAR_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        con: duckdb_connection,
        scalar_function: duckdb_scalar_function,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(con, scalar_function)
}

static __DUCKDB_CREATE_TABLE_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_table_function() -> duckdb_table_function {
    let function_ptr = __DUCKDB_CREATE_TABLE_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn() -> duckdb_table_function = ::std::mem::transmute(
        function_ptr,
    );
    (fun)()
}

static __DUCKDB_DESTROY_TABLE_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_table_function(table_function: *mut duckdb_table_function) {
    let function_ptr = __DUCKDB_DESTROY_TABLE_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(table_function: *mut duckdb_table_function) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(table_function)
}

static __DUCKDB_TABLE_FUNCTION_SET_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_function_set_name(
    table_function: duckdb_table_function,
    name: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_TABLE_FUNCTION_SET_NAME
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_function: duckdb_table_function,
        name: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(table_function, name)
}

static __DUCKDB_TABLE_FUNCTION_ADD_PARAMETER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_function_add_parameter(
    table_function: duckdb_table_function,
    type_: duckdb_logical_type,
) {
    let function_ptr = __DUCKDB_TABLE_FUNCTION_ADD_PARAMETER
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_function: duckdb_table_function,
        type_: duckdb_logical_type,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(table_function, type_)
}

static __DUCKDB_TABLE_FUNCTION_ADD_NAMED_PARAMETER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_function_add_named_parameter(
    table_function: duckdb_table_function,
    name: *const ::std::os::raw::c_char,
    type_: duckdb_logical_type,
) {
    let function_ptr = __DUCKDB_TABLE_FUNCTION_ADD_NAMED_PARAMETER
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_function: duckdb_table_function,
        name: *const ::std::os::raw::c_char,
        type_: duckdb_logical_type,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(table_function, name, type_)
}

static __DUCKDB_TABLE_FUNCTION_SET_EXTRA_INFO: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_function_set_extra_info(
    table_function: duckdb_table_function,
    extra_info: *mut ::std::os::raw::c_void,
    destroy: duckdb_delete_callback_t,
) {
    let function_ptr = __DUCKDB_TABLE_FUNCTION_SET_EXTRA_INFO
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_function: duckdb_table_function,
        extra_info: *mut ::std::os::raw::c_void,
        destroy: duckdb_delete_callback_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(table_function, extra_info, destroy)
}

static __DUCKDB_TABLE_FUNCTION_SET_BIND: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_function_set_bind(
    table_function: duckdb_table_function,
    bind: duckdb_table_function_bind_t,
) {
    let function_ptr = __DUCKDB_TABLE_FUNCTION_SET_BIND
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_function: duckdb_table_function,
        bind: duckdb_table_function_bind_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(table_function, bind)
}

static __DUCKDB_TABLE_FUNCTION_SET_INIT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_function_set_init(
    table_function: duckdb_table_function,
    init: duckdb_table_function_init_t,
) {
    let function_ptr = __DUCKDB_TABLE_FUNCTION_SET_INIT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_function: duckdb_table_function,
        init: duckdb_table_function_init_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(table_function, init)
}

static __DUCKDB_TABLE_FUNCTION_SET_LOCAL_INIT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_function_set_local_init(
    table_function: duckdb_table_function,
    init: duckdb_table_function_init_t,
) {
    let function_ptr = __DUCKDB_TABLE_FUNCTION_SET_LOCAL_INIT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_function: duckdb_table_function,
        init: duckdb_table_function_init_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(table_function, init)
}

static __DUCKDB_TABLE_FUNCTION_SET_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_function_set_function(
    table_function: duckdb_table_function,
    function: duckdb_table_function_t,
) {
    let function_ptr = __DUCKDB_TABLE_FUNCTION_SET_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_function: duckdb_table_function,
        function: duckdb_table_function_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(table_function, function)
}

static __DUCKDB_TABLE_FUNCTION_SUPPORTS_PROJECTION_PUSHDOWN: ::std::sync::atomic::AtomicPtr<
    (),
> = ::std::sync::atomic::AtomicPtr::new(::std::ptr::null_mut());
pub unsafe fn duckdb_table_function_supports_projection_pushdown(
    table_function: duckdb_table_function,
    pushdown: bool,
) {
    let function_ptr = __DUCKDB_TABLE_FUNCTION_SUPPORTS_PROJECTION_PUSHDOWN
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_function: duckdb_table_function,
        pushdown: bool,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(table_function, pushdown)
}

static __DUCKDB_REGISTER_TABLE_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_register_table_function(
    con: duckdb_connection,
    function: duckdb_table_function,
) -> duckdb_state {
    let function_ptr = __DUCKDB_REGISTER_TABLE_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        con: duckdb_connection,
        function: duckdb_table_function,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(con, function)
}

static __DUCKDB_BIND_GET_EXTRA_INFO: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_get_extra_info(
    info: duckdb_bind_info,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_BIND_GET_EXTRA_INFO
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_bind_info,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_BIND_ADD_RESULT_COLUMN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_add_result_column(
    info: duckdb_bind_info,
    name: *const ::std::os::raw::c_char,
    type_: duckdb_logical_type,
) {
    let function_ptr = __DUCKDB_BIND_ADD_RESULT_COLUMN
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_bind_info,
        name: *const ::std::os::raw::c_char,
        type_: duckdb_logical_type,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, name, type_)
}

static __DUCKDB_BIND_GET_PARAMETER_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_get_parameter_count(info: duckdb_bind_info) -> idx_t {
    let function_ptr = __DUCKDB_BIND_GET_PARAMETER_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(info: duckdb_bind_info) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(info)
}

static __DUCKDB_BIND_GET_PARAMETER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_get_parameter(
    info: duckdb_bind_info,
    index: idx_t,
) -> duckdb_value {
    let function_ptr = __DUCKDB_BIND_GET_PARAMETER
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_bind_info,
        index: idx_t,
    ) -> duckdb_value = ::std::mem::transmute(function_ptr);
    (fun)(info, index)
}

static __DUCKDB_BIND_GET_NAMED_PARAMETER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_get_named_parameter(
    info: duckdb_bind_info,
    name: *const ::std::os::raw::c_char,
) -> duckdb_value {
    let function_ptr = __DUCKDB_BIND_GET_NAMED_PARAMETER
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_bind_info,
        name: *const ::std::os::raw::c_char,
    ) -> duckdb_value = ::std::mem::transmute(function_ptr);
    (fun)(info, name)
}

static __DUCKDB_BIND_SET_BIND_DATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_set_bind_data(
    info: duckdb_bind_info,
    bind_data: *mut ::std::os::raw::c_void,
    destroy: duckdb_delete_callback_t,
) {
    let function_ptr = __DUCKDB_BIND_SET_BIND_DATA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_bind_info,
        bind_data: *mut ::std::os::raw::c_void,
        destroy: duckdb_delete_callback_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, bind_data, destroy)
}

static __DUCKDB_BIND_SET_CARDINALITY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_set_cardinality(
    info: duckdb_bind_info,
    cardinality: idx_t,
    is_exact: bool,
) {
    let function_ptr = __DUCKDB_BIND_SET_CARDINALITY
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_bind_info,
        cardinality: idx_t,
        is_exact: bool,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, cardinality, is_exact)
}

static __DUCKDB_BIND_SET_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_set_error(
    info: duckdb_bind_info,
    error: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_BIND_SET_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_bind_info,
        error: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, error)
}

static __DUCKDB_INIT_GET_EXTRA_INFO: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_init_get_extra_info(
    info: duckdb_init_info,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_INIT_GET_EXTRA_INFO
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_init_info,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_INIT_GET_BIND_DATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_init_get_bind_data(
    info: duckdb_init_info,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_INIT_GET_BIND_DATA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_init_info,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_INIT_SET_INIT_DATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_init_set_init_data(
    info: duckdb_init_info,
    init_data: *mut ::std::os::raw::c_void,
    destroy: duckdb_delete_callback_t,
) {
    let function_ptr = __DUCKDB_INIT_SET_INIT_DATA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_init_info,
        init_data: *mut ::std::os::raw::c_void,
        destroy: duckdb_delete_callback_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, init_data, destroy)
}

static __DUCKDB_INIT_GET_COLUMN_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_init_get_column_count(info: duckdb_init_info) -> idx_t {
    let function_ptr = __DUCKDB_INIT_GET_COLUMN_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(info: duckdb_init_info) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(info)
}

static __DUCKDB_INIT_GET_COLUMN_INDEX: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_init_get_column_index(
    info: duckdb_init_info,
    column_index: idx_t,
) -> idx_t {
    let function_ptr = __DUCKDB_INIT_GET_COLUMN_INDEX
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_init_info,
        column_index: idx_t,
    ) -> idx_t = ::std::mem::transmute(function_ptr);
    (fun)(info, column_index)
}

static __DUCKDB_INIT_SET_MAX_THREADS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_init_set_max_threads(info: duckdb_init_info, max_threads: idx_t) {
    let function_ptr = __DUCKDB_INIT_SET_MAX_THREADS
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(info: duckdb_init_info, max_threads: idx_t) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(info, max_threads)
}

static __DUCKDB_INIT_SET_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_init_set_error(
    info: duckdb_init_info,
    error: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_INIT_SET_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_init_info,
        error: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, error)
}

static __DUCKDB_FUNCTION_GET_EXTRA_INFO: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_function_get_extra_info(
    info: duckdb_function_info,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_FUNCTION_GET_EXTRA_INFO
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_function_info,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_FUNCTION_GET_BIND_DATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_function_get_bind_data(
    info: duckdb_function_info,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_FUNCTION_GET_BIND_DATA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_function_info,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_FUNCTION_GET_INIT_DATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_function_get_init_data(
    info: duckdb_function_info,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_FUNCTION_GET_INIT_DATA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_function_info,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_FUNCTION_GET_LOCAL_INIT_DATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_function_get_local_init_data(
    info: duckdb_function_info,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_FUNCTION_GET_LOCAL_INIT_DATA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_function_info,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_FUNCTION_SET_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_function_set_error(
    info: duckdb_function_info,
    error: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_FUNCTION_SET_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_function_info,
        error: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, error)
}

static __DUCKDB_ADD_REPLACEMENT_SCAN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_add_replacement_scan(
    db: duckdb_database,
    replacement: duckdb_replacement_callback_t,
    extra_data: *mut ::std::os::raw::c_void,
    delete_callback: duckdb_delete_callback_t,
) {
    let function_ptr = __DUCKDB_ADD_REPLACEMENT_SCAN
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        db: duckdb_database,
        replacement: duckdb_replacement_callback_t,
        extra_data: *mut ::std::os::raw::c_void,
        delete_callback: duckdb_delete_callback_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(db, replacement, extra_data, delete_callback)
}

static __DUCKDB_REPLACEMENT_SCAN_SET_FUNCTION_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_replacement_scan_set_function_name(
    info: duckdb_replacement_scan_info,
    function_name: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_REPLACEMENT_SCAN_SET_FUNCTION_NAME
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_replacement_scan_info,
        function_name: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, function_name)
}

static __DUCKDB_REPLACEMENT_SCAN_ADD_PARAMETER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_replacement_scan_add_parameter(
    info: duckdb_replacement_scan_info,
    parameter: duckdb_value,
) {
    let function_ptr = __DUCKDB_REPLACEMENT_SCAN_ADD_PARAMETER
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_replacement_scan_info,
        parameter: duckdb_value,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, parameter)
}

static __DUCKDB_REPLACEMENT_SCAN_SET_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_replacement_scan_set_error(
    info: duckdb_replacement_scan_info,
    error: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_REPLACEMENT_SCAN_SET_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_replacement_scan_info,
        error: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, error)
}

static __DUCKDB_APPENDER_CREATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_appender_create(
    connection: duckdb_connection,
    schema: *const ::std::os::raw::c_char,
    table: *const ::std::os::raw::c_char,
    out_appender: *mut duckdb_appender,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPENDER_CREATE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        connection: duckdb_connection,
        schema: *const ::std::os::raw::c_char,
        table: *const ::std::os::raw::c_char,
        out_appender: *mut duckdb_appender,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(connection, schema, table, out_appender)
}

static __DUCKDB_APPENDER_COLUMN_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_appender_column_count(appender: duckdb_appender) -> idx_t {
    let function_ptr = __DUCKDB_APPENDER_COLUMN_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(appender: duckdb_appender) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(appender)
}

static __DUCKDB_APPENDER_COLUMN_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_appender_column_type(
    appender: duckdb_appender,
    col_idx: idx_t,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_APPENDER_COLUMN_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        col_idx: idx_t,
    ) -> duckdb_logical_type = ::std::mem::transmute(function_ptr);
    (fun)(appender, col_idx)
}

static __DUCKDB_APPENDER_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_appender_error(
    appender: duckdb_appender,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_APPENDER_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(appender)
}

static __DUCKDB_APPENDER_FLUSH: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_appender_flush(appender: duckdb_appender) -> duckdb_state {
    let function_ptr = __DUCKDB_APPENDER_FLUSH
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(appender)
}

static __DUCKDB_APPENDER_CLOSE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_appender_close(appender: duckdb_appender) -> duckdb_state {
    let function_ptr = __DUCKDB_APPENDER_CLOSE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(appender)
}

static __DUCKDB_APPENDER_DESTROY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_appender_destroy(appender: *mut duckdb_appender) -> duckdb_state {
    let function_ptr = __DUCKDB_APPENDER_DESTROY
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(appender: *mut duckdb_appender) -> duckdb_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(appender)
}

static __DUCKDB_APPENDER_BEGIN_ROW: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_appender_begin_row(appender: duckdb_appender) -> duckdb_state {
    let function_ptr = __DUCKDB_APPENDER_BEGIN_ROW
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(appender)
}

static __DUCKDB_APPENDER_END_ROW: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_appender_end_row(appender: duckdb_appender) -> duckdb_state {
    let function_ptr = __DUCKDB_APPENDER_END_ROW
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(appender)
}

static __DUCKDB_APPEND_DEFAULT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_default(appender: duckdb_appender) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_DEFAULT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(appender)
}

static __DUCKDB_APPEND_BOOL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_bool(
    appender: duckdb_appender,
    value: bool,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_BOOL.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: bool,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_INT8: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_int8(appender: duckdb_appender, value: i8) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_INT8.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: i8,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_INT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_int16(
    appender: duckdb_appender,
    value: i16,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_INT16
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: i16,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_INT32: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_int32(
    appender: duckdb_appender,
    value: i32,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_INT32
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: i32,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_INT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_int64(
    appender: duckdb_appender,
    value: i64,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_INT64
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: i64,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_HUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_hugeint(
    appender: duckdb_appender,
    value: duckdb_hugeint,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_HUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: duckdb_hugeint,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_UINT8: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_uint8(appender: duckdb_appender, value: u8) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_UINT8
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: u8,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_UINT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_uint16(
    appender: duckdb_appender,
    value: u16,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_UINT16
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: u16,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_UINT32: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_uint32(
    appender: duckdb_appender,
    value: u32,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_UINT32
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: u32,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_UINT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_uint64(
    appender: duckdb_appender,
    value: u64,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_UINT64
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: u64,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_UHUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_uhugeint(
    appender: duckdb_appender,
    value: duckdb_uhugeint,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_UHUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: duckdb_uhugeint,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_FLOAT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_float(
    appender: duckdb_appender,
    value: f32,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_FLOAT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: f32,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_DOUBLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_double(
    appender: duckdb_appender,
    value: f64,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_DOUBLE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: f64,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_DATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_date(
    appender: duckdb_appender,
    value: duckdb_date,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_DATE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: duckdb_date,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_TIME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_time(
    appender: duckdb_appender,
    value: duckdb_time,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_TIME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: duckdb_time,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_TIMESTAMP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_timestamp(
    appender: duckdb_appender,
    value: duckdb_timestamp,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_TIMESTAMP
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: duckdb_timestamp,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_INTERVAL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_interval(
    appender: duckdb_appender,
    value: duckdb_interval,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_INTERVAL
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: duckdb_interval,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_VARCHAR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_varchar(
    appender: duckdb_appender,
    val: *const ::std::os::raw::c_char,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_VARCHAR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        val: *const ::std::os::raw::c_char,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, val)
}

static __DUCKDB_APPEND_VARCHAR_LENGTH: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_varchar_length(
    appender: duckdb_appender,
    val: *const ::std::os::raw::c_char,
    length: idx_t,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_VARCHAR_LENGTH
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        val: *const ::std::os::raw::c_char,
        length: idx_t,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, val, length)
}

static __DUCKDB_APPEND_BLOB: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_blob(
    appender: duckdb_appender,
    data: *const ::std::os::raw::c_void,
    length: idx_t,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_BLOB.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        data: *const ::std::os::raw::c_void,
        length: idx_t,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, data, length)
}

static __DUCKDB_APPEND_NULL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_null(appender: duckdb_appender) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_NULL.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(appender)
}

static __DUCKDB_APPEND_DATA_CHUNK: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_data_chunk(
    appender: duckdb_appender,
    chunk: duckdb_data_chunk,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_DATA_CHUNK
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        chunk: duckdb_data_chunk,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, chunk)
}

static __DUCKDB_EXECUTE_TASKS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_execute_tasks(database: duckdb_database, max_tasks: idx_t) {
    let function_ptr = __DUCKDB_EXECUTE_TASKS
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(database: duckdb_database, max_tasks: idx_t) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(database, max_tasks)
}

static __DUCKDB_CREATE_TASK_STATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_task_state(database: duckdb_database) -> duckdb_task_state {
    let function_ptr = __DUCKDB_CREATE_TASK_STATE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(database: duckdb_database) -> duckdb_task_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(database)
}

static __DUCKDB_EXECUTE_TASKS_STATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_execute_tasks_state(state: duckdb_task_state) {
    let function_ptr = __DUCKDB_EXECUTE_TASKS_STATE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(state: duckdb_task_state) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(state)
}

static __DUCKDB_EXECUTE_N_TASKS_STATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_execute_n_tasks_state(
    state: duckdb_task_state,
    max_tasks: idx_t,
) -> idx_t {
    let function_ptr = __DUCKDB_EXECUTE_N_TASKS_STATE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(state: duckdb_task_state, max_tasks: idx_t) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(state, max_tasks)
}

static __DUCKDB_FINISH_EXECUTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_finish_execution(state: duckdb_task_state) {
    let function_ptr = __DUCKDB_FINISH_EXECUTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(state: duckdb_task_state) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(state)
}

static __DUCKDB_TASK_STATE_IS_FINISHED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_task_state_is_finished(state: duckdb_task_state) -> bool {
    let function_ptr = __DUCKDB_TASK_STATE_IS_FINISHED
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(state: duckdb_task_state) -> bool = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(state)
}

static __DUCKDB_DESTROY_TASK_STATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_task_state(state: duckdb_task_state) {
    let function_ptr = __DUCKDB_DESTROY_TASK_STATE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(state: duckdb_task_state) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(state)
}

static __DUCKDB_EXECUTION_IS_FINISHED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_execution_is_finished(con: duckdb_connection) -> bool {
    let function_ptr = __DUCKDB_EXECUTION_IS_FINISHED
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(con: duckdb_connection) -> bool = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(con)
}

static __DUCKDB_GET_PROFILING_INFO: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_profiling_info(
    connection: duckdb_connection,
) -> duckdb_profiling_info {
    let function_ptr = __DUCKDB_GET_PROFILING_INFO
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        connection: duckdb_connection,
    ) -> duckdb_profiling_info = ::std::mem::transmute(function_ptr);
    (fun)(connection)
}

static __DUCKDB_PROFILING_INFO_GET_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_profiling_info_get_value(
    info: duckdb_profiling_info,
    key: *const ::std::os::raw::c_char,
) -> duckdb_value {
    let function_ptr = __DUCKDB_PROFILING_INFO_GET_VALUE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_profiling_info,
        key: *const ::std::os::raw::c_char,
    ) -> duckdb_value = ::std::mem::transmute(function_ptr);
    (fun)(info, key)
}

static __DUCKDB_PROFILING_INFO_GET_CHILD_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_profiling_info_get_child_count(
    info: duckdb_profiling_info,
) -> idx_t {
    let function_ptr = __DUCKDB_PROFILING_INFO_GET_CHILD_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(info: duckdb_profiling_info) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(info)
}

static __DUCKDB_PROFILING_INFO_GET_CHILD: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_profiling_info_get_child(
    info: duckdb_profiling_info,
    index: idx_t,
) -> duckdb_profiling_info {
    let function_ptr = __DUCKDB_PROFILING_INFO_GET_CHILD
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_profiling_info,
        index: idx_t,
    ) -> duckdb_profiling_info = ::std::mem::transmute(function_ptr);
    (fun)(info, index)
}

static __DUCKDB_PROFILING_INFO_GET_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_profiling_info_get_name(
    info: duckdb_profiling_info,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_PROFILING_INFO_GET_NAME
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_profiling_info,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_PROFILING_INFO_GET_QUERY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_profiling_info_get_query(
    info: duckdb_profiling_info,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_PROFILING_INFO_GET_QUERY
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_profiling_info,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_SCALAR_FUNCTION_SET_VARARGS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_scalar_function_set_varargs(
    scalar_function: duckdb_scalar_function,
    type_: duckdb_logical_type,
) {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_SET_VARARGS
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        scalar_function: duckdb_scalar_function,
        type_: duckdb_logical_type,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(scalar_function, type_)
}

static __DUCKDB_SCALAR_FUNCTION_SET_SPECIAL_HANDLING: ::std::sync::atomic::AtomicPtr<
    (),
> = ::std::sync::atomic::AtomicPtr::new(::std::ptr::null_mut());
pub unsafe fn duckdb_scalar_function_set_special_handling(
    scalar_function: duckdb_scalar_function,
) {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_SET_SPECIAL_HANDLING
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(scalar_function: duckdb_scalar_function) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(scalar_function)
}

static __DUCKDB_SCALAR_FUNCTION_SET_VOLATILE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_scalar_function_set_volatile(
    scalar_function: duckdb_scalar_function,
) {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_SET_VOLATILE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(scalar_function: duckdb_scalar_function) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(scalar_function)
}

static __DUCKDB_SCALAR_FUNCTION_GET_EXTRA_INFO: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_scalar_function_get_extra_info(
    info: duckdb_function_info,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_GET_EXTRA_INFO
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_function_info,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_SCALAR_FUNCTION_SET_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_scalar_function_set_error(
    info: duckdb_function_info,
    error: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_SET_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_function_info,
        error: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, error)
}

static __DUCKDB_TABLE_DESCRIPTION_CREATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_description_create(
    connection: duckdb_connection,
    schema: *const ::std::os::raw::c_char,
    table: *const ::std::os::raw::c_char,
    out: *mut duckdb_table_description,
) -> duckdb_state {
    let function_ptr = __DUCKDB_TABLE_DESCRIPTION_CREATE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        connection: duckdb_connection,
        schema: *const ::std::os::raw::c_char,
        table: *const ::std::os::raw::c_char,
        out: *mut duckdb_table_description,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(connection, schema, table, out)
}

static __DUCKDB_TABLE_DESCRIPTION_DESTROY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_description_destroy(
    table_description: *mut duckdb_table_description,
) {
    let function_ptr = __DUCKDB_TABLE_DESCRIPTION_DESTROY
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(table_description: *mut duckdb_table_description) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(table_description)
}

static __DUCKDB_TABLE_DESCRIPTION_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_description_error(
    table_description: duckdb_table_description,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_TABLE_DESCRIPTION_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_description: duckdb_table_description,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(table_description)
}

static __DUCKDB_RESULT_ERROR_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_result_error_type(result: *mut duckdb_result) -> duckdb_error_type {
    let function_ptr = __DUCKDB_RESULT_ERROR_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: *mut duckdb_result) -> duckdb_error_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_STRING_T_LENGTH: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_string_t_length(string: duckdb_string_t) -> u32 {
    let function_ptr = __DUCKDB_STRING_T_LENGTH
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(string: duckdb_string_t) -> u32 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(string)
}

static __DUCKDB_STRING_T_DATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_string_t_data(
    string: *mut duckdb_string_t,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_STRING_T_DATA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        string: *mut duckdb_string_t,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(string)
}

static __DUCKDB_CREATE_BOOL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_bool(input: bool) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_BOOL.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: bool) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_INT8: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_int8(input: i8) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_INT8.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: i8) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_UINT8: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_uint8(input: u8) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_UINT8
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: u8) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_INT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_int16(input: i16) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_INT16
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: i16) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_UINT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_uint16(input: u16) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_UINT16
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: u16) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_INT32: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_int32(input: i32) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_INT32
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: i32) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_UINT32: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_uint32(input: u32) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_UINT32
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: u32) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_UINT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_uint64(input: u64) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_UINT64
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: u64) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_HUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_hugeint(input: duckdb_hugeint) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_HUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: duckdb_hugeint) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_UHUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_uhugeint(input: duckdb_uhugeint) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_UHUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: duckdb_uhugeint) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_FLOAT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_float(input: f32) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_FLOAT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: f32) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_DOUBLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_double(input: f64) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_DOUBLE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: f64) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_DATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_date(input: duckdb_date) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_DATE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: duckdb_date) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_TIME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_time(input: duckdb_time) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_TIME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: duckdb_time) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_TIME_TZ_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_time_tz_value(value: duckdb_time_tz) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_TIME_TZ_VALUE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(value: duckdb_time_tz) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(value)
}

static __DUCKDB_CREATE_TIMESTAMP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_timestamp(input: duckdb_timestamp) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_TIMESTAMP
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: duckdb_timestamp) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_INTERVAL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_interval(input: duckdb_interval) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_INTERVAL
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: duckdb_interval) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_BLOB: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_blob(data: *const u8, length: idx_t) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_BLOB.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(data: *const u8, length: idx_t) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(data, length)
}

static __DUCKDB_GET_BOOL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_bool(val: duckdb_value) -> bool {
    let function_ptr = __DUCKDB_GET_BOOL.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> bool = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_INT8: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_int8(val: duckdb_value) -> i8 {
    let function_ptr = __DUCKDB_GET_INT8.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> i8 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_UINT8: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_uint8(val: duckdb_value) -> u8 {
    let function_ptr = __DUCKDB_GET_UINT8.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> u8 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_INT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_int16(val: duckdb_value) -> i16 {
    let function_ptr = __DUCKDB_GET_INT16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> i16 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_UINT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_uint16(val: duckdb_value) -> u16 {
    let function_ptr = __DUCKDB_GET_UINT16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> u16 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_INT32: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_int32(val: duckdb_value) -> i32 {
    let function_ptr = __DUCKDB_GET_INT32.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> i32 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_UINT32: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_uint32(val: duckdb_value) -> u32 {
    let function_ptr = __DUCKDB_GET_UINT32.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> u32 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_UINT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_uint64(val: duckdb_value) -> u64 {
    let function_ptr = __DUCKDB_GET_UINT64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> u64 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_HUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_hugeint(val: duckdb_value) -> duckdb_hugeint {
    let function_ptr = __DUCKDB_GET_HUGEINT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> duckdb_hugeint = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_UHUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_uhugeint(val: duckdb_value) -> duckdb_uhugeint {
    let function_ptr = __DUCKDB_GET_UHUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> duckdb_uhugeint = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_FLOAT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_float(val: duckdb_value) -> f32 {
    let function_ptr = __DUCKDB_GET_FLOAT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> f32 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_DOUBLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_double(val: duckdb_value) -> f64 {
    let function_ptr = __DUCKDB_GET_DOUBLE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> f64 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_DATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_date(val: duckdb_value) -> duckdb_date {
    let function_ptr = __DUCKDB_GET_DATE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> duckdb_date = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_TIME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_time(val: duckdb_value) -> duckdb_time {
    let function_ptr = __DUCKDB_GET_TIME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> duckdb_time = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_TIME_TZ: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_time_tz(val: duckdb_value) -> duckdb_time_tz {
    let function_ptr = __DUCKDB_GET_TIME_TZ.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> duckdb_time_tz = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_TIMESTAMP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_timestamp(val: duckdb_value) -> duckdb_timestamp {
    let function_ptr = __DUCKDB_GET_TIMESTAMP
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> duckdb_timestamp = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_INTERVAL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_interval(val: duckdb_value) -> duckdb_interval {
    let function_ptr = __DUCKDB_GET_INTERVAL
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> duckdb_interval = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_VALUE_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_value_type(val: duckdb_value) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_GET_VALUE_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> duckdb_logical_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_BLOB: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_blob(val: duckdb_value) -> duckdb_blob {
    let function_ptr = __DUCKDB_GET_BLOB.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> duckdb_blob = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_CREATE_SCALAR_FUNCTION_SET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_scalar_function_set(
    name: *const ::std::os::raw::c_char,
) -> duckdb_scalar_function_set {
    let function_ptr = __DUCKDB_CREATE_SCALAR_FUNCTION_SET
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
    ) -> duckdb_scalar_function_set = ::std::mem::transmute(function_ptr);
    (fun)(name)
}

static __DUCKDB_DESTROY_SCALAR_FUNCTION_SET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_scalar_function_set(
    scalar_function_set: *mut duckdb_scalar_function_set,
) {
    let function_ptr = __DUCKDB_DESTROY_SCALAR_FUNCTION_SET
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        scalar_function_set: *mut duckdb_scalar_function_set,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(scalar_function_set)
}

static __DUCKDB_ADD_SCALAR_FUNCTION_TO_SET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_add_scalar_function_to_set(
    set: duckdb_scalar_function_set,
    function: duckdb_scalar_function,
) -> duckdb_state {
    let function_ptr = __DUCKDB_ADD_SCALAR_FUNCTION_TO_SET
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        set: duckdb_scalar_function_set,
        function: duckdb_scalar_function,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(set, function)
}

static __DUCKDB_REGISTER_SCALAR_FUNCTION_SET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_register_scalar_function_set(
    con: duckdb_connection,
    set: duckdb_scalar_function_set,
) -> duckdb_state {
    let function_ptr = __DUCKDB_REGISTER_SCALAR_FUNCTION_SET
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        con: duckdb_connection,
        set: duckdb_scalar_function_set,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(con, set)
}

static __DUCKDB_CREATE_AGGREGATE_FUNCTION_SET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_aggregate_function_set(
    name: *const ::std::os::raw::c_char,
) -> duckdb_aggregate_function_set {
    let function_ptr = __DUCKDB_CREATE_AGGREGATE_FUNCTION_SET
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
    ) -> duckdb_aggregate_function_set = ::std::mem::transmute(function_ptr);
    (fun)(name)
}

static __DUCKDB_DESTROY_AGGREGATE_FUNCTION_SET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_aggregate_function_set(
    aggregate_function_set: *mut duckdb_aggregate_function_set,
) {
    let function_ptr = __DUCKDB_DESTROY_AGGREGATE_FUNCTION_SET
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        aggregate_function_set: *mut duckdb_aggregate_function_set,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(aggregate_function_set)
}

static __DUCKDB_ADD_AGGREGATE_FUNCTION_TO_SET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_add_aggregate_function_to_set(
    set: duckdb_aggregate_function_set,
    function: duckdb_aggregate_function,
) -> duckdb_state {
    let function_ptr = __DUCKDB_ADD_AGGREGATE_FUNCTION_TO_SET
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        set: duckdb_aggregate_function_set,
        function: duckdb_aggregate_function,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(set, function)
}

static __DUCKDB_REGISTER_AGGREGATE_FUNCTION_SET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_register_aggregate_function_set(
    con: duckdb_connection,
    set: duckdb_aggregate_function_set,
) -> duckdb_state {
    let function_ptr = __DUCKDB_REGISTER_AGGREGATE_FUNCTION_SET
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        con: duckdb_connection,
        set: duckdb_aggregate_function_set,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(con, set)
}

/// Like DUCKDB_EXTENSION_API_INIT macro
pub unsafe fn duckdb_rs_extension_api_init(
    info: duckdb_extension_info,
    access: duckdb_extension_access,
) -> ::std::result::Result<(), &'static str> {
    let p_api = access.get_api.unwrap()(info, c"v0.0.2".as_ptr())
        as *const duckdb_ext_api_v0;
    if p_api.is_null() {
        return Err(
            "DuckDB passed a nullpointer while trying to initialize the extension",
        );
    }
    if let Some(fun) = (*p_api).duckdb_open {
        __DUCKDB_OPEN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_open_ext {
        __DUCKDB_OPEN_EXT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_close {
        __DUCKDB_CLOSE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_connect {
        __DUCKDB_CONNECT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_interrupt {
        __DUCKDB_INTERRUPT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_query_progress {
        __DUCKDB_QUERY_PROGRESS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_disconnect {
        __DUCKDB_DISCONNECT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_library_version {
        __DUCKDB_LIBRARY_VERSION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_config {
        __DUCKDB_CREATE_CONFIG
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_config_count {
        __DUCKDB_CONFIG_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_config_flag {
        __DUCKDB_GET_CONFIG_FLAG
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_set_config {
        __DUCKDB_SET_CONFIG
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_config {
        __DUCKDB_DESTROY_CONFIG
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_query {
        __DUCKDB_QUERY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_result {
        __DUCKDB_DESTROY_RESULT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_column_name {
        __DUCKDB_COLUMN_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_column_type {
        __DUCKDB_COLUMN_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_result_statement_type {
        __DUCKDB_RESULT_STATEMENT_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_column_logical_type {
        __DUCKDB_COLUMN_LOGICAL_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_column_count {
        __DUCKDB_COLUMN_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_rows_changed {
        __DUCKDB_ROWS_CHANGED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_result_error {
        __DUCKDB_RESULT_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_malloc {
        __DUCKDB_MALLOC
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_free {
        __DUCKDB_FREE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_vector_size {
        __DUCKDB_VECTOR_SIZE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_string_is_inlined {
        __DUCKDB_STRING_IS_INLINED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_from_date {
        __DUCKDB_FROM_DATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_to_date {
        __DUCKDB_TO_DATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_is_finite_date {
        __DUCKDB_IS_FINITE_DATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_from_time {
        __DUCKDB_FROM_TIME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_time_tz {
        __DUCKDB_CREATE_TIME_TZ
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_from_time_tz {
        __DUCKDB_FROM_TIME_TZ
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_to_time {
        __DUCKDB_TO_TIME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_from_timestamp {
        __DUCKDB_FROM_TIMESTAMP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_to_timestamp {
        __DUCKDB_TO_TIMESTAMP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_is_finite_timestamp {
        __DUCKDB_IS_FINITE_TIMESTAMP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_hugeint_to_double {
        __DUCKDB_HUGEINT_TO_DOUBLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_double_to_hugeint {
        __DUCKDB_DOUBLE_TO_HUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_uhugeint_to_double {
        __DUCKDB_UHUGEINT_TO_DOUBLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_double_to_uhugeint {
        __DUCKDB_DOUBLE_TO_UHUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_double_to_decimal {
        __DUCKDB_DOUBLE_TO_DECIMAL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_decimal_to_double {
        __DUCKDB_DECIMAL_TO_DOUBLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_prepare {
        __DUCKDB_PREPARE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_prepare {
        __DUCKDB_DESTROY_PREPARE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_prepare_error {
        __DUCKDB_PREPARE_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_nparams {
        __DUCKDB_NPARAMS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_parameter_name {
        __DUCKDB_PARAMETER_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_param_type {
        __DUCKDB_PARAM_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_clear_bindings {
        __DUCKDB_CLEAR_BINDINGS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_prepared_statement_type {
        __DUCKDB_PREPARED_STATEMENT_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_value {
        __DUCKDB_BIND_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_parameter_index {
        __DUCKDB_BIND_PARAMETER_INDEX
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_boolean {
        __DUCKDB_BIND_BOOLEAN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_int8 {
        __DUCKDB_BIND_INT8
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_int16 {
        __DUCKDB_BIND_INT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_int32 {
        __DUCKDB_BIND_INT32
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_int64 {
        __DUCKDB_BIND_INT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_hugeint {
        __DUCKDB_BIND_HUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_uhugeint {
        __DUCKDB_BIND_UHUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_decimal {
        __DUCKDB_BIND_DECIMAL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_uint8 {
        __DUCKDB_BIND_UINT8
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_uint16 {
        __DUCKDB_BIND_UINT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_uint32 {
        __DUCKDB_BIND_UINT32
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_uint64 {
        __DUCKDB_BIND_UINT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_float {
        __DUCKDB_BIND_FLOAT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_double {
        __DUCKDB_BIND_DOUBLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_date {
        __DUCKDB_BIND_DATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_time {
        __DUCKDB_BIND_TIME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_timestamp {
        __DUCKDB_BIND_TIMESTAMP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_timestamp_tz {
        __DUCKDB_BIND_TIMESTAMP_TZ
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_interval {
        __DUCKDB_BIND_INTERVAL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_varchar {
        __DUCKDB_BIND_VARCHAR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_varchar_length {
        __DUCKDB_BIND_VARCHAR_LENGTH
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_blob {
        __DUCKDB_BIND_BLOB
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_null {
        __DUCKDB_BIND_NULL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_execute_prepared {
        __DUCKDB_EXECUTE_PREPARED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_extract_statements {
        __DUCKDB_EXTRACT_STATEMENTS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_prepare_extracted_statement {
        __DUCKDB_PREPARE_EXTRACTED_STATEMENT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_extract_statements_error {
        __DUCKDB_EXTRACT_STATEMENTS_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_extracted {
        __DUCKDB_DESTROY_EXTRACTED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_pending_prepared {
        __DUCKDB_PENDING_PREPARED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_pending {
        __DUCKDB_DESTROY_PENDING
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_pending_error {
        __DUCKDB_PENDING_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_pending_execute_task {
        __DUCKDB_PENDING_EXECUTE_TASK
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_pending_execute_check_state {
        __DUCKDB_PENDING_EXECUTE_CHECK_STATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_execute_pending {
        __DUCKDB_EXECUTE_PENDING
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_pending_execution_is_finished {
        __DUCKDB_PENDING_EXECUTION_IS_FINISHED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_value {
        __DUCKDB_DESTROY_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_varchar {
        __DUCKDB_CREATE_VARCHAR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_varchar_length {
        __DUCKDB_CREATE_VARCHAR_LENGTH
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_int64 {
        __DUCKDB_CREATE_INT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_struct_value {
        __DUCKDB_CREATE_STRUCT_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_list_value {
        __DUCKDB_CREATE_LIST_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_array_value {
        __DUCKDB_CREATE_ARRAY_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_varchar {
        __DUCKDB_GET_VARCHAR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_int64 {
        __DUCKDB_GET_INT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_logical_type {
        __DUCKDB_CREATE_LOGICAL_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_logical_type_get_alias {
        __DUCKDB_LOGICAL_TYPE_GET_ALIAS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_list_type {
        __DUCKDB_CREATE_LIST_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_array_type {
        __DUCKDB_CREATE_ARRAY_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_map_type {
        __DUCKDB_CREATE_MAP_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_union_type {
        __DUCKDB_CREATE_UNION_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_struct_type {
        __DUCKDB_CREATE_STRUCT_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_enum_type {
        __DUCKDB_CREATE_ENUM_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_decimal_type {
        __DUCKDB_CREATE_DECIMAL_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_type_id {
        __DUCKDB_GET_TYPE_ID
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_decimal_width {
        __DUCKDB_DECIMAL_WIDTH
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_decimal_scale {
        __DUCKDB_DECIMAL_SCALE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_decimal_internal_type {
        __DUCKDB_DECIMAL_INTERNAL_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_enum_internal_type {
        __DUCKDB_ENUM_INTERNAL_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_enum_dictionary_size {
        __DUCKDB_ENUM_DICTIONARY_SIZE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_enum_dictionary_value {
        __DUCKDB_ENUM_DICTIONARY_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_list_type_child_type {
        __DUCKDB_LIST_TYPE_CHILD_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_array_type_child_type {
        __DUCKDB_ARRAY_TYPE_CHILD_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_array_type_array_size {
        __DUCKDB_ARRAY_TYPE_ARRAY_SIZE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_map_type_key_type {
        __DUCKDB_MAP_TYPE_KEY_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_map_type_value_type {
        __DUCKDB_MAP_TYPE_VALUE_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_struct_type_child_count {
        __DUCKDB_STRUCT_TYPE_CHILD_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_struct_type_child_name {
        __DUCKDB_STRUCT_TYPE_CHILD_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_struct_type_child_type {
        __DUCKDB_STRUCT_TYPE_CHILD_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_union_type_member_count {
        __DUCKDB_UNION_TYPE_MEMBER_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_union_type_member_name {
        __DUCKDB_UNION_TYPE_MEMBER_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_union_type_member_type {
        __DUCKDB_UNION_TYPE_MEMBER_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_logical_type {
        __DUCKDB_DESTROY_LOGICAL_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_fetch_chunk {
        __DUCKDB_FETCH_CHUNK
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_data_chunk {
        __DUCKDB_CREATE_DATA_CHUNK
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_data_chunk {
        __DUCKDB_DESTROY_DATA_CHUNK
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_data_chunk_reset {
        __DUCKDB_DATA_CHUNK_RESET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_data_chunk_get_column_count {
        __DUCKDB_DATA_CHUNK_GET_COLUMN_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_data_chunk_get_vector {
        __DUCKDB_DATA_CHUNK_GET_VECTOR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_data_chunk_get_size {
        __DUCKDB_DATA_CHUNK_GET_SIZE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_data_chunk_set_size {
        __DUCKDB_DATA_CHUNK_SET_SIZE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_vector_get_column_type {
        __DUCKDB_VECTOR_GET_COLUMN_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_vector_get_data {
        __DUCKDB_VECTOR_GET_DATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_vector_get_validity {
        __DUCKDB_VECTOR_GET_VALIDITY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_vector_ensure_validity_writable {
        __DUCKDB_VECTOR_ENSURE_VALIDITY_WRITABLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_vector_assign_string_element {
        __DUCKDB_VECTOR_ASSIGN_STRING_ELEMENT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_vector_assign_string_element_len {
        __DUCKDB_VECTOR_ASSIGN_STRING_ELEMENT_LEN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_list_vector_get_child {
        __DUCKDB_LIST_VECTOR_GET_CHILD
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_list_vector_get_size {
        __DUCKDB_LIST_VECTOR_GET_SIZE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_list_vector_set_size {
        __DUCKDB_LIST_VECTOR_SET_SIZE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_list_vector_reserve {
        __DUCKDB_LIST_VECTOR_RESERVE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_struct_vector_get_child {
        __DUCKDB_STRUCT_VECTOR_GET_CHILD
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_array_vector_get_child {
        __DUCKDB_ARRAY_VECTOR_GET_CHILD
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_validity_row_is_valid {
        __DUCKDB_VALIDITY_ROW_IS_VALID
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_validity_set_row_validity {
        __DUCKDB_VALIDITY_SET_ROW_VALIDITY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_validity_set_row_invalid {
        __DUCKDB_VALIDITY_SET_ROW_INVALID
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_validity_set_row_valid {
        __DUCKDB_VALIDITY_SET_ROW_VALID
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_scalar_function {
        __DUCKDB_CREATE_SCALAR_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_scalar_function {
        __DUCKDB_DESTROY_SCALAR_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_set_name {
        __DUCKDB_SCALAR_FUNCTION_SET_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_add_parameter {
        __DUCKDB_SCALAR_FUNCTION_ADD_PARAMETER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_set_return_type {
        __DUCKDB_SCALAR_FUNCTION_SET_RETURN_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_set_extra_info {
        __DUCKDB_SCALAR_FUNCTION_SET_EXTRA_INFO
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_set_function {
        __DUCKDB_SCALAR_FUNCTION_SET_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_register_scalar_function {
        __DUCKDB_REGISTER_SCALAR_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_table_function {
        __DUCKDB_CREATE_TABLE_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_table_function {
        __DUCKDB_DESTROY_TABLE_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_function_set_name {
        __DUCKDB_TABLE_FUNCTION_SET_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_function_add_parameter {
        __DUCKDB_TABLE_FUNCTION_ADD_PARAMETER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_function_add_named_parameter {
        __DUCKDB_TABLE_FUNCTION_ADD_NAMED_PARAMETER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_function_set_extra_info {
        __DUCKDB_TABLE_FUNCTION_SET_EXTRA_INFO
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_function_set_bind {
        __DUCKDB_TABLE_FUNCTION_SET_BIND
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_function_set_init {
        __DUCKDB_TABLE_FUNCTION_SET_INIT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_function_set_local_init {
        __DUCKDB_TABLE_FUNCTION_SET_LOCAL_INIT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_function_set_function {
        __DUCKDB_TABLE_FUNCTION_SET_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_function_supports_projection_pushdown {
        __DUCKDB_TABLE_FUNCTION_SUPPORTS_PROJECTION_PUSHDOWN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_register_table_function {
        __DUCKDB_REGISTER_TABLE_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_get_extra_info {
        __DUCKDB_BIND_GET_EXTRA_INFO
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_add_result_column {
        __DUCKDB_BIND_ADD_RESULT_COLUMN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_get_parameter_count {
        __DUCKDB_BIND_GET_PARAMETER_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_get_parameter {
        __DUCKDB_BIND_GET_PARAMETER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_get_named_parameter {
        __DUCKDB_BIND_GET_NAMED_PARAMETER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_set_bind_data {
        __DUCKDB_BIND_SET_BIND_DATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_set_cardinality {
        __DUCKDB_BIND_SET_CARDINALITY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_set_error {
        __DUCKDB_BIND_SET_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_init_get_extra_info {
        __DUCKDB_INIT_GET_EXTRA_INFO
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_init_get_bind_data {
        __DUCKDB_INIT_GET_BIND_DATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_init_set_init_data {
        __DUCKDB_INIT_SET_INIT_DATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_init_get_column_count {
        __DUCKDB_INIT_GET_COLUMN_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_init_get_column_index {
        __DUCKDB_INIT_GET_COLUMN_INDEX
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_init_set_max_threads {
        __DUCKDB_INIT_SET_MAX_THREADS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_init_set_error {
        __DUCKDB_INIT_SET_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_function_get_extra_info {
        __DUCKDB_FUNCTION_GET_EXTRA_INFO
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_function_get_bind_data {
        __DUCKDB_FUNCTION_GET_BIND_DATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_function_get_init_data {
        __DUCKDB_FUNCTION_GET_INIT_DATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_function_get_local_init_data {
        __DUCKDB_FUNCTION_GET_LOCAL_INIT_DATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_function_set_error {
        __DUCKDB_FUNCTION_SET_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_add_replacement_scan {
        __DUCKDB_ADD_REPLACEMENT_SCAN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_replacement_scan_set_function_name {
        __DUCKDB_REPLACEMENT_SCAN_SET_FUNCTION_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_replacement_scan_add_parameter {
        __DUCKDB_REPLACEMENT_SCAN_ADD_PARAMETER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_replacement_scan_set_error {
        __DUCKDB_REPLACEMENT_SCAN_SET_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_appender_create {
        __DUCKDB_APPENDER_CREATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_appender_column_count {
        __DUCKDB_APPENDER_COLUMN_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_appender_column_type {
        __DUCKDB_APPENDER_COLUMN_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_appender_error {
        __DUCKDB_APPENDER_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_appender_flush {
        __DUCKDB_APPENDER_FLUSH
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_appender_close {
        __DUCKDB_APPENDER_CLOSE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_appender_destroy {
        __DUCKDB_APPENDER_DESTROY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_appender_begin_row {
        __DUCKDB_APPENDER_BEGIN_ROW
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_appender_end_row {
        __DUCKDB_APPENDER_END_ROW
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_default {
        __DUCKDB_APPEND_DEFAULT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_bool {
        __DUCKDB_APPEND_BOOL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_int8 {
        __DUCKDB_APPEND_INT8
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_int16 {
        __DUCKDB_APPEND_INT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_int32 {
        __DUCKDB_APPEND_INT32
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_int64 {
        __DUCKDB_APPEND_INT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_hugeint {
        __DUCKDB_APPEND_HUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_uint8 {
        __DUCKDB_APPEND_UINT8
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_uint16 {
        __DUCKDB_APPEND_UINT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_uint32 {
        __DUCKDB_APPEND_UINT32
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_uint64 {
        __DUCKDB_APPEND_UINT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_uhugeint {
        __DUCKDB_APPEND_UHUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_float {
        __DUCKDB_APPEND_FLOAT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_double {
        __DUCKDB_APPEND_DOUBLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_date {
        __DUCKDB_APPEND_DATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_time {
        __DUCKDB_APPEND_TIME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_timestamp {
        __DUCKDB_APPEND_TIMESTAMP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_interval {
        __DUCKDB_APPEND_INTERVAL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_varchar {
        __DUCKDB_APPEND_VARCHAR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_varchar_length {
        __DUCKDB_APPEND_VARCHAR_LENGTH
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_blob {
        __DUCKDB_APPEND_BLOB
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_null {
        __DUCKDB_APPEND_NULL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_data_chunk {
        __DUCKDB_APPEND_DATA_CHUNK
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_execute_tasks {
        __DUCKDB_EXECUTE_TASKS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_task_state {
        __DUCKDB_CREATE_TASK_STATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_execute_tasks_state {
        __DUCKDB_EXECUTE_TASKS_STATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_execute_n_tasks_state {
        __DUCKDB_EXECUTE_N_TASKS_STATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_finish_execution {
        __DUCKDB_FINISH_EXECUTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_task_state_is_finished {
        __DUCKDB_TASK_STATE_IS_FINISHED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_task_state {
        __DUCKDB_DESTROY_TASK_STATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_execution_is_finished {
        __DUCKDB_EXECUTION_IS_FINISHED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_profiling_info {
        __DUCKDB_GET_PROFILING_INFO
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_profiling_info_get_value {
        __DUCKDB_PROFILING_INFO_GET_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_profiling_info_get_child_count {
        __DUCKDB_PROFILING_INFO_GET_CHILD_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_profiling_info_get_child {
        __DUCKDB_PROFILING_INFO_GET_CHILD
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_profiling_info_get_name {
        __DUCKDB_PROFILING_INFO_GET_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_profiling_info_get_query {
        __DUCKDB_PROFILING_INFO_GET_QUERY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_set_varargs {
        __DUCKDB_SCALAR_FUNCTION_SET_VARARGS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_set_special_handling {
        __DUCKDB_SCALAR_FUNCTION_SET_SPECIAL_HANDLING
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_set_volatile {
        __DUCKDB_SCALAR_FUNCTION_SET_VOLATILE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_get_extra_info {
        __DUCKDB_SCALAR_FUNCTION_GET_EXTRA_INFO
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_set_error {
        __DUCKDB_SCALAR_FUNCTION_SET_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_description_create {
        __DUCKDB_TABLE_DESCRIPTION_CREATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_description_destroy {
        __DUCKDB_TABLE_DESCRIPTION_DESTROY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_description_error {
        __DUCKDB_TABLE_DESCRIPTION_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_result_error_type {
        __DUCKDB_RESULT_ERROR_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_string_t_length {
        __DUCKDB_STRING_T_LENGTH
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_string_t_data {
        __DUCKDB_STRING_T_DATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_bool {
        __DUCKDB_CREATE_BOOL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_int8 {
        __DUCKDB_CREATE_INT8
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_uint8 {
        __DUCKDB_CREATE_UINT8
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_int16 {
        __DUCKDB_CREATE_INT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_uint16 {
        __DUCKDB_CREATE_UINT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_int32 {
        __DUCKDB_CREATE_INT32
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_uint32 {
        __DUCKDB_CREATE_UINT32
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_uint64 {
        __DUCKDB_CREATE_UINT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_hugeint {
        __DUCKDB_CREATE_HUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_uhugeint {
        __DUCKDB_CREATE_UHUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_float {
        __DUCKDB_CREATE_FLOAT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_double {
        __DUCKDB_CREATE_DOUBLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_date {
        __DUCKDB_CREATE_DATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_time {
        __DUCKDB_CREATE_TIME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_time_tz_value {
        __DUCKDB_CREATE_TIME_TZ_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_timestamp {
        __DUCKDB_CREATE_TIMESTAMP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_interval {
        __DUCKDB_CREATE_INTERVAL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_blob {
        __DUCKDB_CREATE_BLOB
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_bool {
        __DUCKDB_GET_BOOL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_int8 {
        __DUCKDB_GET_INT8
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_uint8 {
        __DUCKDB_GET_UINT8
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_int16 {
        __DUCKDB_GET_INT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_uint16 {
        __DUCKDB_GET_UINT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_int32 {
        __DUCKDB_GET_INT32
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_uint32 {
        __DUCKDB_GET_UINT32
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_uint64 {
        __DUCKDB_GET_UINT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_hugeint {
        __DUCKDB_GET_HUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_uhugeint {
        __DUCKDB_GET_UHUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_float {
        __DUCKDB_GET_FLOAT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_double {
        __DUCKDB_GET_DOUBLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_date {
        __DUCKDB_GET_DATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_time {
        __DUCKDB_GET_TIME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_time_tz {
        __DUCKDB_GET_TIME_TZ
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_timestamp {
        __DUCKDB_GET_TIMESTAMP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_interval {
        __DUCKDB_GET_INTERVAL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_value_type {
        __DUCKDB_GET_VALUE_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_blob {
        __DUCKDB_GET_BLOB
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_scalar_function_set {
        __DUCKDB_CREATE_SCALAR_FUNCTION_SET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_scalar_function_set {
        __DUCKDB_DESTROY_SCALAR_FUNCTION_SET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_add_scalar_function_to_set {
        __DUCKDB_ADD_SCALAR_FUNCTION_TO_SET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_register_scalar_function_set {
        __DUCKDB_REGISTER_SCALAR_FUNCTION_SET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_aggregate_function_set {
        __DUCKDB_CREATE_AGGREGATE_FUNCTION_SET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_aggregate_function_set {
        __DUCKDB_DESTROY_AGGREGATE_FUNCTION_SET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_add_aggregate_function_to_set {
        __DUCKDB_ADD_AGGREGATE_FUNCTION_TO_SET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_register_aggregate_function_set {
        __DUCKDB_REGISTER_AGGREGATE_FUNCTION_SET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    Ok(())
}

