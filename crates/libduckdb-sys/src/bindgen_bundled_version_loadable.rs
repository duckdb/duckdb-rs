/* automatically generated by rust-bindgen 0.69.4 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 0;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const DUCKDB_EXTENSION_API_VERSION_MAJOR: u32 = 0;
pub const DUCKDB_EXTENSION_API_VERSION_MINOR: u32 = 0;
pub const DUCKDB_EXTENSION_API_VERSION_PATCH: u32 = 1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_uint;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__fsid_t), "::", stringify!(__val))
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_int;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub const DUCKDB_TYPE_DUCKDB_TYPE_INVALID: DUCKDB_TYPE = 0;
pub const DUCKDB_TYPE_DUCKDB_TYPE_BOOLEAN: DUCKDB_TYPE = 1;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TINYINT: DUCKDB_TYPE = 2;
pub const DUCKDB_TYPE_DUCKDB_TYPE_SMALLINT: DUCKDB_TYPE = 3;
pub const DUCKDB_TYPE_DUCKDB_TYPE_INTEGER: DUCKDB_TYPE = 4;
pub const DUCKDB_TYPE_DUCKDB_TYPE_BIGINT: DUCKDB_TYPE = 5;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UTINYINT: DUCKDB_TYPE = 6;
pub const DUCKDB_TYPE_DUCKDB_TYPE_USMALLINT: DUCKDB_TYPE = 7;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UINTEGER: DUCKDB_TYPE = 8;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UBIGINT: DUCKDB_TYPE = 9;
pub const DUCKDB_TYPE_DUCKDB_TYPE_FLOAT: DUCKDB_TYPE = 10;
pub const DUCKDB_TYPE_DUCKDB_TYPE_DOUBLE: DUCKDB_TYPE = 11;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIMESTAMP: DUCKDB_TYPE = 12;
pub const DUCKDB_TYPE_DUCKDB_TYPE_DATE: DUCKDB_TYPE = 13;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIME: DUCKDB_TYPE = 14;
pub const DUCKDB_TYPE_DUCKDB_TYPE_INTERVAL: DUCKDB_TYPE = 15;
pub const DUCKDB_TYPE_DUCKDB_TYPE_HUGEINT: DUCKDB_TYPE = 16;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UHUGEINT: DUCKDB_TYPE = 32;
pub const DUCKDB_TYPE_DUCKDB_TYPE_VARCHAR: DUCKDB_TYPE = 17;
pub const DUCKDB_TYPE_DUCKDB_TYPE_BLOB: DUCKDB_TYPE = 18;
pub const DUCKDB_TYPE_DUCKDB_TYPE_DECIMAL: DUCKDB_TYPE = 19;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIMESTAMP_S: DUCKDB_TYPE = 20;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIMESTAMP_MS: DUCKDB_TYPE = 21;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIMESTAMP_NS: DUCKDB_TYPE = 22;
pub const DUCKDB_TYPE_DUCKDB_TYPE_ENUM: DUCKDB_TYPE = 23;
pub const DUCKDB_TYPE_DUCKDB_TYPE_LIST: DUCKDB_TYPE = 24;
pub const DUCKDB_TYPE_DUCKDB_TYPE_STRUCT: DUCKDB_TYPE = 25;
pub const DUCKDB_TYPE_DUCKDB_TYPE_MAP: DUCKDB_TYPE = 26;
pub const DUCKDB_TYPE_DUCKDB_TYPE_ARRAY: DUCKDB_TYPE = 33;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UUID: DUCKDB_TYPE = 27;
pub const DUCKDB_TYPE_DUCKDB_TYPE_UNION: DUCKDB_TYPE = 28;
pub const DUCKDB_TYPE_DUCKDB_TYPE_BIT: DUCKDB_TYPE = 29;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIME_TZ: DUCKDB_TYPE = 30;
pub const DUCKDB_TYPE_DUCKDB_TYPE_TIMESTAMP_TZ: DUCKDB_TYPE = 31;
pub const DUCKDB_TYPE_DUCKDB_TYPE_ANY: DUCKDB_TYPE = 34;
pub const DUCKDB_TYPE_DUCKDB_TYPE_VARINT: DUCKDB_TYPE = 35;
pub const DUCKDB_TYPE_DUCKDB_TYPE_SQLNULL: DUCKDB_TYPE = 36;
#[doc = "! An enum over DuckDB's internal types."]
pub type DUCKDB_TYPE = ::std::os::raw::c_uint;
#[doc = "! An enum over DuckDB's internal types."]
pub use self::DUCKDB_TYPE as duckdb_type;
pub const duckdb_state_DuckDBSuccess: duckdb_state = 0;
pub const duckdb_state_DuckDBError: duckdb_state = 1;
#[doc = "! An enum over the returned state of different functions."]
pub type duckdb_state = ::std::os::raw::c_uint;
pub const duckdb_pending_state_DUCKDB_PENDING_RESULT_READY: duckdb_pending_state = 0;
pub const duckdb_pending_state_DUCKDB_PENDING_RESULT_NOT_READY: duckdb_pending_state = 1;
pub const duckdb_pending_state_DUCKDB_PENDING_ERROR: duckdb_pending_state = 2;
pub const duckdb_pending_state_DUCKDB_PENDING_NO_TASKS_AVAILABLE: duckdb_pending_state = 3;
#[doc = "! An enum over the pending state of a pending query result."]
pub type duckdb_pending_state = ::std::os::raw::c_uint;
pub const duckdb_result_type_DUCKDB_RESULT_TYPE_INVALID: duckdb_result_type = 0;
pub const duckdb_result_type_DUCKDB_RESULT_TYPE_CHANGED_ROWS: duckdb_result_type = 1;
pub const duckdb_result_type_DUCKDB_RESULT_TYPE_NOTHING: duckdb_result_type = 2;
pub const duckdb_result_type_DUCKDB_RESULT_TYPE_QUERY_RESULT: duckdb_result_type = 3;
#[doc = "! An enum over DuckDB's different result types."]
pub type duckdb_result_type = ::std::os::raw::c_uint;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_INVALID: duckdb_statement_type = 0;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_SELECT: duckdb_statement_type = 1;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_INSERT: duckdb_statement_type = 2;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_UPDATE: duckdb_statement_type = 3;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_EXPLAIN: duckdb_statement_type = 4;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_DELETE: duckdb_statement_type = 5;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_PREPARE: duckdb_statement_type = 6;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_CREATE: duckdb_statement_type = 7;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_EXECUTE: duckdb_statement_type = 8;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_ALTER: duckdb_statement_type = 9;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_TRANSACTION: duckdb_statement_type = 10;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_COPY: duckdb_statement_type = 11;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_ANALYZE: duckdb_statement_type = 12;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_VARIABLE_SET: duckdb_statement_type = 13;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_CREATE_FUNC: duckdb_statement_type = 14;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_DROP: duckdb_statement_type = 15;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_EXPORT: duckdb_statement_type = 16;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_PRAGMA: duckdb_statement_type = 17;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_VACUUM: duckdb_statement_type = 18;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_CALL: duckdb_statement_type = 19;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_SET: duckdb_statement_type = 20;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_LOAD: duckdb_statement_type = 21;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_RELATION: duckdb_statement_type = 22;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_EXTENSION: duckdb_statement_type = 23;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_LOGICAL_PLAN: duckdb_statement_type = 24;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_ATTACH: duckdb_statement_type = 25;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_DETACH: duckdb_statement_type = 26;
pub const duckdb_statement_type_DUCKDB_STATEMENT_TYPE_MULTI: duckdb_statement_type = 27;
#[doc = "! An enum over DuckDB's different statement types."]
pub type duckdb_statement_type = ::std::os::raw::c_uint;
pub const duckdb_error_type_DUCKDB_ERROR_INVALID: duckdb_error_type = 0;
pub const duckdb_error_type_DUCKDB_ERROR_OUT_OF_RANGE: duckdb_error_type = 1;
pub const duckdb_error_type_DUCKDB_ERROR_CONVERSION: duckdb_error_type = 2;
pub const duckdb_error_type_DUCKDB_ERROR_UNKNOWN_TYPE: duckdb_error_type = 3;
pub const duckdb_error_type_DUCKDB_ERROR_DECIMAL: duckdb_error_type = 4;
pub const duckdb_error_type_DUCKDB_ERROR_MISMATCH_TYPE: duckdb_error_type = 5;
pub const duckdb_error_type_DUCKDB_ERROR_DIVIDE_BY_ZERO: duckdb_error_type = 6;
pub const duckdb_error_type_DUCKDB_ERROR_OBJECT_SIZE: duckdb_error_type = 7;
pub const duckdb_error_type_DUCKDB_ERROR_INVALID_TYPE: duckdb_error_type = 8;
pub const duckdb_error_type_DUCKDB_ERROR_SERIALIZATION: duckdb_error_type = 9;
pub const duckdb_error_type_DUCKDB_ERROR_TRANSACTION: duckdb_error_type = 10;
pub const duckdb_error_type_DUCKDB_ERROR_NOT_IMPLEMENTED: duckdb_error_type = 11;
pub const duckdb_error_type_DUCKDB_ERROR_EXPRESSION: duckdb_error_type = 12;
pub const duckdb_error_type_DUCKDB_ERROR_CATALOG: duckdb_error_type = 13;
pub const duckdb_error_type_DUCKDB_ERROR_PARSER: duckdb_error_type = 14;
pub const duckdb_error_type_DUCKDB_ERROR_PLANNER: duckdb_error_type = 15;
pub const duckdb_error_type_DUCKDB_ERROR_SCHEDULER: duckdb_error_type = 16;
pub const duckdb_error_type_DUCKDB_ERROR_EXECUTOR: duckdb_error_type = 17;
pub const duckdb_error_type_DUCKDB_ERROR_CONSTRAINT: duckdb_error_type = 18;
pub const duckdb_error_type_DUCKDB_ERROR_INDEX: duckdb_error_type = 19;
pub const duckdb_error_type_DUCKDB_ERROR_STAT: duckdb_error_type = 20;
pub const duckdb_error_type_DUCKDB_ERROR_CONNECTION: duckdb_error_type = 21;
pub const duckdb_error_type_DUCKDB_ERROR_SYNTAX: duckdb_error_type = 22;
pub const duckdb_error_type_DUCKDB_ERROR_SETTINGS: duckdb_error_type = 23;
pub const duckdb_error_type_DUCKDB_ERROR_BINDER: duckdb_error_type = 24;
pub const duckdb_error_type_DUCKDB_ERROR_NETWORK: duckdb_error_type = 25;
pub const duckdb_error_type_DUCKDB_ERROR_OPTIMIZER: duckdb_error_type = 26;
pub const duckdb_error_type_DUCKDB_ERROR_NULL_POINTER: duckdb_error_type = 27;
pub const duckdb_error_type_DUCKDB_ERROR_IO: duckdb_error_type = 28;
pub const duckdb_error_type_DUCKDB_ERROR_INTERRUPT: duckdb_error_type = 29;
pub const duckdb_error_type_DUCKDB_ERROR_FATAL: duckdb_error_type = 30;
pub const duckdb_error_type_DUCKDB_ERROR_INTERNAL: duckdb_error_type = 31;
pub const duckdb_error_type_DUCKDB_ERROR_INVALID_INPUT: duckdb_error_type = 32;
pub const duckdb_error_type_DUCKDB_ERROR_OUT_OF_MEMORY: duckdb_error_type = 33;
pub const duckdb_error_type_DUCKDB_ERROR_PERMISSION: duckdb_error_type = 34;
pub const duckdb_error_type_DUCKDB_ERROR_PARAMETER_NOT_RESOLVED: duckdb_error_type = 35;
pub const duckdb_error_type_DUCKDB_ERROR_PARAMETER_NOT_ALLOWED: duckdb_error_type = 36;
pub const duckdb_error_type_DUCKDB_ERROR_DEPENDENCY: duckdb_error_type = 37;
pub const duckdb_error_type_DUCKDB_ERROR_HTTP: duckdb_error_type = 38;
pub const duckdb_error_type_DUCKDB_ERROR_MISSING_EXTENSION: duckdb_error_type = 39;
pub const duckdb_error_type_DUCKDB_ERROR_AUTOLOAD: duckdb_error_type = 40;
pub const duckdb_error_type_DUCKDB_ERROR_SEQUENCE: duckdb_error_type = 41;
pub const duckdb_error_type_DUCKDB_INVALID_CONFIGURATION: duckdb_error_type = 42;
#[doc = "! An enum over DuckDB's different result types."]
pub type duckdb_error_type = ::std::os::raw::c_uint;
pub const duckdb_cast_mode_DUCKDB_CAST_NORMAL: duckdb_cast_mode = 0;
pub const duckdb_cast_mode_DUCKDB_CAST_TRY: duckdb_cast_mode = 1;
#[doc = "! An enum over DuckDB's different cast modes."]
pub type duckdb_cast_mode = ::std::os::raw::c_uint;
#[doc = "! DuckDB's index type."]
pub type idx_t = u64;
#[doc = "! The callback that will be called to destroy data, e.g.,\n! bind data (if any), init data (if any), extra data for replacement scans (if any)"]
pub type duckdb_delete_callback_t = ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
#[doc = "! Used for threading, contains a task state. Must be destroyed with `duckdb_destroy_state`."]
pub type duckdb_task_state = *mut ::std::os::raw::c_void;
#[doc = "! Days are stored as days since 1970-01-01\n! Use the duckdb_from_date/duckdb_to_date function to extract individual information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_date {
    pub days: i32,
}
#[test]
fn bindgen_test_layout_duckdb_date() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_date> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_date>(),
        4usize,
        concat!("Size of: ", stringify!(duckdb_date))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_date>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_date))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).days) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_date), "::", stringify!(days))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_date_struct {
    pub year: i32,
    pub month: i8,
    pub day: i8,
}
#[test]
fn bindgen_test_layout_duckdb_date_struct() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_date_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_date_struct>(),
        8usize,
        concat!("Size of: ", stringify!(duckdb_date_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_date_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_date_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).year) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_date_struct),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_date_struct),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_date_struct),
            "::",
            stringify!(day)
        )
    );
}
#[doc = "! Time is stored as microseconds since 00:00:00\n! Use the duckdb_from_time/duckdb_to_time function to extract individual information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_time {
    pub micros: i64,
}
#[test]
fn bindgen_test_layout_duckdb_time() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_time> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_time>(),
        8usize,
        concat!("Size of: ", stringify!(duckdb_time))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_time>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_time))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).micros) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_time), "::", stringify!(micros))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_time_struct {
    pub hour: i8,
    pub min: i8,
    pub sec: i8,
    pub micros: i32,
}
#[test]
fn bindgen_test_layout_duckdb_time_struct() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_time_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_time_struct>(),
        8usize,
        concat!("Size of: ", stringify!(duckdb_time_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_time_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_time_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hour) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_struct),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_struct),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sec) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_struct),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).micros) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_struct),
            "::",
            stringify!(micros)
        )
    );
}
#[doc = "! TIME_TZ is stored as 40 bits for int64_t micros, and 24 bits for int32_t offset"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_time_tz {
    pub bits: u64,
}
#[test]
fn bindgen_test_layout_duckdb_time_tz() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_time_tz> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_time_tz>(),
        8usize,
        concat!("Size of: ", stringify!(duckdb_time_tz))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_time_tz>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_time_tz))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_time_tz), "::", stringify!(bits))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_time_tz_struct {
    pub time: duckdb_time_struct,
    pub offset: i32,
}
#[test]
fn bindgen_test_layout_duckdb_time_tz_struct() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_time_tz_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_time_tz_struct>(),
        12usize,
        concat!("Size of: ", stringify!(duckdb_time_tz_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_time_tz_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_time_tz_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_tz_struct),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_time_tz_struct),
            "::",
            stringify!(offset)
        )
    );
}
#[doc = "! Timestamps are stored as microseconds since 1970-01-01\n! Use the duckdb_from_timestamp/duckdb_to_timestamp function to extract individual information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_timestamp {
    pub micros: i64,
}
#[test]
fn bindgen_test_layout_duckdb_timestamp() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_timestamp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_timestamp>(),
        8usize,
        concat!("Size of: ", stringify!(duckdb_timestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_timestamp>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_timestamp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).micros) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_timestamp),
            "::",
            stringify!(micros)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_timestamp_struct {
    pub date: duckdb_date_struct,
    pub time: duckdb_time_struct,
}
#[test]
fn bindgen_test_layout_duckdb_timestamp_struct() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_timestamp_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_timestamp_struct>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_timestamp_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_timestamp_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_timestamp_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).date) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_timestamp_struct),
            "::",
            stringify!(date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_timestamp_struct),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_interval {
    pub months: i32,
    pub days: i32,
    pub micros: i64,
}
#[test]
fn bindgen_test_layout_duckdb_interval() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_interval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_interval>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_interval))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_interval>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_interval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).months) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_interval),
            "::",
            stringify!(months)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).days) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(duckdb_interval), "::", stringify!(days))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).micros) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_interval),
            "::",
            stringify!(micros)
        )
    );
}
#[doc = "! Hugeints are composed of a (lower, upper) component\n! The value of the hugeint is upper * 2^64 + lower\n! For easy usage, the functions duckdb_hugeint_to_double/duckdb_double_to_hugeint are recommended"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_hugeint {
    pub lower: u64,
    pub upper: i64,
}
#[test]
fn bindgen_test_layout_duckdb_hugeint() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_hugeint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_hugeint>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_hugeint))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_hugeint>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_hugeint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lower) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_hugeint), "::", stringify!(lower))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).upper) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(duckdb_hugeint), "::", stringify!(upper))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_uhugeint {
    pub lower: u64,
    pub upper: u64,
}
#[test]
fn bindgen_test_layout_duckdb_uhugeint() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_uhugeint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_uhugeint>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_uhugeint))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_uhugeint>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_uhugeint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lower) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_uhugeint),
            "::",
            stringify!(lower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).upper) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_uhugeint),
            "::",
            stringify!(upper)
        )
    );
}
#[doc = "! Decimals are composed of a width and a scale, and are stored in a hugeint"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_decimal {
    pub width: u8,
    pub scale: u8,
    pub value: duckdb_hugeint,
}
#[test]
fn bindgen_test_layout_duckdb_decimal() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_decimal> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_decimal>(),
        24usize,
        concat!("Size of: ", stringify!(duckdb_decimal))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_decimal>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_decimal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_decimal), "::", stringify!(width))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        1usize,
        concat!("Offset of field: ", stringify!(duckdb_decimal), "::", stringify!(scale))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(duckdb_decimal), "::", stringify!(value))
    );
}
#[doc = "! A type holding information about the query execution progress"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_query_progress_type {
    pub percentage: f64,
    pub rows_processed: u64,
    pub total_rows_to_process: u64,
}
#[test]
fn bindgen_test_layout_duckdb_query_progress_type() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_query_progress_type> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_query_progress_type>(),
        24usize,
        concat!("Size of: ", stringify!(duckdb_query_progress_type))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_query_progress_type>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_query_progress_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).percentage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_query_progress_type),
            "::",
            stringify!(percentage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rows_processed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_query_progress_type),
            "::",
            stringify!(rows_processed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_rows_to_process) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_query_progress_type),
            "::",
            stringify!(total_rows_to_process)
        )
    );
}
#[doc = "! The internal representation of a VARCHAR (string_t). If the VARCHAR does not\n! exceed 12 characters, then we inline it. Otherwise, we inline a prefix for faster\n! string comparisons and store a pointer to the remaining characters. This is a non-\n! owning structure, i.e., it does not have to be freed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct duckdb_string_t {
    pub value: duckdb_string_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union duckdb_string_t__bindgen_ty_1 {
    pub pointer: duckdb_string_t__bindgen_ty_1__bindgen_ty_1,
    pub inlined: duckdb_string_t__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_string_t__bindgen_ty_1__bindgen_ty_1 {
    pub length: u32,
    pub prefix: [::std::os::raw::c_char; 4usize],
    pub ptr: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_duckdb_string_t__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string_t__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string_t__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_string_t__bindgen_ty_1__bindgen_ty_2 {
    pub length: u32,
    pub inlined: [::std::os::raw::c_char; 12usize],
}
#[test]
fn bindgen_test_layout_duckdb_string_t__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string_t__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string_t__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string_t__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inlined) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(inlined)
        )
    );
}
#[test]
fn bindgen_test_layout_duckdb_string_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string_t__bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_string_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1),
            "::",
            stringify!(pointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inlined) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t__bindgen_ty_1),
            "::",
            stringify!(inlined)
        )
    );
}
#[test]
fn bindgen_test_layout_duckdb_string_t() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string_t>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string_t))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string_t>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_string_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_string_t),
            "::",
            stringify!(value)
        )
    );
}
#[doc = "! The internal representation of a list metadata entry contains the list's offset in\n! the child vector, and its length. The parent vector holds these metadata entries,\n! whereas the child vector holds the data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_list_entry {
    pub offset: u64,
    pub length: u64,
}
#[test]
fn bindgen_test_layout_duckdb_list_entry() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_list_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_list_entry>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_list_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_list_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_list_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_list_entry),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_list_entry),
            "::",
            stringify!(length)
        )
    );
}
#[doc = "! A column consists of a pointer to its internal data. Don't operate on this type directly.\n! Instead, use functions such as duckdb_column_data, duckdb_nullmask_data,\n! duckdb_column_type, and duckdb_column_name, which take the result and the column index\n! as their parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_column {
    pub deprecated_data: *mut ::std::os::raw::c_void,
    pub deprecated_nullmask: *mut bool,
    pub deprecated_type: duckdb_type,
    pub deprecated_name: *mut ::std::os::raw::c_char,
    pub internal_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_duckdb_column() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_column> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_column>(),
        40usize,
        concat!("Size of: ", stringify!(duckdb_column))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_column>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_column))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(deprecated_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated_nullmask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(deprecated_nullmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(deprecated_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(deprecated_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_column),
            "::",
            stringify!(internal_data)
        )
    );
}
#[doc = "! A vector to a specified column in a data chunk. Lives as long as the\n! data chunk lives, i.e., must not be destroyed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_vector {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_vector() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_vector> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_vector>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_vector>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_vector))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_vector),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! A vector to a specified column in a data chunk. Lives as long as the\n! data chunk lives, i.e., must not be destroyed."]
pub type duckdb_vector = *mut _duckdb_vector;
#[doc = "! Strings are composed of a char pointer and a size. You must free string.data\n! with `duckdb_free`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_string {
    pub data: *mut ::std::os::raw::c_char,
    pub size: idx_t,
}
#[test]
fn bindgen_test_layout_duckdb_string() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_string> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_string>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_string))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_string>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_string))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_string), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(duckdb_string), "::", stringify!(size))
    );
}
#[doc = "! BLOBs are composed of a byte pointer and a size. You must free blob.data\n! with `duckdb_free`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_blob {
    pub data: *mut ::std::os::raw::c_void,
    pub size: idx_t,
}
#[test]
fn bindgen_test_layout_duckdb_blob() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_blob> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_blob>(),
        16usize,
        concat!("Size of: ", stringify!(duckdb_blob))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_blob>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_blob))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(duckdb_blob), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(duckdb_blob), "::", stringify!(size))
    );
}
#[doc = "! A query result consists of a pointer to its internal data.\n! Must be freed with 'duckdb_destroy_result'."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_result {
    pub deprecated_column_count: idx_t,
    pub deprecated_row_count: idx_t,
    pub deprecated_rows_changed: idx_t,
    pub deprecated_columns: *mut duckdb_column,
    pub deprecated_error_message: *mut ::std::os::raw::c_char,
    pub internal_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_duckdb_result() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_result> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_result>(),
        48usize,
        concat!("Size of: ", stringify!(duckdb_result))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_result>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_result))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated_column_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(deprecated_column_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated_row_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(deprecated_row_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated_rows_changed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(deprecated_rows_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated_columns) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(deprecated_columns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated_error_message) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(deprecated_error_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_result),
            "::",
            stringify!(internal_data)
        )
    );
}
#[doc = "! A database object. Should be closed with `duckdb_close`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_database {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_database() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_database> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_database>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_database))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_database>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_database))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_database),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! A database object. Should be closed with `duckdb_close`."]
pub type duckdb_database = *mut _duckdb_database;
#[doc = "! A connection to a duckdb database. Must be closed with `duckdb_disconnect`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_connection {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_connection() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_connection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_connection>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_connection))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_connection>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_connection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_connection),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! A connection to a duckdb database. Must be closed with `duckdb_disconnect`."]
pub type duckdb_connection = *mut _duckdb_connection;
#[doc = "! A prepared statement is a parameterized query that allows you to bind parameters to it.\n! Must be destroyed with `duckdb_destroy_prepare`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_prepared_statement {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_prepared_statement() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_prepared_statement> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_prepared_statement>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_prepared_statement))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_prepared_statement>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_prepared_statement))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_prepared_statement),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! A prepared statement is a parameterized query that allows you to bind parameters to it.\n! Must be destroyed with `duckdb_destroy_prepare`."]
pub type duckdb_prepared_statement = *mut _duckdb_prepared_statement;
#[doc = "! Extracted statements. Must be destroyed with `duckdb_destroy_extracted`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_extracted_statements {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_extracted_statements() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_extracted_statements> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_extracted_statements>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_extracted_statements))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_extracted_statements>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_extracted_statements))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_extracted_statements),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Extracted statements. Must be destroyed with `duckdb_destroy_extracted`."]
pub type duckdb_extracted_statements = *mut _duckdb_extracted_statements;
#[doc = "! The pending result represents an intermediate structure for a query that is not yet fully executed.\n! Must be destroyed with `duckdb_destroy_pending`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_pending_result {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_pending_result() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_pending_result> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_pending_result>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_pending_result))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_pending_result>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_pending_result))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_pending_result),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! The pending result represents an intermediate structure for a query that is not yet fully executed.\n! Must be destroyed with `duckdb_destroy_pending`."]
pub type duckdb_pending_result = *mut _duckdb_pending_result;
#[doc = "! The appender enables fast data loading into DuckDB.\n! Must be destroyed with `duckdb_appender_destroy`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_appender {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_appender() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_appender> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_appender>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_appender))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_appender>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_appender))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_appender),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! The appender enables fast data loading into DuckDB.\n! Must be destroyed with `duckdb_appender_destroy`."]
pub type duckdb_appender = *mut _duckdb_appender;
#[doc = "! The table description allows querying info about the table.\n! Must be destroyed with `duckdb_table_description_destroy`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_table_description {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_table_description() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_table_description> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_table_description>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_table_description))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_table_description>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_table_description))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_table_description),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! The table description allows querying info about the table.\n! Must be destroyed with `duckdb_table_description_destroy`."]
pub type duckdb_table_description = *mut _duckdb_table_description;
#[doc = "! Can be used to provide start-up options for the DuckDB instance.\n! Must be destroyed with `duckdb_destroy_config`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_config {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_config() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_config> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_config>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_config))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_config>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_config),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Can be used to provide start-up options for the DuckDB instance.\n! Must be destroyed with `duckdb_destroy_config`."]
pub type duckdb_config = *mut _duckdb_config;
#[doc = "! Holds an internal logical type.\n! Must be destroyed with `duckdb_destroy_logical_type`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_logical_type {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_logical_type() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_logical_type> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_logical_type>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_logical_type))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_logical_type>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_logical_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_logical_type),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Holds an internal logical type.\n! Must be destroyed with `duckdb_destroy_logical_type`."]
pub type duckdb_logical_type = *mut _duckdb_logical_type;
#[doc = "! Holds extra information used when registering a custom logical type.\n! Reserved for future use."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_create_type_info {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_create_type_info() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_create_type_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_create_type_info>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_create_type_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_create_type_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_create_type_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_create_type_info),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Holds extra information used when registering a custom logical type.\n! Reserved for future use."]
pub type duckdb_create_type_info = *mut _duckdb_create_type_info;
#[doc = "! Contains a data chunk from a duckdb_result.\n! Must be destroyed with `duckdb_destroy_data_chunk`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_data_chunk {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_data_chunk() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_data_chunk> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_data_chunk>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_data_chunk))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_data_chunk>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_data_chunk))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_data_chunk),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Contains a data chunk from a duckdb_result.\n! Must be destroyed with `duckdb_destroy_data_chunk`."]
pub type duckdb_data_chunk = *mut _duckdb_data_chunk;
#[doc = "! Holds a DuckDB value, which wraps a type.\n! Must be destroyed with `duckdb_destroy_value`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_value {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_value() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_value>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_value))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_value>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_value),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Holds a DuckDB value, which wraps a type.\n! Must be destroyed with `duckdb_destroy_value`."]
pub type duckdb_value = *mut _duckdb_value;
#[doc = "! Holds a recursive tree that matches the query plan."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_profiling_info {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_profiling_info() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_profiling_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_profiling_info>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_profiling_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_profiling_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_profiling_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_profiling_info),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Holds a recursive tree that matches the query plan."]
pub type duckdb_profiling_info = *mut _duckdb_profiling_info;
#[doc = "! Holds state during the C API extension intialization process"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_extension_info {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_extension_info() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_extension_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_extension_info>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_extension_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_extension_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_extension_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_extension_info),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Holds state during the C API extension intialization process"]
pub type duckdb_extension_info = *mut _duckdb_extension_info;
#[doc = "! Additional function info. When setting this info, it is necessary to pass a destroy-callback function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_function_info {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_function_info() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_function_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_function_info>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_function_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_function_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_function_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_function_info),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Additional function info. When setting this info, it is necessary to pass a destroy-callback function."]
pub type duckdb_function_info = *mut _duckdb_function_info;
#[doc = "! A scalar function. Must be destroyed with `duckdb_destroy_scalar_function`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_scalar_function {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_scalar_function() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_scalar_function> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_scalar_function>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_scalar_function))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_scalar_function>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_scalar_function))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_scalar_function),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! A scalar function. Must be destroyed with `duckdb_destroy_scalar_function`."]
pub type duckdb_scalar_function = *mut _duckdb_scalar_function;
#[doc = "! A scalar function set. Must be destroyed with `duckdb_destroy_scalar_function_set`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_scalar_function_set {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_scalar_function_set() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_scalar_function_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_scalar_function_set>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_scalar_function_set))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_scalar_function_set>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_scalar_function_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_scalar_function_set),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! A scalar function set. Must be destroyed with `duckdb_destroy_scalar_function_set`."]
pub type duckdb_scalar_function_set = *mut _duckdb_scalar_function_set;
#[doc = "! The main function of the scalar function."]
pub type duckdb_scalar_function_t = ::std::option::Option<
    unsafe extern "C" fn(info: duckdb_function_info, input: duckdb_data_chunk, output: duckdb_vector),
>;
#[doc = "! An aggregate function. Must be destroyed with `duckdb_destroy_aggregate_function`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_aggregate_function {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_aggregate_function() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_aggregate_function> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_aggregate_function>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_aggregate_function))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_aggregate_function>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_aggregate_function))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_aggregate_function),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! An aggregate function. Must be destroyed with `duckdb_destroy_aggregate_function`."]
pub type duckdb_aggregate_function = *mut _duckdb_aggregate_function;
#[doc = "! A aggregate function set. Must be destroyed with `duckdb_destroy_aggregate_function_set`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_aggregate_function_set {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_aggregate_function_set() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_aggregate_function_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_aggregate_function_set>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_aggregate_function_set))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_aggregate_function_set>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_aggregate_function_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_aggregate_function_set),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! A aggregate function set. Must be destroyed with `duckdb_destroy_aggregate_function_set`."]
pub type duckdb_aggregate_function_set = *mut _duckdb_aggregate_function_set;
#[doc = "! Aggregate state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_aggregate_state {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_aggregate_state() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_aggregate_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_aggregate_state>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_aggregate_state))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_aggregate_state>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_aggregate_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_aggregate_state),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Aggregate state"]
pub type duckdb_aggregate_state = *mut _duckdb_aggregate_state;
#[doc = "! Returns the aggregate state size"]
pub type duckdb_aggregate_state_size = ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info) -> idx_t>;
#[doc = "! Initialize the aggregate state"]
pub type duckdb_aggregate_init_t =
    ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info, state: duckdb_aggregate_state)>;
#[doc = "! Destroy aggregate state (optional)"]
pub type duckdb_aggregate_destroy_t =
    ::std::option::Option<unsafe extern "C" fn(states: *mut duckdb_aggregate_state, count: idx_t)>;
#[doc = "! Update a set of aggregate states with new values"]
pub type duckdb_aggregate_update_t = ::std::option::Option<
    unsafe extern "C" fn(info: duckdb_function_info, input: duckdb_data_chunk, states: *mut duckdb_aggregate_state),
>;
#[doc = "! Combine aggregate states"]
pub type duckdb_aggregate_combine_t = ::std::option::Option<
    unsafe extern "C" fn(
        info: duckdb_function_info,
        source: *mut duckdb_aggregate_state,
        target: *mut duckdb_aggregate_state,
        count: idx_t,
    ),
>;
#[doc = "! Finalize aggregate states into a result vector"]
pub type duckdb_aggregate_finalize_t = ::std::option::Option<
    unsafe extern "C" fn(
        info: duckdb_function_info,
        source: *mut duckdb_aggregate_state,
        result: duckdb_vector,
        count: idx_t,
        offset: idx_t,
    ),
>;
#[doc = "! A table function. Must be destroyed with `duckdb_destroy_table_function`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_table_function {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_table_function() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_table_function> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_table_function>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_table_function))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_table_function>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_table_function))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_table_function),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! A table function. Must be destroyed with `duckdb_destroy_table_function`."]
pub type duckdb_table_function = *mut _duckdb_table_function;
#[doc = "! The bind info of the function. When setting this info, it is necessary to pass a destroy-callback function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_bind_info {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_bind_info() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_bind_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_bind_info>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_bind_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_bind_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_bind_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_bind_info),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! The bind info of the function. When setting this info, it is necessary to pass a destroy-callback function."]
pub type duckdb_bind_info = *mut _duckdb_bind_info;
#[doc = "! Additional function init info. When setting this info, it is necessary to pass a destroy-callback function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_init_info {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_init_info() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_init_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_init_info>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_init_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_init_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_init_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_init_info),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Additional function init info. When setting this info, it is necessary to pass a destroy-callback function."]
pub type duckdb_init_info = *mut _duckdb_init_info;
#[doc = "! The bind function of the table function."]
pub type duckdb_table_function_bind_t = ::std::option::Option<unsafe extern "C" fn(info: duckdb_bind_info)>;
#[doc = "! The (possibly thread-local) init function of the table function."]
pub type duckdb_table_function_init_t = ::std::option::Option<unsafe extern "C" fn(info: duckdb_init_info)>;
#[doc = "! The main function of the table function."]
pub type duckdb_table_function_t =
    ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info, output: duckdb_data_chunk)>;
#[doc = "! A cast function. Must be destroyed with `duckdb_destroy_cast_function`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_cast_function {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_cast_function() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_cast_function> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_cast_function>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_cast_function))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_cast_function>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_cast_function))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_cast_function),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! A cast function. Must be destroyed with `duckdb_destroy_cast_function`."]
pub type duckdb_cast_function = *mut _duckdb_cast_function;
pub type duckdb_cast_function_t = ::std::option::Option<
    unsafe extern "C" fn(info: duckdb_function_info, count: idx_t, input: duckdb_vector, output: duckdb_vector) -> bool,
>;
#[doc = "! Additional replacement scan info. When setting this info, it is necessary to pass a destroy-callback function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_replacement_scan_info {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_replacement_scan_info() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_replacement_scan_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_replacement_scan_info>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_replacement_scan_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_replacement_scan_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_replacement_scan_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_replacement_scan_info),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Additional replacement scan info. When setting this info, it is necessary to pass a destroy-callback function."]
pub type duckdb_replacement_scan_info = *mut _duckdb_replacement_scan_info;
#[doc = "! A replacement scan function that can be added to a database."]
pub type duckdb_replacement_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        info: duckdb_replacement_scan_info,
        table_name: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = "! Holds an arrow query result. Must be destroyed with `duckdb_destroy_arrow`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_arrow {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_arrow() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_arrow> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_arrow>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_arrow))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_arrow>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_arrow))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_arrow),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Holds an arrow query result. Must be destroyed with `duckdb_destroy_arrow`."]
pub type duckdb_arrow = *mut _duckdb_arrow;
#[doc = "! Holds an arrow array stream. Must be destroyed with `duckdb_destroy_arrow_stream`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_arrow_stream {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_arrow_stream() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_arrow_stream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_arrow_stream>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_arrow_stream))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_arrow_stream>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_arrow_stream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_arrow_stream),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Holds an arrow array stream. Must be destroyed with `duckdb_destroy_arrow_stream`."]
pub type duckdb_arrow_stream = *mut _duckdb_arrow_stream;
#[doc = "! Holds an arrow schema. Remember to release the respective ArrowSchema object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_arrow_schema {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_arrow_schema() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_arrow_schema> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_arrow_schema>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_arrow_schema))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_arrow_schema>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_arrow_schema))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_arrow_schema),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Holds an arrow schema. Remember to release the respective ArrowSchema object."]
pub type duckdb_arrow_schema = *mut _duckdb_arrow_schema;
#[doc = "! Holds an arrow array. Remember to release the respective ArrowArray object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _duckdb_arrow_array {
    pub internal_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__duckdb_arrow_array() {
    const UNINIT: ::std::mem::MaybeUninit<_duckdb_arrow_array> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_duckdb_arrow_array>(),
        8usize,
        concat!("Size of: ", stringify!(_duckdb_arrow_array))
    );
    assert_eq!(
        ::std::mem::align_of::<_duckdb_arrow_array>(),
        8usize,
        concat!("Alignment of ", stringify!(_duckdb_arrow_array))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_duckdb_arrow_array),
            "::",
            stringify!(internal_ptr)
        )
    );
}
#[doc = "! Holds an arrow array. Remember to release the respective ArrowArray object."]
pub type duckdb_arrow_array = *mut _duckdb_arrow_array;
#[doc = "! Passed to C API extension as parameter to the entrypoint"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_extension_access {
    #[doc = "! Indicate that an error has occured"]
    pub set_error:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_extension_info, error: *const ::std::os::raw::c_char)>,
    #[doc = "! Fetch the database from duckdb to register extensions to"]
    pub get_database: ::std::option::Option<unsafe extern "C" fn(info: duckdb_extension_info) -> *mut duckdb_database>,
    #[doc = "! Fetch the API"]
    pub get_api: ::std::option::Option<
        unsafe extern "C" fn(
            info: duckdb_extension_info,
            version: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_void,
    >,
}
#[test]
fn bindgen_test_layout_duckdb_extension_access() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_extension_access> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_extension_access>(),
        24usize,
        concat!("Size of: ", stringify!(duckdb_extension_access))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_extension_access>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_extension_access))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_extension_access),
            "::",
            stringify!(set_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_database) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_extension_access),
            "::",
            stringify!(get_database)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_api) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_extension_access),
            "::",
            stringify!(get_api)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct duckdb_ext_api_v0 {
    pub duckdb_open: ::std::option::Option<
        unsafe extern "C" fn(path: *const ::std::os::raw::c_char, out_database: *mut duckdb_database) -> duckdb_state,
    >,
    pub duckdb_open_ext: ::std::option::Option<
        unsafe extern "C" fn(
            path: *const ::std::os::raw::c_char,
            out_database: *mut duckdb_database,
            config: duckdb_config,
            out_error: *mut *mut ::std::os::raw::c_char,
        ) -> duckdb_state,
    >,
    pub duckdb_close: ::std::option::Option<unsafe extern "C" fn(database: *mut duckdb_database)>,
    pub duckdb_connect: ::std::option::Option<
        unsafe extern "C" fn(database: duckdb_database, out_connection: *mut duckdb_connection) -> duckdb_state,
    >,
    pub duckdb_interrupt: ::std::option::Option<unsafe extern "C" fn(connection: duckdb_connection)>,
    pub duckdb_query_progress:
        ::std::option::Option<unsafe extern "C" fn(connection: duckdb_connection) -> duckdb_query_progress_type>,
    pub duckdb_disconnect: ::std::option::Option<unsafe extern "C" fn(connection: *mut duckdb_connection)>,
    pub duckdb_library_version: ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>,
    pub duckdb_create_config:
        ::std::option::Option<unsafe extern "C" fn(out_config: *mut duckdb_config) -> duckdb_state>,
    pub duckdb_config_count: ::std::option::Option<unsafe extern "C" fn() -> usize>,
    pub duckdb_get_config_flag: ::std::option::Option<
        unsafe extern "C" fn(
            index: usize,
            out_name: *mut *const ::std::os::raw::c_char,
            out_description: *mut *const ::std::os::raw::c_char,
        ) -> duckdb_state,
    >,
    pub duckdb_set_config: ::std::option::Option<
        unsafe extern "C" fn(
            config: duckdb_config,
            name: *const ::std::os::raw::c_char,
            option: *const ::std::os::raw::c_char,
        ) -> duckdb_state,
    >,
    pub duckdb_destroy_config: ::std::option::Option<unsafe extern "C" fn(config: *mut duckdb_config)>,
    pub duckdb_query: ::std::option::Option<
        unsafe extern "C" fn(
            connection: duckdb_connection,
            query: *const ::std::os::raw::c_char,
            out_result: *mut duckdb_result,
        ) -> duckdb_state,
    >,
    pub duckdb_destroy_result: ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result)>,
    pub duckdb_column_name: ::std::option::Option<
        unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t) -> *const ::std::os::raw::c_char,
    >,
    pub duckdb_column_type:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t) -> duckdb_type>,
    pub duckdb_result_statement_type:
        ::std::option::Option<unsafe extern "C" fn(result: duckdb_result) -> duckdb_statement_type>,
    pub duckdb_column_logical_type:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t) -> duckdb_logical_type>,
    pub duckdb_column_count: ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result) -> idx_t>,
    pub duckdb_rows_changed: ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result) -> idx_t>,
    pub duckdb_result_error:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result) -> *const ::std::os::raw::c_char>,
    pub duckdb_malloc: ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void>,
    pub duckdb_free: ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>,
    pub duckdb_vector_size: ::std::option::Option<unsafe extern "C" fn() -> idx_t>,
    pub duckdb_string_is_inlined: ::std::option::Option<unsafe extern "C" fn(string: duckdb_string_t) -> bool>,
    pub duckdb_from_date: ::std::option::Option<unsafe extern "C" fn(date: duckdb_date) -> duckdb_date_struct>,
    pub duckdb_to_date: ::std::option::Option<unsafe extern "C" fn(date: duckdb_date_struct) -> duckdb_date>,
    pub duckdb_is_finite_date: ::std::option::Option<unsafe extern "C" fn(date: duckdb_date) -> bool>,
    pub duckdb_from_time: ::std::option::Option<unsafe extern "C" fn(time: duckdb_time) -> duckdb_time_struct>,
    pub duckdb_create_time_tz: ::std::option::Option<unsafe extern "C" fn(micros: i64, offset: i32) -> duckdb_time_tz>,
    pub duckdb_from_time_tz:
        ::std::option::Option<unsafe extern "C" fn(micros: duckdb_time_tz) -> duckdb_time_tz_struct>,
    pub duckdb_to_time: ::std::option::Option<unsafe extern "C" fn(time: duckdb_time_struct) -> duckdb_time>,
    pub duckdb_from_timestamp:
        ::std::option::Option<unsafe extern "C" fn(ts: duckdb_timestamp) -> duckdb_timestamp_struct>,
    pub duckdb_to_timestamp:
        ::std::option::Option<unsafe extern "C" fn(ts: duckdb_timestamp_struct) -> duckdb_timestamp>,
    pub duckdb_is_finite_timestamp: ::std::option::Option<unsafe extern "C" fn(ts: duckdb_timestamp) -> bool>,
    pub duckdb_hugeint_to_double: ::std::option::Option<unsafe extern "C" fn(val: duckdb_hugeint) -> f64>,
    pub duckdb_double_to_hugeint: ::std::option::Option<unsafe extern "C" fn(val: f64) -> duckdb_hugeint>,
    pub duckdb_uhugeint_to_double: ::std::option::Option<unsafe extern "C" fn(val: duckdb_uhugeint) -> f64>,
    pub duckdb_double_to_uhugeint: ::std::option::Option<unsafe extern "C" fn(val: f64) -> duckdb_uhugeint>,
    pub duckdb_double_to_decimal:
        ::std::option::Option<unsafe extern "C" fn(val: f64, width: u8, scale: u8) -> duckdb_decimal>,
    pub duckdb_decimal_to_double: ::std::option::Option<unsafe extern "C" fn(val: duckdb_decimal) -> f64>,
    pub duckdb_prepare: ::std::option::Option<
        unsafe extern "C" fn(
            connection: duckdb_connection,
            query: *const ::std::os::raw::c_char,
            out_prepared_statement: *mut duckdb_prepared_statement,
        ) -> duckdb_state,
    >,
    pub duckdb_destroy_prepare:
        ::std::option::Option<unsafe extern "C" fn(prepared_statement: *mut duckdb_prepared_statement)>,
    pub duckdb_prepare_error: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement) -> *const ::std::os::raw::c_char,
    >,
    pub duckdb_nparams:
        ::std::option::Option<unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement) -> idx_t>,
    pub duckdb_parameter_name: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            index: idx_t,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub duckdb_param_type: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t) -> duckdb_type,
    >,
    pub duckdb_clear_bindings:
        ::std::option::Option<unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement) -> duckdb_state>,
    pub duckdb_prepared_statement_type:
        ::std::option::Option<unsafe extern "C" fn(statement: duckdb_prepared_statement) -> duckdb_statement_type>,
    pub duckdb_bind_value: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: duckdb_value,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_parameter_index: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx_out: *mut idx_t,
            name: *const ::std::os::raw::c_char,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_boolean: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: bool,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_int8: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: i8) -> duckdb_state,
    >,
    pub duckdb_bind_int16: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: i16) -> duckdb_state,
    >,
    pub duckdb_bind_int32: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: i32) -> duckdb_state,
    >,
    pub duckdb_bind_int64: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: i64) -> duckdb_state,
    >,
    pub duckdb_bind_hugeint: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: duckdb_hugeint,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_uhugeint: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: duckdb_uhugeint,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_decimal: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: duckdb_decimal,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_uint8: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: u8) -> duckdb_state,
    >,
    pub duckdb_bind_uint16: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: u16) -> duckdb_state,
    >,
    pub duckdb_bind_uint32: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: u32) -> duckdb_state,
    >,
    pub duckdb_bind_uint64: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: u64) -> duckdb_state,
    >,
    pub duckdb_bind_float: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: f32) -> duckdb_state,
    >,
    pub duckdb_bind_double: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t, val: f64) -> duckdb_state,
    >,
    pub duckdb_bind_date: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: duckdb_date,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_time: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: duckdb_time,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_timestamp: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: duckdb_timestamp,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_timestamp_tz: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: duckdb_timestamp,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_interval: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: duckdb_interval,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_varchar: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: *const ::std::os::raw::c_char,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_varchar_length: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            val: *const ::std::os::raw::c_char,
            length: idx_t,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_blob: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            param_idx: idx_t,
            data: *const ::std::os::raw::c_void,
            length: idx_t,
        ) -> duckdb_state,
    >,
    pub duckdb_bind_null: ::std::option::Option<
        unsafe extern "C" fn(prepared_statement: duckdb_prepared_statement, param_idx: idx_t) -> duckdb_state,
    >,
    pub duckdb_execute_prepared: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            out_result: *mut duckdb_result,
        ) -> duckdb_state,
    >,
    pub duckdb_extract_statements: ::std::option::Option<
        unsafe extern "C" fn(
            connection: duckdb_connection,
            query: *const ::std::os::raw::c_char,
            out_extracted_statements: *mut duckdb_extracted_statements,
        ) -> idx_t,
    >,
    pub duckdb_prepare_extracted_statement: ::std::option::Option<
        unsafe extern "C" fn(
            connection: duckdb_connection,
            extracted_statements: duckdb_extracted_statements,
            index: idx_t,
            out_prepared_statement: *mut duckdb_prepared_statement,
        ) -> duckdb_state,
    >,
    pub duckdb_extract_statements_error: ::std::option::Option<
        unsafe extern "C" fn(extracted_statements: duckdb_extracted_statements) -> *const ::std::os::raw::c_char,
    >,
    pub duckdb_destroy_extracted:
        ::std::option::Option<unsafe extern "C" fn(extracted_statements: *mut duckdb_extracted_statements)>,
    pub duckdb_pending_prepared: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            out_result: *mut duckdb_pending_result,
        ) -> duckdb_state,
    >,
    pub duckdb_destroy_pending: ::std::option::Option<unsafe extern "C" fn(pending_result: *mut duckdb_pending_result)>,
    pub duckdb_pending_error: ::std::option::Option<
        unsafe extern "C" fn(pending_result: duckdb_pending_result) -> *const ::std::os::raw::c_char,
    >,
    pub duckdb_pending_execute_task:
        ::std::option::Option<unsafe extern "C" fn(pending_result: duckdb_pending_result) -> duckdb_pending_state>,
    pub duckdb_pending_execute_check_state:
        ::std::option::Option<unsafe extern "C" fn(pending_result: duckdb_pending_result) -> duckdb_pending_state>,
    pub duckdb_execute_pending: ::std::option::Option<
        unsafe extern "C" fn(pending_result: duckdb_pending_result, out_result: *mut duckdb_result) -> duckdb_state,
    >,
    pub duckdb_pending_execution_is_finished:
        ::std::option::Option<unsafe extern "C" fn(pending_state: duckdb_pending_state) -> bool>,
    pub duckdb_destroy_value: ::std::option::Option<unsafe extern "C" fn(value: *mut duckdb_value)>,
    pub duckdb_create_varchar:
        ::std::option::Option<unsafe extern "C" fn(text: *const ::std::os::raw::c_char) -> duckdb_value>,
    pub duckdb_create_varchar_length:
        ::std::option::Option<unsafe extern "C" fn(text: *const ::std::os::raw::c_char, length: idx_t) -> duckdb_value>,
    pub duckdb_create_int64: ::std::option::Option<unsafe extern "C" fn(val: i64) -> duckdb_value>,
    pub duckdb_create_struct_value: ::std::option::Option<
        unsafe extern "C" fn(type_: duckdb_logical_type, values: *mut duckdb_value) -> duckdb_value,
    >,
    pub duckdb_create_list_value: ::std::option::Option<
        unsafe extern "C" fn(type_: duckdb_logical_type, values: *mut duckdb_value, value_count: idx_t) -> duckdb_value,
    >,
    pub duckdb_create_array_value: ::std::option::Option<
        unsafe extern "C" fn(type_: duckdb_logical_type, values: *mut duckdb_value, value_count: idx_t) -> duckdb_value,
    >,
    pub duckdb_get_varchar:
        ::std::option::Option<unsafe extern "C" fn(value: duckdb_value) -> *mut ::std::os::raw::c_char>,
    pub duckdb_get_int64: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> i64>,
    pub duckdb_create_logical_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_type) -> duckdb_logical_type>,
    pub duckdb_logical_type_get_alias:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> *mut ::std::os::raw::c_char>,
    pub duckdb_create_list_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type>,
    pub duckdb_create_array_type: ::std::option::Option<
        unsafe extern "C" fn(type_: duckdb_logical_type, array_size: idx_t) -> duckdb_logical_type,
    >,
    pub duckdb_create_map_type: ::std::option::Option<
        unsafe extern "C" fn(key_type: duckdb_logical_type, value_type: duckdb_logical_type) -> duckdb_logical_type,
    >,
    pub duckdb_create_union_type: ::std::option::Option<
        unsafe extern "C" fn(
            member_types: *mut duckdb_logical_type,
            member_names: *mut *const ::std::os::raw::c_char,
            member_count: idx_t,
        ) -> duckdb_logical_type,
    >,
    pub duckdb_create_struct_type: ::std::option::Option<
        unsafe extern "C" fn(
            member_types: *mut duckdb_logical_type,
            member_names: *mut *const ::std::os::raw::c_char,
            member_count: idx_t,
        ) -> duckdb_logical_type,
    >,
    pub duckdb_create_enum_type: ::std::option::Option<
        unsafe extern "C" fn(
            member_names: *mut *const ::std::os::raw::c_char,
            member_count: idx_t,
        ) -> duckdb_logical_type,
    >,
    pub duckdb_create_decimal_type:
        ::std::option::Option<unsafe extern "C" fn(width: u8, scale: u8) -> duckdb_logical_type>,
    pub duckdb_get_type_id: ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_type>,
    pub duckdb_decimal_width: ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> u8>,
    pub duckdb_decimal_scale: ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> u8>,
    pub duckdb_decimal_internal_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_type>,
    pub duckdb_enum_internal_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_type>,
    pub duckdb_enum_dictionary_size: ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> u32>,
    pub duckdb_enum_dictionary_value: ::std::option::Option<
        unsafe extern "C" fn(type_: duckdb_logical_type, index: idx_t) -> *mut ::std::os::raw::c_char,
    >,
    pub duckdb_list_type_child_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type>,
    pub duckdb_array_type_child_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type>,
    pub duckdb_array_type_array_size: ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> idx_t>,
    pub duckdb_map_type_key_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type>,
    pub duckdb_map_type_value_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type>,
    pub duckdb_struct_type_child_count:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> idx_t>,
    pub duckdb_struct_type_child_name: ::std::option::Option<
        unsafe extern "C" fn(type_: duckdb_logical_type, index: idx_t) -> *mut ::std::os::raw::c_char,
    >,
    pub duckdb_struct_type_child_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type, index: idx_t) -> duckdb_logical_type>,
    pub duckdb_union_type_member_count:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type) -> idx_t>,
    pub duckdb_union_type_member_name: ::std::option::Option<
        unsafe extern "C" fn(type_: duckdb_logical_type, index: idx_t) -> *mut ::std::os::raw::c_char,
    >,
    pub duckdb_union_type_member_type:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type, index: idx_t) -> duckdb_logical_type>,
    pub duckdb_destroy_logical_type: ::std::option::Option<unsafe extern "C" fn(type_: *mut duckdb_logical_type)>,
    pub duckdb_fetch_chunk: ::std::option::Option<unsafe extern "C" fn(result: duckdb_result) -> duckdb_data_chunk>,
    pub duckdb_create_data_chunk: ::std::option::Option<
        unsafe extern "C" fn(types: *mut duckdb_logical_type, column_count: idx_t) -> duckdb_data_chunk,
    >,
    pub duckdb_destroy_data_chunk: ::std::option::Option<unsafe extern "C" fn(chunk: *mut duckdb_data_chunk)>,
    pub duckdb_data_chunk_reset: ::std::option::Option<unsafe extern "C" fn(chunk: duckdb_data_chunk)>,
    pub duckdb_data_chunk_get_column_count:
        ::std::option::Option<unsafe extern "C" fn(chunk: duckdb_data_chunk) -> idx_t>,
    pub duckdb_data_chunk_get_vector:
        ::std::option::Option<unsafe extern "C" fn(chunk: duckdb_data_chunk, col_idx: idx_t) -> duckdb_vector>,
    pub duckdb_data_chunk_get_size: ::std::option::Option<unsafe extern "C" fn(chunk: duckdb_data_chunk) -> idx_t>,
    pub duckdb_data_chunk_set_size: ::std::option::Option<unsafe extern "C" fn(chunk: duckdb_data_chunk, size: idx_t)>,
    pub duckdb_vector_get_column_type:
        ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector) -> duckdb_logical_type>,
    pub duckdb_vector_get_data:
        ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector) -> *mut ::std::os::raw::c_void>,
    pub duckdb_vector_get_validity: ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector) -> *mut u64>,
    pub duckdb_vector_ensure_validity_writable: ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector)>,
    pub duckdb_vector_assign_string_element: ::std::option::Option<
        unsafe extern "C" fn(vector: duckdb_vector, index: idx_t, str_: *const ::std::os::raw::c_char),
    >,
    pub duckdb_vector_assign_string_element_len: ::std::option::Option<
        unsafe extern "C" fn(vector: duckdb_vector, index: idx_t, str_: *const ::std::os::raw::c_char, str_len: idx_t),
    >,
    pub duckdb_list_vector_get_child:
        ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector) -> duckdb_vector>,
    pub duckdb_list_vector_get_size: ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector) -> idx_t>,
    pub duckdb_list_vector_set_size:
        ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector, size: idx_t) -> duckdb_state>,
    pub duckdb_list_vector_reserve:
        ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector, required_capacity: idx_t) -> duckdb_state>,
    pub duckdb_struct_vector_get_child:
        ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector, index: idx_t) -> duckdb_vector>,
    pub duckdb_array_vector_get_child:
        ::std::option::Option<unsafe extern "C" fn(vector: duckdb_vector) -> duckdb_vector>,
    pub duckdb_validity_row_is_valid:
        ::std::option::Option<unsafe extern "C" fn(validity: *mut u64, row: idx_t) -> bool>,
    pub duckdb_validity_set_row_validity:
        ::std::option::Option<unsafe extern "C" fn(validity: *mut u64, row: idx_t, valid: bool)>,
    pub duckdb_validity_set_row_invalid: ::std::option::Option<unsafe extern "C" fn(validity: *mut u64, row: idx_t)>,
    pub duckdb_validity_set_row_valid: ::std::option::Option<unsafe extern "C" fn(validity: *mut u64, row: idx_t)>,
    pub duckdb_create_scalar_function: ::std::option::Option<unsafe extern "C" fn() -> duckdb_scalar_function>,
    pub duckdb_destroy_scalar_function:
        ::std::option::Option<unsafe extern "C" fn(scalar_function: *mut duckdb_scalar_function)>,
    pub duckdb_scalar_function_set_name: ::std::option::Option<
        unsafe extern "C" fn(scalar_function: duckdb_scalar_function, name: *const ::std::os::raw::c_char),
    >,
    pub duckdb_scalar_function_add_parameter: ::std::option::Option<
        unsafe extern "C" fn(scalar_function: duckdb_scalar_function, type_: duckdb_logical_type),
    >,
    pub duckdb_scalar_function_set_return_type: ::std::option::Option<
        unsafe extern "C" fn(scalar_function: duckdb_scalar_function, type_: duckdb_logical_type),
    >,
    pub duckdb_scalar_function_set_extra_info: ::std::option::Option<
        unsafe extern "C" fn(
            scalar_function: duckdb_scalar_function,
            extra_info: *mut ::std::os::raw::c_void,
            destroy: duckdb_delete_callback_t,
        ),
    >,
    pub duckdb_scalar_function_set_function: ::std::option::Option<
        unsafe extern "C" fn(scalar_function: duckdb_scalar_function, function: duckdb_scalar_function_t),
    >,
    pub duckdb_register_scalar_function: ::std::option::Option<
        unsafe extern "C" fn(con: duckdb_connection, scalar_function: duckdb_scalar_function) -> duckdb_state,
    >,
    pub duckdb_create_table_function: ::std::option::Option<unsafe extern "C" fn() -> duckdb_table_function>,
    pub duckdb_destroy_table_function:
        ::std::option::Option<unsafe extern "C" fn(table_function: *mut duckdb_table_function)>,
    pub duckdb_table_function_set_name: ::std::option::Option<
        unsafe extern "C" fn(table_function: duckdb_table_function, name: *const ::std::os::raw::c_char),
    >,
    pub duckdb_table_function_add_parameter:
        ::std::option::Option<unsafe extern "C" fn(table_function: duckdb_table_function, type_: duckdb_logical_type)>,
    pub duckdb_table_function_add_named_parameter: ::std::option::Option<
        unsafe extern "C" fn(
            table_function: duckdb_table_function,
            name: *const ::std::os::raw::c_char,
            type_: duckdb_logical_type,
        ),
    >,
    pub duckdb_table_function_set_extra_info: ::std::option::Option<
        unsafe extern "C" fn(
            table_function: duckdb_table_function,
            extra_info: *mut ::std::os::raw::c_void,
            destroy: duckdb_delete_callback_t,
        ),
    >,
    pub duckdb_table_function_set_bind: ::std::option::Option<
        unsafe extern "C" fn(table_function: duckdb_table_function, bind: duckdb_table_function_bind_t),
    >,
    pub duckdb_table_function_set_init: ::std::option::Option<
        unsafe extern "C" fn(table_function: duckdb_table_function, init: duckdb_table_function_init_t),
    >,
    pub duckdb_table_function_set_local_init: ::std::option::Option<
        unsafe extern "C" fn(table_function: duckdb_table_function, init: duckdb_table_function_init_t),
    >,
    pub duckdb_table_function_set_function: ::std::option::Option<
        unsafe extern "C" fn(table_function: duckdb_table_function, function: duckdb_table_function_t),
    >,
    pub duckdb_table_function_supports_projection_pushdown:
        ::std::option::Option<unsafe extern "C" fn(table_function: duckdb_table_function, pushdown: bool)>,
    pub duckdb_register_table_function: ::std::option::Option<
        unsafe extern "C" fn(con: duckdb_connection, function: duckdb_table_function) -> duckdb_state,
    >,
    pub duckdb_bind_get_extra_info:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_bind_info) -> *mut ::std::os::raw::c_void>,
    pub duckdb_bind_add_result_column: ::std::option::Option<
        unsafe extern "C" fn(info: duckdb_bind_info, name: *const ::std::os::raw::c_char, type_: duckdb_logical_type),
    >,
    pub duckdb_bind_get_parameter_count: ::std::option::Option<unsafe extern "C" fn(info: duckdb_bind_info) -> idx_t>,
    pub duckdb_bind_get_parameter:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_bind_info, index: idx_t) -> duckdb_value>,
    pub duckdb_bind_get_named_parameter: ::std::option::Option<
        unsafe extern "C" fn(info: duckdb_bind_info, name: *const ::std::os::raw::c_char) -> duckdb_value,
    >,
    pub duckdb_bind_set_bind_data: ::std::option::Option<
        unsafe extern "C" fn(
            info: duckdb_bind_info,
            bind_data: *mut ::std::os::raw::c_void,
            destroy: duckdb_delete_callback_t,
        ),
    >,
    pub duckdb_bind_set_cardinality:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_bind_info, cardinality: idx_t, is_exact: bool)>,
    pub duckdb_bind_set_error:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_bind_info, error: *const ::std::os::raw::c_char)>,
    pub duckdb_init_get_extra_info:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_init_info) -> *mut ::std::os::raw::c_void>,
    pub duckdb_init_get_bind_data:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_init_info) -> *mut ::std::os::raw::c_void>,
    pub duckdb_init_set_init_data: ::std::option::Option<
        unsafe extern "C" fn(
            info: duckdb_init_info,
            init_data: *mut ::std::os::raw::c_void,
            destroy: duckdb_delete_callback_t,
        ),
    >,
    pub duckdb_init_get_column_count: ::std::option::Option<unsafe extern "C" fn(info: duckdb_init_info) -> idx_t>,
    pub duckdb_init_get_column_index:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_init_info, column_index: idx_t) -> idx_t>,
    pub duckdb_init_set_max_threads:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_init_info, max_threads: idx_t)>,
    pub duckdb_init_set_error:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_init_info, error: *const ::std::os::raw::c_char)>,
    pub duckdb_function_get_extra_info:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info) -> *mut ::std::os::raw::c_void>,
    pub duckdb_function_get_bind_data:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info) -> *mut ::std::os::raw::c_void>,
    pub duckdb_function_get_init_data:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info) -> *mut ::std::os::raw::c_void>,
    pub duckdb_function_get_local_init_data:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info) -> *mut ::std::os::raw::c_void>,
    pub duckdb_function_set_error:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info, error: *const ::std::os::raw::c_char)>,
    pub duckdb_add_replacement_scan: ::std::option::Option<
        unsafe extern "C" fn(
            db: duckdb_database,
            replacement: duckdb_replacement_callback_t,
            extra_data: *mut ::std::os::raw::c_void,
            delete_callback: duckdb_delete_callback_t,
        ),
    >,
    pub duckdb_replacement_scan_set_function_name: ::std::option::Option<
        unsafe extern "C" fn(info: duckdb_replacement_scan_info, function_name: *const ::std::os::raw::c_char),
    >,
    pub duckdb_replacement_scan_add_parameter:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_replacement_scan_info, parameter: duckdb_value)>,
    pub duckdb_replacement_scan_set_error: ::std::option::Option<
        unsafe extern "C" fn(info: duckdb_replacement_scan_info, error: *const ::std::os::raw::c_char),
    >,
    pub duckdb_appender_create: ::std::option::Option<
        unsafe extern "C" fn(
            connection: duckdb_connection,
            schema: *const ::std::os::raw::c_char,
            table: *const ::std::os::raw::c_char,
            out_appender: *mut duckdb_appender,
        ) -> duckdb_state,
    >,
    pub duckdb_appender_column_count: ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender) -> idx_t>,
    pub duckdb_appender_column_type:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, col_idx: idx_t) -> duckdb_logical_type>,
    pub duckdb_appender_error:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender) -> *const ::std::os::raw::c_char>,
    pub duckdb_appender_flush: ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state>,
    pub duckdb_appender_close: ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state>,
    pub duckdb_appender_destroy:
        ::std::option::Option<unsafe extern "C" fn(appender: *mut duckdb_appender) -> duckdb_state>,
    pub duckdb_appender_begin_row:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state>,
    pub duckdb_appender_end_row: ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state>,
    pub duckdb_append_default: ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state>,
    pub duckdb_append_bool:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: bool) -> duckdb_state>,
    pub duckdb_append_int8:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: i8) -> duckdb_state>,
    pub duckdb_append_int16:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: i16) -> duckdb_state>,
    pub duckdb_append_int32:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: i32) -> duckdb_state>,
    pub duckdb_append_int64:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: i64) -> duckdb_state>,
    pub duckdb_append_hugeint:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: duckdb_hugeint) -> duckdb_state>,
    pub duckdb_append_uint8:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: u8) -> duckdb_state>,
    pub duckdb_append_uint16:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: u16) -> duckdb_state>,
    pub duckdb_append_uint32:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: u32) -> duckdb_state>,
    pub duckdb_append_uint64:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: u64) -> duckdb_state>,
    pub duckdb_append_uhugeint:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: duckdb_uhugeint) -> duckdb_state>,
    pub duckdb_append_float:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: f32) -> duckdb_state>,
    pub duckdb_append_double:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: f64) -> duckdb_state>,
    pub duckdb_append_date:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: duckdb_date) -> duckdb_state>,
    pub duckdb_append_time:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: duckdb_time) -> duckdb_state>,
    pub duckdb_append_timestamp:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: duckdb_timestamp) -> duckdb_state>,
    pub duckdb_append_interval:
        ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender, value: duckdb_interval) -> duckdb_state>,
    pub duckdb_append_varchar: ::std::option::Option<
        unsafe extern "C" fn(appender: duckdb_appender, val: *const ::std::os::raw::c_char) -> duckdb_state,
    >,
    pub duckdb_append_varchar_length: ::std::option::Option<
        unsafe extern "C" fn(
            appender: duckdb_appender,
            val: *const ::std::os::raw::c_char,
            length: idx_t,
        ) -> duckdb_state,
    >,
    pub duckdb_append_blob: ::std::option::Option<
        unsafe extern "C" fn(
            appender: duckdb_appender,
            data: *const ::std::os::raw::c_void,
            length: idx_t,
        ) -> duckdb_state,
    >,
    pub duckdb_append_null: ::std::option::Option<unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state>,
    pub duckdb_append_data_chunk: ::std::option::Option<
        unsafe extern "C" fn(appender: duckdb_appender, chunk: duckdb_data_chunk) -> duckdb_state,
    >,
    pub duckdb_execute_tasks: ::std::option::Option<unsafe extern "C" fn(database: duckdb_database, max_tasks: idx_t)>,
    pub duckdb_create_task_state:
        ::std::option::Option<unsafe extern "C" fn(database: duckdb_database) -> duckdb_task_state>,
    pub duckdb_execute_tasks_state: ::std::option::Option<unsafe extern "C" fn(state: duckdb_task_state)>,
    pub duckdb_execute_n_tasks_state:
        ::std::option::Option<unsafe extern "C" fn(state: duckdb_task_state, max_tasks: idx_t) -> idx_t>,
    pub duckdb_finish_execution: ::std::option::Option<unsafe extern "C" fn(state: duckdb_task_state)>,
    pub duckdb_task_state_is_finished: ::std::option::Option<unsafe extern "C" fn(state: duckdb_task_state) -> bool>,
    pub duckdb_destroy_task_state: ::std::option::Option<unsafe extern "C" fn(state: duckdb_task_state)>,
    pub duckdb_execution_is_finished: ::std::option::Option<unsafe extern "C" fn(con: duckdb_connection) -> bool>,
    pub duckdb_get_profiling_info:
        ::std::option::Option<unsafe extern "C" fn(connection: duckdb_connection) -> duckdb_profiling_info>,
    pub duckdb_profiling_info_get_value: ::std::option::Option<
        unsafe extern "C" fn(info: duckdb_profiling_info, key: *const ::std::os::raw::c_char) -> duckdb_value,
    >,
    pub duckdb_profiling_info_get_child_count:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_profiling_info) -> idx_t>,
    pub duckdb_profiling_info_get_child:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_profiling_info, index: idx_t) -> duckdb_profiling_info>,
    pub duckdb_profiling_info_get_metrics:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_profiling_info) -> duckdb_value>,
    pub duckdb_scalar_function_set_varargs: ::std::option::Option<
        unsafe extern "C" fn(scalar_function: duckdb_scalar_function, type_: duckdb_logical_type),
    >,
    pub duckdb_scalar_function_set_special_handling:
        ::std::option::Option<unsafe extern "C" fn(scalar_function: duckdb_scalar_function)>,
    pub duckdb_scalar_function_set_volatile:
        ::std::option::Option<unsafe extern "C" fn(scalar_function: duckdb_scalar_function)>,
    pub duckdb_scalar_function_get_extra_info:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info) -> *mut ::std::os::raw::c_void>,
    pub duckdb_scalar_function_set_error:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info, error: *const ::std::os::raw::c_char)>,
    pub duckdb_table_description_create: ::std::option::Option<
        unsafe extern "C" fn(
            connection: duckdb_connection,
            schema: *const ::std::os::raw::c_char,
            table: *const ::std::os::raw::c_char,
            out: *mut duckdb_table_description,
        ) -> duckdb_state,
    >,
    pub duckdb_table_description_destroy:
        ::std::option::Option<unsafe extern "C" fn(table_description: *mut duckdb_table_description)>,
    pub duckdb_table_description_error: ::std::option::Option<
        unsafe extern "C" fn(table_description: duckdb_table_description) -> *const ::std::os::raw::c_char,
    >,
    pub duckdb_result_error_type:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result) -> duckdb_error_type>,
    pub duckdb_string_t_length: ::std::option::Option<unsafe extern "C" fn(string: duckdb_string_t) -> u32>,
    pub duckdb_string_t_data:
        ::std::option::Option<unsafe extern "C" fn(string: *mut duckdb_string_t) -> *const ::std::os::raw::c_char>,
    pub duckdb_create_bool: ::std::option::Option<unsafe extern "C" fn(input: bool) -> duckdb_value>,
    pub duckdb_create_int8: ::std::option::Option<unsafe extern "C" fn(input: i8) -> duckdb_value>,
    pub duckdb_create_uint8: ::std::option::Option<unsafe extern "C" fn(input: u8) -> duckdb_value>,
    pub duckdb_create_int16: ::std::option::Option<unsafe extern "C" fn(input: i16) -> duckdb_value>,
    pub duckdb_create_uint16: ::std::option::Option<unsafe extern "C" fn(input: u16) -> duckdb_value>,
    pub duckdb_create_int32: ::std::option::Option<unsafe extern "C" fn(input: i32) -> duckdb_value>,
    pub duckdb_create_uint32: ::std::option::Option<unsafe extern "C" fn(input: u32) -> duckdb_value>,
    pub duckdb_create_uint64: ::std::option::Option<unsafe extern "C" fn(input: u64) -> duckdb_value>,
    pub duckdb_create_hugeint: ::std::option::Option<unsafe extern "C" fn(input: duckdb_hugeint) -> duckdb_value>,
    pub duckdb_create_uhugeint: ::std::option::Option<unsafe extern "C" fn(input: duckdb_uhugeint) -> duckdb_value>,
    pub duckdb_create_float: ::std::option::Option<unsafe extern "C" fn(input: f32) -> duckdb_value>,
    pub duckdb_create_double: ::std::option::Option<unsafe extern "C" fn(input: f64) -> duckdb_value>,
    pub duckdb_create_date: ::std::option::Option<unsafe extern "C" fn(input: duckdb_date) -> duckdb_value>,
    pub duckdb_create_time: ::std::option::Option<unsafe extern "C" fn(input: duckdb_time) -> duckdb_value>,
    pub duckdb_create_time_tz_value: ::std::option::Option<unsafe extern "C" fn(value: duckdb_time_tz) -> duckdb_value>,
    pub duckdb_create_timestamp: ::std::option::Option<unsafe extern "C" fn(input: duckdb_timestamp) -> duckdb_value>,
    pub duckdb_create_interval: ::std::option::Option<unsafe extern "C" fn(input: duckdb_interval) -> duckdb_value>,
    pub duckdb_create_blob: ::std::option::Option<unsafe extern "C" fn(data: *const u8, length: idx_t) -> duckdb_value>,
    pub duckdb_get_bool: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> bool>,
    pub duckdb_get_int8: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> i8>,
    pub duckdb_get_uint8: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> u8>,
    pub duckdb_get_int16: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> i16>,
    pub duckdb_get_uint16: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> u16>,
    pub duckdb_get_int32: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> i32>,
    pub duckdb_get_uint32: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> u32>,
    pub duckdb_get_uint64: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> u64>,
    pub duckdb_get_hugeint: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> duckdb_hugeint>,
    pub duckdb_get_uhugeint: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> duckdb_uhugeint>,
    pub duckdb_get_float: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> f32>,
    pub duckdb_get_double: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> f64>,
    pub duckdb_get_date: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> duckdb_date>,
    pub duckdb_get_time: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> duckdb_time>,
    pub duckdb_get_time_tz: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> duckdb_time_tz>,
    pub duckdb_get_timestamp: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> duckdb_timestamp>,
    pub duckdb_get_interval: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> duckdb_interval>,
    pub duckdb_get_value_type: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> duckdb_logical_type>,
    pub duckdb_get_blob: ::std::option::Option<unsafe extern "C" fn(val: duckdb_value) -> duckdb_blob>,
    pub duckdb_create_scalar_function_set:
        ::std::option::Option<unsafe extern "C" fn(name: *const ::std::os::raw::c_char) -> duckdb_scalar_function_set>,
    pub duckdb_destroy_scalar_function_set:
        ::std::option::Option<unsafe extern "C" fn(scalar_function_set: *mut duckdb_scalar_function_set)>,
    pub duckdb_add_scalar_function_to_set: ::std::option::Option<
        unsafe extern "C" fn(set: duckdb_scalar_function_set, function: duckdb_scalar_function) -> duckdb_state,
    >,
    pub duckdb_register_scalar_function_set: ::std::option::Option<
        unsafe extern "C" fn(con: duckdb_connection, set: duckdb_scalar_function_set) -> duckdb_state,
    >,
    pub duckdb_create_aggregate_function_set: ::std::option::Option<
        unsafe extern "C" fn(name: *const ::std::os::raw::c_char) -> duckdb_aggregate_function_set,
    >,
    pub duckdb_destroy_aggregate_function_set:
        ::std::option::Option<unsafe extern "C" fn(aggregate_function_set: *mut duckdb_aggregate_function_set)>,
    pub duckdb_add_aggregate_function_to_set: ::std::option::Option<
        unsafe extern "C" fn(set: duckdb_aggregate_function_set, function: duckdb_aggregate_function) -> duckdb_state,
    >,
    pub duckdb_register_aggregate_function_set: ::std::option::Option<
        unsafe extern "C" fn(con: duckdb_connection, set: duckdb_aggregate_function_set) -> duckdb_state,
    >,
    pub duckdb_get_map_size: ::std::option::Option<unsafe extern "C" fn(value: duckdb_value) -> idx_t>,
    pub duckdb_get_map_key:
        ::std::option::Option<unsafe extern "C" fn(value: duckdb_value, index: idx_t) -> duckdb_value>,
    pub duckdb_get_map_value:
        ::std::option::Option<unsafe extern "C" fn(value: duckdb_value, index: idx_t) -> duckdb_value>,
    pub duckdb_create_aggregate_function: ::std::option::Option<unsafe extern "C" fn() -> duckdb_aggregate_function>,
    pub duckdb_destroy_aggregate_function:
        ::std::option::Option<unsafe extern "C" fn(aggregate_function: *mut duckdb_aggregate_function)>,
    pub duckdb_aggregate_function_set_name: ::std::option::Option<
        unsafe extern "C" fn(aggregate_function: duckdb_aggregate_function, name: *const ::std::os::raw::c_char),
    >,
    pub duckdb_aggregate_function_add_parameter: ::std::option::Option<
        unsafe extern "C" fn(aggregate_function: duckdb_aggregate_function, type_: duckdb_logical_type),
    >,
    pub duckdb_aggregate_function_set_return_type: ::std::option::Option<
        unsafe extern "C" fn(aggregate_function: duckdb_aggregate_function, type_: duckdb_logical_type),
    >,
    pub duckdb_aggregate_function_set_functions: ::std::option::Option<
        unsafe extern "C" fn(
            aggregate_function: duckdb_aggregate_function,
            state_size: duckdb_aggregate_state_size,
            state_init: duckdb_aggregate_init_t,
            update: duckdb_aggregate_update_t,
            combine: duckdb_aggregate_combine_t,
            finalize: duckdb_aggregate_finalize_t,
        ),
    >,
    pub duckdb_aggregate_function_set_destructor: ::std::option::Option<
        unsafe extern "C" fn(aggregate_function: duckdb_aggregate_function, destroy: duckdb_aggregate_destroy_t),
    >,
    pub duckdb_register_aggregate_function: ::std::option::Option<
        unsafe extern "C" fn(con: duckdb_connection, aggregate_function: duckdb_aggregate_function) -> duckdb_state,
    >,
    pub duckdb_aggregate_function_set_special_handling:
        ::std::option::Option<unsafe extern "C" fn(aggregate_function: duckdb_aggregate_function)>,
    pub duckdb_aggregate_function_set_extra_info: ::std::option::Option<
        unsafe extern "C" fn(
            aggregate_function: duckdb_aggregate_function,
            extra_info: *mut ::std::os::raw::c_void,
            destroy: duckdb_delete_callback_t,
        ),
    >,
    pub duckdb_aggregate_function_get_extra_info:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info) -> *mut ::std::os::raw::c_void>,
    pub duckdb_aggregate_function_set_error:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info, error: *const ::std::os::raw::c_char)>,
    pub duckdb_logical_type_set_alias:
        ::std::option::Option<unsafe extern "C" fn(type_: duckdb_logical_type, alias: *const ::std::os::raw::c_char)>,
    pub duckdb_register_logical_type: ::std::option::Option<
        unsafe extern "C" fn(
            con: duckdb_connection,
            type_: duckdb_logical_type,
            info: duckdb_create_type_info,
        ) -> duckdb_state,
    >,
    pub duckdb_create_cast_function: ::std::option::Option<unsafe extern "C" fn() -> duckdb_cast_function>,
    pub duckdb_cast_function_set_source_type: ::std::option::Option<
        unsafe extern "C" fn(cast_function: duckdb_cast_function, source_type: duckdb_logical_type),
    >,
    pub duckdb_cast_function_set_target_type: ::std::option::Option<
        unsafe extern "C" fn(cast_function: duckdb_cast_function, target_type: duckdb_logical_type),
    >,
    pub duckdb_cast_function_set_implicit_cast_cost:
        ::std::option::Option<unsafe extern "C" fn(cast_function: duckdb_cast_function, cost: i64)>,
    pub duckdb_cast_function_set_function: ::std::option::Option<
        unsafe extern "C" fn(cast_function: duckdb_cast_function, function: duckdb_cast_function_t),
    >,
    pub duckdb_cast_function_set_extra_info: ::std::option::Option<
        unsafe extern "C" fn(
            cast_function: duckdb_cast_function,
            extra_info: *mut ::std::os::raw::c_void,
            destroy: duckdb_delete_callback_t,
        ),
    >,
    pub duckdb_cast_function_get_extra_info:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info) -> *mut ::std::os::raw::c_void>,
    pub duckdb_cast_function_get_cast_mode:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info) -> duckdb_cast_mode>,
    pub duckdb_cast_function_set_error:
        ::std::option::Option<unsafe extern "C" fn(info: duckdb_function_info, error: *const ::std::os::raw::c_char)>,
    pub duckdb_cast_function_set_row_error: ::std::option::Option<
        unsafe extern "C" fn(
            info: duckdb_function_info,
            error: *const ::std::os::raw::c_char,
            row: idx_t,
            output: duckdb_vector,
        ),
    >,
    pub duckdb_register_cast_function: ::std::option::Option<
        unsafe extern "C" fn(con: duckdb_connection, cast_function: duckdb_cast_function) -> duckdb_state,
    >,
    pub duckdb_destroy_cast_function:
        ::std::option::Option<unsafe extern "C" fn(cast_function: *mut duckdb_cast_function)>,
    pub duckdb_row_count: ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result) -> idx_t>,
    pub duckdb_column_data: ::std::option::Option<
        unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t) -> *mut ::std::os::raw::c_void,
    >,
    pub duckdb_nullmask_data:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t) -> *mut bool>,
    pub duckdb_result_get_chunk:
        ::std::option::Option<unsafe extern "C" fn(result: duckdb_result, chunk_index: idx_t) -> duckdb_data_chunk>,
    pub duckdb_result_is_streaming: ::std::option::Option<unsafe extern "C" fn(result: duckdb_result) -> bool>,
    pub duckdb_result_chunk_count: ::std::option::Option<unsafe extern "C" fn(result: duckdb_result) -> idx_t>,
    pub duckdb_result_return_type:
        ::std::option::Option<unsafe extern "C" fn(result: duckdb_result) -> duckdb_result_type>,
    pub duckdb_value_boolean:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> bool>,
    pub duckdb_value_int8:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> i8>,
    pub duckdb_value_int16:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> i16>,
    pub duckdb_value_int32:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> i32>,
    pub duckdb_value_int64:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> i64>,
    pub duckdb_value_hugeint: ::std::option::Option<
        unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_hugeint,
    >,
    pub duckdb_value_uhugeint: ::std::option::Option<
        unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_uhugeint,
    >,
    pub duckdb_value_decimal: ::std::option::Option<
        unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_decimal,
    >,
    pub duckdb_value_uint8:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> u8>,
    pub duckdb_value_uint16:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> u16>,
    pub duckdb_value_uint32:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> u32>,
    pub duckdb_value_uint64:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> u64>,
    pub duckdb_value_float:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> f32>,
    pub duckdb_value_double:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> f64>,
    pub duckdb_value_date:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_date>,
    pub duckdb_value_time:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_time>,
    pub duckdb_value_timestamp: ::std::option::Option<
        unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_timestamp,
    >,
    pub duckdb_value_interval: ::std::option::Option<
        unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_interval,
    >,
    pub duckdb_value_varchar: ::std::option::Option<
        unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> *mut ::std::os::raw::c_char,
    >,
    pub duckdb_value_string: ::std::option::Option<
        unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_string,
    >,
    pub duckdb_value_varchar_internal: ::std::option::Option<
        unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> *mut ::std::os::raw::c_char,
    >,
    pub duckdb_value_string_internal: ::std::option::Option<
        unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_string,
    >,
    pub duckdb_value_blob:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> duckdb_blob>,
    pub duckdb_value_is_null:
        ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t, row: idx_t) -> bool>,
    pub duckdb_execute_prepared_streaming: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            out_result: *mut duckdb_result,
        ) -> duckdb_state,
    >,
    pub duckdb_pending_prepared_streaming: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            out_result: *mut duckdb_pending_result,
        ) -> duckdb_state,
    >,
    pub duckdb_column_has_default: ::std::option::Option<
        unsafe extern "C" fn(table_description: duckdb_table_description, index: idx_t, out: *mut bool) -> duckdb_state,
    >,
    pub duckdb_query_arrow: ::std::option::Option<
        unsafe extern "C" fn(
            connection: duckdb_connection,
            query: *const ::std::os::raw::c_char,
            out_result: *mut duckdb_arrow,
        ) -> duckdb_state,
    >,
    pub duckdb_query_arrow_schema: ::std::option::Option<
        unsafe extern "C" fn(result: duckdb_arrow, out_schema: *mut duckdb_arrow_schema) -> duckdb_state,
    >,
    pub duckdb_prepared_arrow_schema: ::std::option::Option<
        unsafe extern "C" fn(prepared: duckdb_prepared_statement, out_schema: *mut duckdb_arrow_schema) -> duckdb_state,
    >,
    pub duckdb_result_arrow_array: ::std::option::Option<
        unsafe extern "C" fn(result: duckdb_result, chunk: duckdb_data_chunk, out_array: *mut duckdb_arrow_array),
    >,
    pub duckdb_query_arrow_array: ::std::option::Option<
        unsafe extern "C" fn(result: duckdb_arrow, out_array: *mut duckdb_arrow_array) -> duckdb_state,
    >,
    pub duckdb_arrow_column_count: ::std::option::Option<unsafe extern "C" fn(result: duckdb_arrow) -> idx_t>,
    pub duckdb_arrow_row_count: ::std::option::Option<unsafe extern "C" fn(result: duckdb_arrow) -> idx_t>,
    pub duckdb_arrow_rows_changed: ::std::option::Option<unsafe extern "C" fn(result: duckdb_arrow) -> idx_t>,
    pub duckdb_query_arrow_error:
        ::std::option::Option<unsafe extern "C" fn(result: duckdb_arrow) -> *const ::std::os::raw::c_char>,
    pub duckdb_destroy_arrow: ::std::option::Option<unsafe extern "C" fn(result: *mut duckdb_arrow)>,
    pub duckdb_destroy_arrow_stream: ::std::option::Option<unsafe extern "C" fn(stream_p: *mut duckdb_arrow_stream)>,
    pub duckdb_execute_prepared_arrow: ::std::option::Option<
        unsafe extern "C" fn(
            prepared_statement: duckdb_prepared_statement,
            out_result: *mut duckdb_arrow,
        ) -> duckdb_state,
    >,
    pub duckdb_arrow_scan: ::std::option::Option<
        unsafe extern "C" fn(
            connection: duckdb_connection,
            table_name: *const ::std::os::raw::c_char,
            arrow: duckdb_arrow_stream,
        ) -> duckdb_state,
    >,
    pub duckdb_arrow_array_scan: ::std::option::Option<
        unsafe extern "C" fn(
            connection: duckdb_connection,
            table_name: *const ::std::os::raw::c_char,
            arrow_schema: duckdb_arrow_schema,
            arrow_array: duckdb_arrow_array,
            out_stream: *mut duckdb_arrow_stream,
        ) -> duckdb_state,
    >,
    pub duckdb_stream_fetch_chunk:
        ::std::option::Option<unsafe extern "C" fn(result: duckdb_result) -> duckdb_data_chunk>,
}
#[test]
fn bindgen_test_layout_duckdb_ext_api_v0() {
    const UNINIT: ::std::mem::MaybeUninit<duckdb_ext_api_v0> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<duckdb_ext_api_v0>(),
        2968usize,
        concat!("Size of: ", stringify!(duckdb_ext_api_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<duckdb_ext_api_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(duckdb_ext_api_v0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_open) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_open_ext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_open_ext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_close) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_connect) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_connect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_interrupt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_interrupt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_query_progress) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_query_progress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_disconnect) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_disconnect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_library_version) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_library_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_config) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_config_count) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_config_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_config_flag) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_config_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_set_config) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_set_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_config) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_query) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_query)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_result) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_column_name) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_column_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_column_type) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_column_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_result_statement_type) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_result_statement_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_column_logical_type) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_column_logical_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_column_count) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_column_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_rows_changed) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_rows_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_result_error) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_result_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_malloc) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_malloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_free) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_vector_size) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_vector_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_string_is_inlined) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_string_is_inlined)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_from_date) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_from_date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_to_date) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_to_date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_is_finite_date) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_is_finite_date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_from_time) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_from_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_time_tz) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_time_tz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_from_time_tz) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_from_time_tz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_to_time) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_to_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_from_timestamp) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_from_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_to_timestamp) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_to_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_is_finite_timestamp) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_is_finite_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_hugeint_to_double) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_hugeint_to_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_double_to_hugeint) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_double_to_hugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_uhugeint_to_double) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_uhugeint_to_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_double_to_uhugeint) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_double_to_uhugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_double_to_decimal) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_double_to_decimal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_decimal_to_double) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_decimal_to_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_prepare) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_prepare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_prepare) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_prepare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_prepare_error) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_prepare_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_nparams) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_nparams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_parameter_name) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_parameter_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_param_type) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_param_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_clear_bindings) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_clear_bindings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_prepared_statement_type) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_prepared_statement_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_value) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_parameter_index) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_parameter_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_boolean) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_int8) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_int8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_int16) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_int16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_int32) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_int32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_int64) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_hugeint) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_hugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_uhugeint) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_uhugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_decimal) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_decimal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_uint8) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_uint8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_uint16) as usize - ptr as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_uint16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_uint32) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_uint32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_uint64) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_uint64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_float) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_double) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_date) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_time) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_timestamp) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_timestamp_tz) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_timestamp_tz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_interval) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_varchar) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_varchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_varchar_length) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_varchar_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_blob) as usize - ptr as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_blob)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_null) as usize - ptr as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_null)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_execute_prepared) as usize - ptr as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_execute_prepared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_extract_statements) as usize - ptr as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_extract_statements)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_prepare_extracted_statement) as usize - ptr as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_prepare_extracted_statement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_extract_statements_error) as usize - ptr as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_extract_statements_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_extracted) as usize - ptr as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_extracted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_pending_prepared) as usize - ptr as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_pending_prepared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_pending) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_pending)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_pending_error) as usize - ptr as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_pending_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_pending_execute_task) as usize - ptr as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_pending_execute_task)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_pending_execute_check_state) as usize - ptr as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_pending_execute_check_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_execute_pending) as usize - ptr as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_execute_pending)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_pending_execution_is_finished) as usize - ptr as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_pending_execution_is_finished)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_value) as usize - ptr as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_varchar) as usize - ptr as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_varchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_varchar_length) as usize - ptr as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_varchar_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_int64) as usize - ptr as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_struct_value) as usize - ptr as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_struct_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_list_value) as usize - ptr as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_list_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_array_value) as usize - ptr as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_array_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_varchar) as usize - ptr as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_varchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_int64) as usize - ptr as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_logical_type) as usize - ptr as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_logical_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_logical_type_get_alias) as usize - ptr as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_logical_type_get_alias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_list_type) as usize - ptr as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_list_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_array_type) as usize - ptr as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_array_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_map_type) as usize - ptr as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_map_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_union_type) as usize - ptr as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_union_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_struct_type) as usize - ptr as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_struct_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_enum_type) as usize - ptr as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_enum_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_decimal_type) as usize - ptr as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_decimal_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_type_id) as usize - ptr as usize },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_type_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_decimal_width) as usize - ptr as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_decimal_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_decimal_scale) as usize - ptr as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_decimal_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_decimal_internal_type) as usize - ptr as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_decimal_internal_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_enum_internal_type) as usize - ptr as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_enum_internal_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_enum_dictionary_size) as usize - ptr as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_enum_dictionary_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_enum_dictionary_value) as usize - ptr as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_enum_dictionary_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_list_type_child_type) as usize - ptr as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_list_type_child_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_array_type_child_type) as usize - ptr as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_array_type_child_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_array_type_array_size) as usize - ptr as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_array_type_array_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_map_type_key_type) as usize - ptr as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_map_type_key_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_map_type_value_type) as usize - ptr as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_map_type_value_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_struct_type_child_count) as usize - ptr as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_struct_type_child_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_struct_type_child_name) as usize - ptr as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_struct_type_child_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_struct_type_child_type) as usize - ptr as usize },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_struct_type_child_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_union_type_member_count) as usize - ptr as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_union_type_member_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_union_type_member_name) as usize - ptr as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_union_type_member_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_union_type_member_type) as usize - ptr as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_union_type_member_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_logical_type) as usize - ptr as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_logical_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_fetch_chunk) as usize - ptr as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_fetch_chunk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_data_chunk) as usize - ptr as usize },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_data_chunk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_data_chunk) as usize - ptr as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_data_chunk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_data_chunk_reset) as usize - ptr as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_data_chunk_reset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_data_chunk_get_column_count) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_data_chunk_get_column_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_data_chunk_get_vector) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_data_chunk_get_vector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_data_chunk_get_size) as usize - ptr as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_data_chunk_get_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_data_chunk_set_size) as usize - ptr as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_data_chunk_set_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_vector_get_column_type) as usize - ptr as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_vector_get_column_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_vector_get_data) as usize - ptr as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_vector_get_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_vector_get_validity) as usize - ptr as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_vector_get_validity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_vector_ensure_validity_writable) as usize - ptr as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_vector_ensure_validity_writable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_vector_assign_string_element) as usize - ptr as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_vector_assign_string_element)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_vector_assign_string_element_len) as usize - ptr as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_vector_assign_string_element_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_list_vector_get_child) as usize - ptr as usize },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_list_vector_get_child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_list_vector_get_size) as usize - ptr as usize },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_list_vector_get_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_list_vector_set_size) as usize - ptr as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_list_vector_set_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_list_vector_reserve) as usize - ptr as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_list_vector_reserve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_struct_vector_get_child) as usize - ptr as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_struct_vector_get_child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_array_vector_get_child) as usize - ptr as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_array_vector_get_child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_validity_row_is_valid) as usize - ptr as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_validity_row_is_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_validity_set_row_validity) as usize - ptr as usize },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_validity_set_row_validity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_validity_set_row_invalid) as usize - ptr as usize },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_validity_set_row_invalid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_validity_set_row_valid) as usize - ptr as usize },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_validity_set_row_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_scalar_function) as usize - ptr as usize },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_scalar_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_scalar_function) as usize - ptr as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_scalar_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_set_name) as usize - ptr as usize },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_set_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_add_parameter) as usize - ptr as usize },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_add_parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_set_return_type) as usize - ptr as usize },
        1216usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_set_return_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_set_extra_info) as usize - ptr as usize },
        1224usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_set_extra_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_set_function) as usize - ptr as usize },
        1232usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_set_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_register_scalar_function) as usize - ptr as usize },
        1240usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_register_scalar_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_table_function) as usize - ptr as usize },
        1248usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_table_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_table_function) as usize - ptr as usize },
        1256usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_table_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_function_set_name) as usize - ptr as usize },
        1264usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_function_set_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_function_add_parameter) as usize - ptr as usize },
        1272usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_function_add_parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_function_add_named_parameter) as usize - ptr as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_function_add_named_parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_function_set_extra_info) as usize - ptr as usize },
        1288usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_function_set_extra_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_function_set_bind) as usize - ptr as usize },
        1296usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_function_set_bind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_function_set_init) as usize - ptr as usize },
        1304usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_function_set_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_function_set_local_init) as usize - ptr as usize },
        1312usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_function_set_local_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_function_set_function) as usize - ptr as usize },
        1320usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_function_set_function)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).duckdb_table_function_supports_projection_pushdown) as usize - ptr as usize
        },
        1328usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_function_supports_projection_pushdown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_register_table_function) as usize - ptr as usize },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_register_table_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_get_extra_info) as usize - ptr as usize },
        1344usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_get_extra_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_add_result_column) as usize - ptr as usize },
        1352usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_add_result_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_get_parameter_count) as usize - ptr as usize },
        1360usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_get_parameter_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_get_parameter) as usize - ptr as usize },
        1368usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_get_parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_get_named_parameter) as usize - ptr as usize },
        1376usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_get_named_parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_set_bind_data) as usize - ptr as usize },
        1384usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_set_bind_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_set_cardinality) as usize - ptr as usize },
        1392usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_set_cardinality)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_bind_set_error) as usize - ptr as usize },
        1400usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_bind_set_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_init_get_extra_info) as usize - ptr as usize },
        1408usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_init_get_extra_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_init_get_bind_data) as usize - ptr as usize },
        1416usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_init_get_bind_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_init_set_init_data) as usize - ptr as usize },
        1424usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_init_set_init_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_init_get_column_count) as usize - ptr as usize },
        1432usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_init_get_column_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_init_get_column_index) as usize - ptr as usize },
        1440usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_init_get_column_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_init_set_max_threads) as usize - ptr as usize },
        1448usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_init_set_max_threads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_init_set_error) as usize - ptr as usize },
        1456usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_init_set_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_function_get_extra_info) as usize - ptr as usize },
        1464usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_function_get_extra_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_function_get_bind_data) as usize - ptr as usize },
        1472usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_function_get_bind_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_function_get_init_data) as usize - ptr as usize },
        1480usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_function_get_init_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_function_get_local_init_data) as usize - ptr as usize },
        1488usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_function_get_local_init_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_function_set_error) as usize - ptr as usize },
        1496usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_function_set_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_add_replacement_scan) as usize - ptr as usize },
        1504usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_add_replacement_scan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_replacement_scan_set_function_name) as usize - ptr as usize },
        1512usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_replacement_scan_set_function_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_replacement_scan_add_parameter) as usize - ptr as usize },
        1520usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_replacement_scan_add_parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_replacement_scan_set_error) as usize - ptr as usize },
        1528usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_replacement_scan_set_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_appender_create) as usize - ptr as usize },
        1536usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_appender_create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_appender_column_count) as usize - ptr as usize },
        1544usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_appender_column_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_appender_column_type) as usize - ptr as usize },
        1552usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_appender_column_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_appender_error) as usize - ptr as usize },
        1560usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_appender_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_appender_flush) as usize - ptr as usize },
        1568usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_appender_flush)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_appender_close) as usize - ptr as usize },
        1576usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_appender_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_appender_destroy) as usize - ptr as usize },
        1584usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_appender_destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_appender_begin_row) as usize - ptr as usize },
        1592usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_appender_begin_row)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_appender_end_row) as usize - ptr as usize },
        1600usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_appender_end_row)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_default) as usize - ptr as usize },
        1608usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_bool) as usize - ptr as usize },
        1616usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_bool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_int8) as usize - ptr as usize },
        1624usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_int8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_int16) as usize - ptr as usize },
        1632usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_int16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_int32) as usize - ptr as usize },
        1640usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_int32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_int64) as usize - ptr as usize },
        1648usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_hugeint) as usize - ptr as usize },
        1656usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_hugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_uint8) as usize - ptr as usize },
        1664usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_uint8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_uint16) as usize - ptr as usize },
        1672usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_uint16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_uint32) as usize - ptr as usize },
        1680usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_uint32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_uint64) as usize - ptr as usize },
        1688usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_uint64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_uhugeint) as usize - ptr as usize },
        1696usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_uhugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_float) as usize - ptr as usize },
        1704usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_double) as usize - ptr as usize },
        1712usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_date) as usize - ptr as usize },
        1720usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_time) as usize - ptr as usize },
        1728usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_timestamp) as usize - ptr as usize },
        1736usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_interval) as usize - ptr as usize },
        1744usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_varchar) as usize - ptr as usize },
        1752usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_varchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_varchar_length) as usize - ptr as usize },
        1760usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_varchar_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_blob) as usize - ptr as usize },
        1768usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_blob)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_null) as usize - ptr as usize },
        1776usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_null)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_append_data_chunk) as usize - ptr as usize },
        1784usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_append_data_chunk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_execute_tasks) as usize - ptr as usize },
        1792usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_execute_tasks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_task_state) as usize - ptr as usize },
        1800usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_task_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_execute_tasks_state) as usize - ptr as usize },
        1808usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_execute_tasks_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_execute_n_tasks_state) as usize - ptr as usize },
        1816usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_execute_n_tasks_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_finish_execution) as usize - ptr as usize },
        1824usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_finish_execution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_task_state_is_finished) as usize - ptr as usize },
        1832usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_task_state_is_finished)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_task_state) as usize - ptr as usize },
        1840usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_task_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_execution_is_finished) as usize - ptr as usize },
        1848usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_execution_is_finished)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_profiling_info) as usize - ptr as usize },
        1856usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_profiling_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_profiling_info_get_value) as usize - ptr as usize },
        1864usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_profiling_info_get_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_profiling_info_get_child_count) as usize - ptr as usize },
        1872usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_profiling_info_get_child_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_profiling_info_get_child) as usize - ptr as usize },
        1880usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_profiling_info_get_child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_profiling_info_get_metrics) as usize - ptr as usize },
        1888usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_profiling_info_get_metrics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_set_varargs) as usize - ptr as usize },
        1896usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_set_varargs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_set_special_handling) as usize - ptr as usize },
        1904usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_set_special_handling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_set_volatile) as usize - ptr as usize },
        1912usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_set_volatile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_get_extra_info) as usize - ptr as usize },
        1920usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_get_extra_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_scalar_function_set_error) as usize - ptr as usize },
        1928usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_scalar_function_set_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_description_create) as usize - ptr as usize },
        1936usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_description_create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_description_destroy) as usize - ptr as usize },
        1944usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_description_destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_table_description_error) as usize - ptr as usize },
        1952usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_table_description_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_result_error_type) as usize - ptr as usize },
        1960usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_result_error_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_string_t_length) as usize - ptr as usize },
        1968usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_string_t_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_string_t_data) as usize - ptr as usize },
        1976usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_string_t_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_bool) as usize - ptr as usize },
        1984usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_bool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_int8) as usize - ptr as usize },
        1992usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_int8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_uint8) as usize - ptr as usize },
        2000usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_uint8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_int16) as usize - ptr as usize },
        2008usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_int16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_uint16) as usize - ptr as usize },
        2016usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_uint16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_int32) as usize - ptr as usize },
        2024usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_int32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_uint32) as usize - ptr as usize },
        2032usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_uint32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_uint64) as usize - ptr as usize },
        2040usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_uint64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_hugeint) as usize - ptr as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_hugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_uhugeint) as usize - ptr as usize },
        2056usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_uhugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_float) as usize - ptr as usize },
        2064usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_double) as usize - ptr as usize },
        2072usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_date) as usize - ptr as usize },
        2080usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_time) as usize - ptr as usize },
        2088usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_time_tz_value) as usize - ptr as usize },
        2096usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_time_tz_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_timestamp) as usize - ptr as usize },
        2104usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_interval) as usize - ptr as usize },
        2112usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_blob) as usize - ptr as usize },
        2120usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_blob)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_bool) as usize - ptr as usize },
        2128usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_bool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_int8) as usize - ptr as usize },
        2136usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_int8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_uint8) as usize - ptr as usize },
        2144usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_uint8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_int16) as usize - ptr as usize },
        2152usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_int16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_uint16) as usize - ptr as usize },
        2160usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_uint16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_int32) as usize - ptr as usize },
        2168usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_int32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_uint32) as usize - ptr as usize },
        2176usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_uint32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_uint64) as usize - ptr as usize },
        2184usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_uint64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_hugeint) as usize - ptr as usize },
        2192usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_hugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_uhugeint) as usize - ptr as usize },
        2200usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_uhugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_float) as usize - ptr as usize },
        2208usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_double) as usize - ptr as usize },
        2216usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_date) as usize - ptr as usize },
        2224usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_time) as usize - ptr as usize },
        2232usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_time_tz) as usize - ptr as usize },
        2240usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_time_tz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_timestamp) as usize - ptr as usize },
        2248usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_interval) as usize - ptr as usize },
        2256usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_value_type) as usize - ptr as usize },
        2264usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_value_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_blob) as usize - ptr as usize },
        2272usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_blob)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_scalar_function_set) as usize - ptr as usize },
        2280usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_scalar_function_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_scalar_function_set) as usize - ptr as usize },
        2288usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_scalar_function_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_add_scalar_function_to_set) as usize - ptr as usize },
        2296usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_add_scalar_function_to_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_register_scalar_function_set) as usize - ptr as usize },
        2304usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_register_scalar_function_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_aggregate_function_set) as usize - ptr as usize },
        2312usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_aggregate_function_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_aggregate_function_set) as usize - ptr as usize },
        2320usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_aggregate_function_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_add_aggregate_function_to_set) as usize - ptr as usize },
        2328usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_add_aggregate_function_to_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_register_aggregate_function_set) as usize - ptr as usize },
        2336usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_register_aggregate_function_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_map_size) as usize - ptr as usize },
        2344usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_map_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_map_key) as usize - ptr as usize },
        2352usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_map_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_get_map_value) as usize - ptr as usize },
        2360usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_get_map_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_aggregate_function) as usize - ptr as usize },
        2368usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_aggregate_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_aggregate_function) as usize - ptr as usize },
        2376usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_aggregate_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_aggregate_function_set_name) as usize - ptr as usize },
        2384usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_aggregate_function_set_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_aggregate_function_add_parameter) as usize - ptr as usize },
        2392usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_aggregate_function_add_parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_aggregate_function_set_return_type) as usize - ptr as usize },
        2400usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_aggregate_function_set_return_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_aggregate_function_set_functions) as usize - ptr as usize },
        2408usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_aggregate_function_set_functions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_aggregate_function_set_destructor) as usize - ptr as usize },
        2416usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_aggregate_function_set_destructor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_register_aggregate_function) as usize - ptr as usize },
        2424usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_register_aggregate_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_aggregate_function_set_special_handling) as usize - ptr as usize },
        2432usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_aggregate_function_set_special_handling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_aggregate_function_set_extra_info) as usize - ptr as usize },
        2440usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_aggregate_function_set_extra_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_aggregate_function_get_extra_info) as usize - ptr as usize },
        2448usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_aggregate_function_get_extra_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_aggregate_function_set_error) as usize - ptr as usize },
        2456usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_aggregate_function_set_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_logical_type_set_alias) as usize - ptr as usize },
        2464usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_logical_type_set_alias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_register_logical_type) as usize - ptr as usize },
        2472usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_register_logical_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_create_cast_function) as usize - ptr as usize },
        2480usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_create_cast_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_cast_function_set_source_type) as usize - ptr as usize },
        2488usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_cast_function_set_source_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_cast_function_set_target_type) as usize - ptr as usize },
        2496usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_cast_function_set_target_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_cast_function_set_implicit_cast_cost) as usize - ptr as usize },
        2504usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_cast_function_set_implicit_cast_cost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_cast_function_set_function) as usize - ptr as usize },
        2512usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_cast_function_set_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_cast_function_set_extra_info) as usize - ptr as usize },
        2520usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_cast_function_set_extra_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_cast_function_get_extra_info) as usize - ptr as usize },
        2528usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_cast_function_get_extra_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_cast_function_get_cast_mode) as usize - ptr as usize },
        2536usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_cast_function_get_cast_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_cast_function_set_error) as usize - ptr as usize },
        2544usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_cast_function_set_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_cast_function_set_row_error) as usize - ptr as usize },
        2552usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_cast_function_set_row_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_register_cast_function) as usize - ptr as usize },
        2560usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_register_cast_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_cast_function) as usize - ptr as usize },
        2568usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_cast_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_row_count) as usize - ptr as usize },
        2576usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_row_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_column_data) as usize - ptr as usize },
        2584usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_column_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_nullmask_data) as usize - ptr as usize },
        2592usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_nullmask_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_result_get_chunk) as usize - ptr as usize },
        2600usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_result_get_chunk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_result_is_streaming) as usize - ptr as usize },
        2608usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_result_is_streaming)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_result_chunk_count) as usize - ptr as usize },
        2616usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_result_chunk_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_result_return_type) as usize - ptr as usize },
        2624usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_result_return_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_boolean) as usize - ptr as usize },
        2632usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_int8) as usize - ptr as usize },
        2640usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_int8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_int16) as usize - ptr as usize },
        2648usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_int16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_int32) as usize - ptr as usize },
        2656usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_int32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_int64) as usize - ptr as usize },
        2664usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_hugeint) as usize - ptr as usize },
        2672usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_hugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_uhugeint) as usize - ptr as usize },
        2680usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_uhugeint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_decimal) as usize - ptr as usize },
        2688usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_decimal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_uint8) as usize - ptr as usize },
        2696usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_uint8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_uint16) as usize - ptr as usize },
        2704usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_uint16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_uint32) as usize - ptr as usize },
        2712usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_uint32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_uint64) as usize - ptr as usize },
        2720usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_uint64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_float) as usize - ptr as usize },
        2728usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_double) as usize - ptr as usize },
        2736usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_date) as usize - ptr as usize },
        2744usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_time) as usize - ptr as usize },
        2752usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_timestamp) as usize - ptr as usize },
        2760usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_interval) as usize - ptr as usize },
        2768usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_varchar) as usize - ptr as usize },
        2776usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_varchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_string) as usize - ptr as usize },
        2784usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_varchar_internal) as usize - ptr as usize },
        2792usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_varchar_internal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_string_internal) as usize - ptr as usize },
        2800usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_string_internal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_blob) as usize - ptr as usize },
        2808usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_blob)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_value_is_null) as usize - ptr as usize },
        2816usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_value_is_null)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_execute_prepared_streaming) as usize - ptr as usize },
        2824usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_execute_prepared_streaming)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_pending_prepared_streaming) as usize - ptr as usize },
        2832usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_pending_prepared_streaming)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_column_has_default) as usize - ptr as usize },
        2840usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_column_has_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_query_arrow) as usize - ptr as usize },
        2848usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_query_arrow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_query_arrow_schema) as usize - ptr as usize },
        2856usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_query_arrow_schema)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_prepared_arrow_schema) as usize - ptr as usize },
        2864usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_prepared_arrow_schema)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_result_arrow_array) as usize - ptr as usize },
        2872usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_result_arrow_array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_query_arrow_array) as usize - ptr as usize },
        2880usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_query_arrow_array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_arrow_column_count) as usize - ptr as usize },
        2888usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_arrow_column_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_arrow_row_count) as usize - ptr as usize },
        2896usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_arrow_row_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_arrow_rows_changed) as usize - ptr as usize },
        2904usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_arrow_rows_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_query_arrow_error) as usize - ptr as usize },
        2912usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_query_arrow_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_arrow) as usize - ptr as usize },
        2920usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_arrow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_destroy_arrow_stream) as usize - ptr as usize },
        2928usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_destroy_arrow_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_execute_prepared_arrow) as usize - ptr as usize },
        2936usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_execute_prepared_arrow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_arrow_scan) as usize - ptr as usize },
        2944usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_arrow_scan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_arrow_array_scan) as usize - ptr as usize },
        2952usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_arrow_array_scan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duckdb_stream_fetch_chunk) as usize - ptr as usize },
        2960usize,
        concat!(
            "Offset of field: ",
            stringify!(duckdb_ext_api_v0),
            "::",
            stringify!(duckdb_stream_fetch_chunk)
        )
    );
}
static __DUCKDB_OPEN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_open(
    path: *const ::std::os::raw::c_char,
    out_database: *mut duckdb_database,
) -> duckdb_state {
    let function_ptr = __DUCKDB_OPEN.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        path: *const ::std::os::raw::c_char,
        out_database: *mut duckdb_database,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(path, out_database)
}

static __DUCKDB_OPEN_EXT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_open_ext(
    path: *const ::std::os::raw::c_char,
    out_database: *mut duckdb_database,
    config: duckdb_config,
    out_error: *mut *mut ::std::os::raw::c_char,
) -> duckdb_state {
    let function_ptr = __DUCKDB_OPEN_EXT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        path: *const ::std::os::raw::c_char,
        out_database: *mut duckdb_database,
        config: duckdb_config,
        out_error: *mut *mut ::std::os::raw::c_char,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(path, out_database, config, out_error)
}

static __DUCKDB_CLOSE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_close(database: *mut duckdb_database) {
    let function_ptr = __DUCKDB_CLOSE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(database: *mut duckdb_database) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(database)
}

static __DUCKDB_CONNECT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_connect(
    database: duckdb_database,
    out_connection: *mut duckdb_connection,
) -> duckdb_state {
    let function_ptr = __DUCKDB_CONNECT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        database: duckdb_database,
        out_connection: *mut duckdb_connection,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(database, out_connection)
}

static __DUCKDB_INTERRUPT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_interrupt(connection: duckdb_connection) {
    let function_ptr = __DUCKDB_INTERRUPT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(connection: duckdb_connection) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(connection)
}

static __DUCKDB_QUERY_PROGRESS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_query_progress(
    connection: duckdb_connection,
) -> duckdb_query_progress_type {
    let function_ptr = __DUCKDB_QUERY_PROGRESS
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        connection: duckdb_connection,
    ) -> duckdb_query_progress_type = ::std::mem::transmute(function_ptr);
    (fun)(connection)
}

static __DUCKDB_DISCONNECT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_disconnect(connection: *mut duckdb_connection) {
    let function_ptr = __DUCKDB_DISCONNECT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(connection: *mut duckdb_connection) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(connection)
}

static __DUCKDB_LIBRARY_VERSION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_library_version() -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_LIBRARY_VERSION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn() -> *const ::std::os::raw::c_char = ::std::mem::transmute(
        function_ptr,
    );
    (fun)()
}

static __DUCKDB_CREATE_CONFIG: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_config(out_config: *mut duckdb_config) -> duckdb_state {
    let function_ptr = __DUCKDB_CREATE_CONFIG
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(out_config: *mut duckdb_config) -> duckdb_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(out_config)
}

static __DUCKDB_CONFIG_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_config_count() -> usize {
    let function_ptr = __DUCKDB_CONFIG_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn() -> usize = ::std::mem::transmute(function_ptr);
    (fun)()
}

static __DUCKDB_GET_CONFIG_FLAG: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_config_flag(
    index: usize,
    out_name: *mut *const ::std::os::raw::c_char,
    out_description: *mut *const ::std::os::raw::c_char,
) -> duckdb_state {
    let function_ptr = __DUCKDB_GET_CONFIG_FLAG
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        index: usize,
        out_name: *mut *const ::std::os::raw::c_char,
        out_description: *mut *const ::std::os::raw::c_char,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(index, out_name, out_description)
}

static __DUCKDB_SET_CONFIG: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_set_config(
    config: duckdb_config,
    name: *const ::std::os::raw::c_char,
    option: *const ::std::os::raw::c_char,
) -> duckdb_state {
    let function_ptr = __DUCKDB_SET_CONFIG.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        config: duckdb_config,
        name: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(config, name, option)
}

static __DUCKDB_DESTROY_CONFIG: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_config(config: *mut duckdb_config) {
    let function_ptr = __DUCKDB_DESTROY_CONFIG
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(config: *mut duckdb_config) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(config)
}

static __DUCKDB_QUERY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_query(
    connection: duckdb_connection,
    query: *const ::std::os::raw::c_char,
    out_result: *mut duckdb_result,
) -> duckdb_state {
    let function_ptr = __DUCKDB_QUERY.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        connection: duckdb_connection,
        query: *const ::std::os::raw::c_char,
        out_result: *mut duckdb_result,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(connection, query, out_result)
}

static __DUCKDB_DESTROY_RESULT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_result(result: *mut duckdb_result) {
    let function_ptr = __DUCKDB_DESTROY_RESULT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: *mut duckdb_result) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_COLUMN_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_column_name(
    result: *mut duckdb_result,
    col: idx_t,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_COLUMN_NAME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(result, col)
}

static __DUCKDB_COLUMN_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_column_type(result: *mut duckdb_result, col: idx_t) -> duckdb_type {
    let function_ptr = __DUCKDB_COLUMN_TYPE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
    ) -> duckdb_type = ::std::mem::transmute(function_ptr);
    (fun)(result, col)
}

static __DUCKDB_RESULT_STATEMENT_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_result_statement_type(
    result: duckdb_result,
) -> duckdb_statement_type {
    let function_ptr = __DUCKDB_RESULT_STATEMENT_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: duckdb_result) -> duckdb_statement_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_COLUMN_LOGICAL_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_column_logical_type(
    result: *mut duckdb_result,
    col: idx_t,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_COLUMN_LOGICAL_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
    ) -> duckdb_logical_type = ::std::mem::transmute(function_ptr);
    (fun)(result, col)
}

static __DUCKDB_COLUMN_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_column_count(result: *mut duckdb_result) -> idx_t {
    let function_ptr = __DUCKDB_COLUMN_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: *mut duckdb_result) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_ROWS_CHANGED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_rows_changed(result: *mut duckdb_result) -> idx_t {
    let function_ptr = __DUCKDB_ROWS_CHANGED
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: *mut duckdb_result) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_RESULT_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_result_error(
    result: *mut duckdb_result,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_RESULT_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(result)
}

static __DUCKDB_MALLOC: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_malloc(size: usize) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_MALLOC.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(size)
}

static __DUCKDB_FREE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_free(ptr: *mut ::std::os::raw::c_void) {
    let function_ptr = __DUCKDB_FREE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(ptr)
}

static __DUCKDB_VECTOR_SIZE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_vector_size() -> idx_t {
    let function_ptr = __DUCKDB_VECTOR_SIZE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn() -> idx_t = ::std::mem::transmute(function_ptr);
    (fun)()
}

static __DUCKDB_STRING_IS_INLINED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_string_is_inlined(string: duckdb_string_t) -> bool {
    let function_ptr = __DUCKDB_STRING_IS_INLINED
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(string: duckdb_string_t) -> bool = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(string)
}

static __DUCKDB_FROM_DATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_from_date(date: duckdb_date) -> duckdb_date_struct {
    let function_ptr = __DUCKDB_FROM_DATE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(date: duckdb_date) -> duckdb_date_struct = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(date)
}

static __DUCKDB_TO_DATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_to_date(date: duckdb_date_struct) -> duckdb_date {
    let function_ptr = __DUCKDB_TO_DATE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(date: duckdb_date_struct) -> duckdb_date = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(date)
}

static __DUCKDB_IS_FINITE_DATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_is_finite_date(date: duckdb_date) -> bool {
    let function_ptr = __DUCKDB_IS_FINITE_DATE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(date: duckdb_date) -> bool = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(date)
}

static __DUCKDB_FROM_TIME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_from_time(time: duckdb_time) -> duckdb_time_struct {
    let function_ptr = __DUCKDB_FROM_TIME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(time: duckdb_time) -> duckdb_time_struct = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(time)
}

static __DUCKDB_CREATE_TIME_TZ: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_time_tz(micros: i64, offset: i32) -> duckdb_time_tz {
    let function_ptr = __DUCKDB_CREATE_TIME_TZ
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(micros: i64, offset: i32) -> duckdb_time_tz = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(micros, offset)
}

static __DUCKDB_FROM_TIME_TZ: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_from_time_tz(micros: duckdb_time_tz) -> duckdb_time_tz_struct {
    let function_ptr = __DUCKDB_FROM_TIME_TZ
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(micros: duckdb_time_tz) -> duckdb_time_tz_struct = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(micros)
}

static __DUCKDB_TO_TIME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_to_time(time: duckdb_time_struct) -> duckdb_time {
    let function_ptr = __DUCKDB_TO_TIME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(time: duckdb_time_struct) -> duckdb_time = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(time)
}

static __DUCKDB_FROM_TIMESTAMP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_from_timestamp(ts: duckdb_timestamp) -> duckdb_timestamp_struct {
    let function_ptr = __DUCKDB_FROM_TIMESTAMP
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(ts: duckdb_timestamp) -> duckdb_timestamp_struct = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(ts)
}

static __DUCKDB_TO_TIMESTAMP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_to_timestamp(ts: duckdb_timestamp_struct) -> duckdb_timestamp {
    let function_ptr = __DUCKDB_TO_TIMESTAMP
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(ts: duckdb_timestamp_struct) -> duckdb_timestamp = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(ts)
}

static __DUCKDB_IS_FINITE_TIMESTAMP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_is_finite_timestamp(ts: duckdb_timestamp) -> bool {
    let function_ptr = __DUCKDB_IS_FINITE_TIMESTAMP
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(ts: duckdb_timestamp) -> bool = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(ts)
}

static __DUCKDB_HUGEINT_TO_DOUBLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_hugeint_to_double(val: duckdb_hugeint) -> f64 {
    let function_ptr = __DUCKDB_HUGEINT_TO_DOUBLE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_hugeint) -> f64 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_DOUBLE_TO_HUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_double_to_hugeint(val: f64) -> duckdb_hugeint {
    let function_ptr = __DUCKDB_DOUBLE_TO_HUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: f64) -> duckdb_hugeint = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_UHUGEINT_TO_DOUBLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_uhugeint_to_double(val: duckdb_uhugeint) -> f64 {
    let function_ptr = __DUCKDB_UHUGEINT_TO_DOUBLE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_uhugeint) -> f64 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_DOUBLE_TO_UHUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_double_to_uhugeint(val: f64) -> duckdb_uhugeint {
    let function_ptr = __DUCKDB_DOUBLE_TO_UHUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: f64) -> duckdb_uhugeint = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_DOUBLE_TO_DECIMAL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_double_to_decimal(
    val: f64,
    width: u8,
    scale: u8,
) -> duckdb_decimal {
    let function_ptr = __DUCKDB_DOUBLE_TO_DECIMAL
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: f64, width: u8, scale: u8) -> duckdb_decimal = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val, width, scale)
}

static __DUCKDB_DECIMAL_TO_DOUBLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_decimal_to_double(val: duckdb_decimal) -> f64 {
    let function_ptr = __DUCKDB_DECIMAL_TO_DOUBLE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_decimal) -> f64 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_PREPARE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_prepare(
    connection: duckdb_connection,
    query: *const ::std::os::raw::c_char,
    out_prepared_statement: *mut duckdb_prepared_statement,
) -> duckdb_state {
    let function_ptr = __DUCKDB_PREPARE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        connection: duckdb_connection,
        query: *const ::std::os::raw::c_char,
        out_prepared_statement: *mut duckdb_prepared_statement,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(connection, query, out_prepared_statement)
}

static __DUCKDB_DESTROY_PREPARE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_prepare(
    prepared_statement: *mut duckdb_prepared_statement,
) {
    let function_ptr = __DUCKDB_DESTROY_PREPARE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(prepared_statement: *mut duckdb_prepared_statement) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(prepared_statement)
}

static __DUCKDB_PREPARE_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_prepare_error(
    prepared_statement: duckdb_prepared_statement,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_PREPARE_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement)
}

static __DUCKDB_NPARAMS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_nparams(prepared_statement: duckdb_prepared_statement) -> idx_t {
    let function_ptr = __DUCKDB_NPARAMS.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
    ) -> idx_t = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement)
}

static __DUCKDB_PARAMETER_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_parameter_name(
    prepared_statement: duckdb_prepared_statement,
    index: idx_t,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_PARAMETER_NAME
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        index: idx_t,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, index)
}

static __DUCKDB_PARAM_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_param_type(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
) -> duckdb_type {
    let function_ptr = __DUCKDB_PARAM_TYPE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
    ) -> duckdb_type = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx)
}

static __DUCKDB_CLEAR_BINDINGS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_clear_bindings(
    prepared_statement: duckdb_prepared_statement,
) -> duckdb_state {
    let function_ptr = __DUCKDB_CLEAR_BINDINGS
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement)
}

static __DUCKDB_PREPARED_STATEMENT_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_prepared_statement_type(
    statement: duckdb_prepared_statement,
) -> duckdb_statement_type {
    let function_ptr = __DUCKDB_PREPARED_STATEMENT_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        statement: duckdb_prepared_statement,
    ) -> duckdb_statement_type = ::std::mem::transmute(function_ptr);
    (fun)(statement)
}

static __DUCKDB_BIND_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_value(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: duckdb_value,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_VALUE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_value,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_PARAMETER_INDEX: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_parameter_index(
    prepared_statement: duckdb_prepared_statement,
    param_idx_out: *mut idx_t,
    name: *const ::std::os::raw::c_char,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_PARAMETER_INDEX
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx_out: *mut idx_t,
        name: *const ::std::os::raw::c_char,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx_out, name)
}

static __DUCKDB_BIND_BOOLEAN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_boolean(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: bool,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_BOOLEAN
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: bool,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_INT8: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_int8(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: i8,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_INT8.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: i8,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_INT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_int16(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: i16,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_INT16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: i16,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_INT32: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_int32(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: i32,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_INT32.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: i32,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_INT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_int64(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: i64,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_INT64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: i64,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_HUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_hugeint(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: duckdb_hugeint,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_HUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_hugeint,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_UHUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_uhugeint(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: duckdb_uhugeint,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_UHUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_uhugeint,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_DECIMAL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_decimal(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: duckdb_decimal,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_DECIMAL
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_decimal,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_UINT8: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_uint8(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: u8,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_UINT8.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: u8,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_UINT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_uint16(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: u16,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_UINT16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: u16,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_UINT32: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_uint32(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: u32,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_UINT32.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: u32,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_UINT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_uint64(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: u64,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_UINT64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: u64,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_FLOAT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_float(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: f32,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_FLOAT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: f32,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_DOUBLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_double(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: f64,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_DOUBLE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: f64,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_DATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_date(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: duckdb_date,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_DATE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_date,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_TIME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_time(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: duckdb_time,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_TIME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_time,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_TIMESTAMP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_timestamp(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: duckdb_timestamp,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_TIMESTAMP
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_timestamp,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_TIMESTAMP_TZ: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_timestamp_tz(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: duckdb_timestamp,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_TIMESTAMP_TZ
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_timestamp,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_INTERVAL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_interval(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: duckdb_interval,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_INTERVAL
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: duckdb_interval,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_VARCHAR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_varchar(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: *const ::std::os::raw::c_char,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_VARCHAR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: *const ::std::os::raw::c_char,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val)
}

static __DUCKDB_BIND_VARCHAR_LENGTH: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_varchar_length(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    val: *const ::std::os::raw::c_char,
    length: idx_t,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_VARCHAR_LENGTH
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        val: *const ::std::os::raw::c_char,
        length: idx_t,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, val, length)
}

static __DUCKDB_BIND_BLOB: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_blob(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
    data: *const ::std::os::raw::c_void,
    length: idx_t,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_BLOB.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
        data: *const ::std::os::raw::c_void,
        length: idx_t,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx, data, length)
}

static __DUCKDB_BIND_NULL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_null(
    prepared_statement: duckdb_prepared_statement,
    param_idx: idx_t,
) -> duckdb_state {
    let function_ptr = __DUCKDB_BIND_NULL.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        param_idx: idx_t,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, param_idx)
}

static __DUCKDB_EXECUTE_PREPARED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_execute_prepared(
    prepared_statement: duckdb_prepared_statement,
    out_result: *mut duckdb_result,
) -> duckdb_state {
    let function_ptr = __DUCKDB_EXECUTE_PREPARED
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        out_result: *mut duckdb_result,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, out_result)
}

static __DUCKDB_EXTRACT_STATEMENTS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_extract_statements(
    connection: duckdb_connection,
    query: *const ::std::os::raw::c_char,
    out_extracted_statements: *mut duckdb_extracted_statements,
) -> idx_t {
    let function_ptr = __DUCKDB_EXTRACT_STATEMENTS
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        connection: duckdb_connection,
        query: *const ::std::os::raw::c_char,
        out_extracted_statements: *mut duckdb_extracted_statements,
    ) -> idx_t = ::std::mem::transmute(function_ptr);
    (fun)(connection, query, out_extracted_statements)
}

static __DUCKDB_PREPARE_EXTRACTED_STATEMENT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_prepare_extracted_statement(
    connection: duckdb_connection,
    extracted_statements: duckdb_extracted_statements,
    index: idx_t,
    out_prepared_statement: *mut duckdb_prepared_statement,
) -> duckdb_state {
    let function_ptr = __DUCKDB_PREPARE_EXTRACTED_STATEMENT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        connection: duckdb_connection,
        extracted_statements: duckdb_extracted_statements,
        index: idx_t,
        out_prepared_statement: *mut duckdb_prepared_statement,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(connection, extracted_statements, index, out_prepared_statement)
}

static __DUCKDB_EXTRACT_STATEMENTS_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_extract_statements_error(
    extracted_statements: duckdb_extracted_statements,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_EXTRACT_STATEMENTS_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        extracted_statements: duckdb_extracted_statements,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(extracted_statements)
}

static __DUCKDB_DESTROY_EXTRACTED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_extracted(
    extracted_statements: *mut duckdb_extracted_statements,
) {
    let function_ptr = __DUCKDB_DESTROY_EXTRACTED
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        extracted_statements: *mut duckdb_extracted_statements,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(extracted_statements)
}

static __DUCKDB_PENDING_PREPARED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_pending_prepared(
    prepared_statement: duckdb_prepared_statement,
    out_result: *mut duckdb_pending_result,
) -> duckdb_state {
    let function_ptr = __DUCKDB_PENDING_PREPARED
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        out_result: *mut duckdb_pending_result,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, out_result)
}

static __DUCKDB_DESTROY_PENDING: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_pending(pending_result: *mut duckdb_pending_result) {
    let function_ptr = __DUCKDB_DESTROY_PENDING
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(pending_result: *mut duckdb_pending_result) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(pending_result)
}

static __DUCKDB_PENDING_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_pending_error(
    pending_result: duckdb_pending_result,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_PENDING_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        pending_result: duckdb_pending_result,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(pending_result)
}

static __DUCKDB_PENDING_EXECUTE_TASK: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_pending_execute_task(
    pending_result: duckdb_pending_result,
) -> duckdb_pending_state {
    let function_ptr = __DUCKDB_PENDING_EXECUTE_TASK
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        pending_result: duckdb_pending_result,
    ) -> duckdb_pending_state = ::std::mem::transmute(function_ptr);
    (fun)(pending_result)
}

static __DUCKDB_PENDING_EXECUTE_CHECK_STATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_pending_execute_check_state(
    pending_result: duckdb_pending_result,
) -> duckdb_pending_state {
    let function_ptr = __DUCKDB_PENDING_EXECUTE_CHECK_STATE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        pending_result: duckdb_pending_result,
    ) -> duckdb_pending_state = ::std::mem::transmute(function_ptr);
    (fun)(pending_result)
}

static __DUCKDB_EXECUTE_PENDING: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_execute_pending(
    pending_result: duckdb_pending_result,
    out_result: *mut duckdb_result,
) -> duckdb_state {
    let function_ptr = __DUCKDB_EXECUTE_PENDING
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        pending_result: duckdb_pending_result,
        out_result: *mut duckdb_result,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(pending_result, out_result)
}

static __DUCKDB_PENDING_EXECUTION_IS_FINISHED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_pending_execution_is_finished(
    pending_state: duckdb_pending_state,
) -> bool {
    let function_ptr = __DUCKDB_PENDING_EXECUTION_IS_FINISHED
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(pending_state: duckdb_pending_state) -> bool = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(pending_state)
}

static __DUCKDB_DESTROY_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_value(value: *mut duckdb_value) {
    let function_ptr = __DUCKDB_DESTROY_VALUE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(value: *mut duckdb_value) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(value)
}

static __DUCKDB_CREATE_VARCHAR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_varchar(
    text: *const ::std::os::raw::c_char,
) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_VARCHAR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(text: *const ::std::os::raw::c_char) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(text)
}

static __DUCKDB_CREATE_VARCHAR_LENGTH: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_varchar_length(
    text: *const ::std::os::raw::c_char,
    length: idx_t,
) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_VARCHAR_LENGTH
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        text: *const ::std::os::raw::c_char,
        length: idx_t,
    ) -> duckdb_value = ::std::mem::transmute(function_ptr);
    (fun)(text, length)
}

static __DUCKDB_CREATE_INT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_int64(val: i64) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_INT64
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: i64) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_CREATE_STRUCT_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_struct_value(
    type_: duckdb_logical_type,
    values: *mut duckdb_value,
) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_STRUCT_VALUE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
        values: *mut duckdb_value,
    ) -> duckdb_value = ::std::mem::transmute(function_ptr);
    (fun)(type_, values)
}

static __DUCKDB_CREATE_LIST_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_list_value(
    type_: duckdb_logical_type,
    values: *mut duckdb_value,
    value_count: idx_t,
) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_LIST_VALUE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
        values: *mut duckdb_value,
        value_count: idx_t,
    ) -> duckdb_value = ::std::mem::transmute(function_ptr);
    (fun)(type_, values, value_count)
}

static __DUCKDB_CREATE_ARRAY_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_array_value(
    type_: duckdb_logical_type,
    values: *mut duckdb_value,
    value_count: idx_t,
) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_ARRAY_VALUE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
        values: *mut duckdb_value,
        value_count: idx_t,
    ) -> duckdb_value = ::std::mem::transmute(function_ptr);
    (fun)(type_, values, value_count)
}

static __DUCKDB_GET_VARCHAR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_varchar(value: duckdb_value) -> *mut ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_GET_VARCHAR.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(value: duckdb_value) -> *mut ::std::os::raw::c_char = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(value)
}

static __DUCKDB_GET_INT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_int64(val: duckdb_value) -> i64 {
    let function_ptr = __DUCKDB_GET_INT64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> i64 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_CREATE_LOGICAL_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_logical_type(type_: duckdb_type) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_CREATE_LOGICAL_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_type) -> duckdb_logical_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_LOGICAL_TYPE_GET_ALIAS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_logical_type_get_alias(
    type_: duckdb_logical_type,
) -> *mut ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_LOGICAL_TYPE_GET_ALIAS
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
    ) -> *mut ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(type_)
}

static __DUCKDB_CREATE_LIST_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_list_type(
    type_: duckdb_logical_type,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_CREATE_LIST_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_CREATE_ARRAY_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_array_type(
    type_: duckdb_logical_type,
    array_size: idx_t,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_CREATE_ARRAY_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
        array_size: idx_t,
    ) -> duckdb_logical_type = ::std::mem::transmute(function_ptr);
    (fun)(type_, array_size)
}

static __DUCKDB_CREATE_MAP_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_map_type(
    key_type: duckdb_logical_type,
    value_type: duckdb_logical_type,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_CREATE_MAP_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        key_type: duckdb_logical_type,
        value_type: duckdb_logical_type,
    ) -> duckdb_logical_type = ::std::mem::transmute(function_ptr);
    (fun)(key_type, value_type)
}

static __DUCKDB_CREATE_UNION_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_union_type(
    member_types: *mut duckdb_logical_type,
    member_names: *mut *const ::std::os::raw::c_char,
    member_count: idx_t,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_CREATE_UNION_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        member_types: *mut duckdb_logical_type,
        member_names: *mut *const ::std::os::raw::c_char,
        member_count: idx_t,
    ) -> duckdb_logical_type = ::std::mem::transmute(function_ptr);
    (fun)(member_types, member_names, member_count)
}

static __DUCKDB_CREATE_STRUCT_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_struct_type(
    member_types: *mut duckdb_logical_type,
    member_names: *mut *const ::std::os::raw::c_char,
    member_count: idx_t,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_CREATE_STRUCT_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        member_types: *mut duckdb_logical_type,
        member_names: *mut *const ::std::os::raw::c_char,
        member_count: idx_t,
    ) -> duckdb_logical_type = ::std::mem::transmute(function_ptr);
    (fun)(member_types, member_names, member_count)
}

static __DUCKDB_CREATE_ENUM_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_enum_type(
    member_names: *mut *const ::std::os::raw::c_char,
    member_count: idx_t,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_CREATE_ENUM_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        member_names: *mut *const ::std::os::raw::c_char,
        member_count: idx_t,
    ) -> duckdb_logical_type = ::std::mem::transmute(function_ptr);
    (fun)(member_names, member_count)
}

static __DUCKDB_CREATE_DECIMAL_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_decimal_type(width: u8, scale: u8) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_CREATE_DECIMAL_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(width: u8, scale: u8) -> duckdb_logical_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(width, scale)
}

static __DUCKDB_GET_TYPE_ID: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_type_id(type_: duckdb_logical_type) -> duckdb_type {
    let function_ptr = __DUCKDB_GET_TYPE_ID.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_DECIMAL_WIDTH: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_decimal_width(type_: duckdb_logical_type) -> u8 {
    let function_ptr = __DUCKDB_DECIMAL_WIDTH
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> u8 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_DECIMAL_SCALE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_decimal_scale(type_: duckdb_logical_type) -> u8 {
    let function_ptr = __DUCKDB_DECIMAL_SCALE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> u8 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_DECIMAL_INTERNAL_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_decimal_internal_type(type_: duckdb_logical_type) -> duckdb_type {
    let function_ptr = __DUCKDB_DECIMAL_INTERNAL_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_ENUM_INTERNAL_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_enum_internal_type(type_: duckdb_logical_type) -> duckdb_type {
    let function_ptr = __DUCKDB_ENUM_INTERNAL_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_ENUM_DICTIONARY_SIZE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_enum_dictionary_size(type_: duckdb_logical_type) -> u32 {
    let function_ptr = __DUCKDB_ENUM_DICTIONARY_SIZE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> u32 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_ENUM_DICTIONARY_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_enum_dictionary_value(
    type_: duckdb_logical_type,
    index: idx_t,
) -> *mut ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_ENUM_DICTIONARY_VALUE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
        index: idx_t,
    ) -> *mut ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(type_, index)
}

static __DUCKDB_LIST_TYPE_CHILD_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_list_type_child_type(
    type_: duckdb_logical_type,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_LIST_TYPE_CHILD_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_ARRAY_TYPE_CHILD_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_array_type_child_type(
    type_: duckdb_logical_type,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_ARRAY_TYPE_CHILD_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_ARRAY_TYPE_ARRAY_SIZE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_array_type_array_size(type_: duckdb_logical_type) -> idx_t {
    let function_ptr = __DUCKDB_ARRAY_TYPE_ARRAY_SIZE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_MAP_TYPE_KEY_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_map_type_key_type(
    type_: duckdb_logical_type,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_MAP_TYPE_KEY_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_MAP_TYPE_VALUE_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_map_type_value_type(
    type_: duckdb_logical_type,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_MAP_TYPE_VALUE_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> duckdb_logical_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_STRUCT_TYPE_CHILD_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_struct_type_child_count(type_: duckdb_logical_type) -> idx_t {
    let function_ptr = __DUCKDB_STRUCT_TYPE_CHILD_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_STRUCT_TYPE_CHILD_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_struct_type_child_name(
    type_: duckdb_logical_type,
    index: idx_t,
) -> *mut ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_STRUCT_TYPE_CHILD_NAME
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
        index: idx_t,
    ) -> *mut ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(type_, index)
}

static __DUCKDB_STRUCT_TYPE_CHILD_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_struct_type_child_type(
    type_: duckdb_logical_type,
    index: idx_t,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_STRUCT_TYPE_CHILD_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
        index: idx_t,
    ) -> duckdb_logical_type = ::std::mem::transmute(function_ptr);
    (fun)(type_, index)
}

static __DUCKDB_UNION_TYPE_MEMBER_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_union_type_member_count(type_: duckdb_logical_type) -> idx_t {
    let function_ptr = __DUCKDB_UNION_TYPE_MEMBER_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: duckdb_logical_type) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_UNION_TYPE_MEMBER_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_union_type_member_name(
    type_: duckdb_logical_type,
    index: idx_t,
) -> *mut ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_UNION_TYPE_MEMBER_NAME
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
        index: idx_t,
    ) -> *mut ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(type_, index)
}

static __DUCKDB_UNION_TYPE_MEMBER_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_union_type_member_type(
    type_: duckdb_logical_type,
    index: idx_t,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_UNION_TYPE_MEMBER_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
        index: idx_t,
    ) -> duckdb_logical_type = ::std::mem::transmute(function_ptr);
    (fun)(type_, index)
}

static __DUCKDB_DESTROY_LOGICAL_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_logical_type(type_: *mut duckdb_logical_type) {
    let function_ptr = __DUCKDB_DESTROY_LOGICAL_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(type_: *mut duckdb_logical_type) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(type_)
}

static __DUCKDB_FETCH_CHUNK: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_fetch_chunk(result: duckdb_result) -> duckdb_data_chunk {
    let function_ptr = __DUCKDB_FETCH_CHUNK.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: duckdb_result) -> duckdb_data_chunk = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_CREATE_DATA_CHUNK: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_data_chunk(
    types: *mut duckdb_logical_type,
    column_count: idx_t,
) -> duckdb_data_chunk {
    let function_ptr = __DUCKDB_CREATE_DATA_CHUNK
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        types: *mut duckdb_logical_type,
        column_count: idx_t,
    ) -> duckdb_data_chunk = ::std::mem::transmute(function_ptr);
    (fun)(types, column_count)
}

static __DUCKDB_DESTROY_DATA_CHUNK: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_data_chunk(chunk: *mut duckdb_data_chunk) {
    let function_ptr = __DUCKDB_DESTROY_DATA_CHUNK
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(chunk: *mut duckdb_data_chunk) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(chunk)
}

static __DUCKDB_DATA_CHUNK_RESET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_data_chunk_reset(chunk: duckdb_data_chunk) {
    let function_ptr = __DUCKDB_DATA_CHUNK_RESET
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(chunk: duckdb_data_chunk) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(chunk)
}

static __DUCKDB_DATA_CHUNK_GET_COLUMN_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_data_chunk_get_column_count(chunk: duckdb_data_chunk) -> idx_t {
    let function_ptr = __DUCKDB_DATA_CHUNK_GET_COLUMN_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(chunk: duckdb_data_chunk) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(chunk)
}

static __DUCKDB_DATA_CHUNK_GET_VECTOR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_data_chunk_get_vector(
    chunk: duckdb_data_chunk,
    col_idx: idx_t,
) -> duckdb_vector {
    let function_ptr = __DUCKDB_DATA_CHUNK_GET_VECTOR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        chunk: duckdb_data_chunk,
        col_idx: idx_t,
    ) -> duckdb_vector = ::std::mem::transmute(function_ptr);
    (fun)(chunk, col_idx)
}

static __DUCKDB_DATA_CHUNK_GET_SIZE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_data_chunk_get_size(chunk: duckdb_data_chunk) -> idx_t {
    let function_ptr = __DUCKDB_DATA_CHUNK_GET_SIZE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(chunk: duckdb_data_chunk) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(chunk)
}

static __DUCKDB_DATA_CHUNK_SET_SIZE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_data_chunk_set_size(chunk: duckdb_data_chunk, size: idx_t) {
    let function_ptr = __DUCKDB_DATA_CHUNK_SET_SIZE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(chunk: duckdb_data_chunk, size: idx_t) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(chunk, size)
}

static __DUCKDB_VECTOR_GET_COLUMN_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_vector_get_column_type(
    vector: duckdb_vector,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_VECTOR_GET_COLUMN_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(vector: duckdb_vector) -> duckdb_logical_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(vector)
}

static __DUCKDB_VECTOR_GET_DATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_vector_get_data(
    vector: duckdb_vector,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_VECTOR_GET_DATA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        vector: duckdb_vector,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(vector)
}

static __DUCKDB_VECTOR_GET_VALIDITY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_vector_get_validity(vector: duckdb_vector) -> *mut u64 {
    let function_ptr = __DUCKDB_VECTOR_GET_VALIDITY
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(vector: duckdb_vector) -> *mut u64 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(vector)
}

static __DUCKDB_VECTOR_ENSURE_VALIDITY_WRITABLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_vector_ensure_validity_writable(vector: duckdb_vector) {
    let function_ptr = __DUCKDB_VECTOR_ENSURE_VALIDITY_WRITABLE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(vector: duckdb_vector) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(vector)
}

static __DUCKDB_VECTOR_ASSIGN_STRING_ELEMENT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_vector_assign_string_element(
    vector: duckdb_vector,
    index: idx_t,
    str_: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_VECTOR_ASSIGN_STRING_ELEMENT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        vector: duckdb_vector,
        index: idx_t,
        str_: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(vector, index, str_)
}

static __DUCKDB_VECTOR_ASSIGN_STRING_ELEMENT_LEN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_vector_assign_string_element_len(
    vector: duckdb_vector,
    index: idx_t,
    str_: *const ::std::os::raw::c_char,
    str_len: idx_t,
) {
    let function_ptr = __DUCKDB_VECTOR_ASSIGN_STRING_ELEMENT_LEN
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        vector: duckdb_vector,
        index: idx_t,
        str_: *const ::std::os::raw::c_char,
        str_len: idx_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(vector, index, str_, str_len)
}

static __DUCKDB_LIST_VECTOR_GET_CHILD: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_list_vector_get_child(vector: duckdb_vector) -> duckdb_vector {
    let function_ptr = __DUCKDB_LIST_VECTOR_GET_CHILD
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(vector: duckdb_vector) -> duckdb_vector = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(vector)
}

static __DUCKDB_LIST_VECTOR_GET_SIZE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_list_vector_get_size(vector: duckdb_vector) -> idx_t {
    let function_ptr = __DUCKDB_LIST_VECTOR_GET_SIZE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(vector: duckdb_vector) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(vector)
}

static __DUCKDB_LIST_VECTOR_SET_SIZE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_list_vector_set_size(
    vector: duckdb_vector,
    size: idx_t,
) -> duckdb_state {
    let function_ptr = __DUCKDB_LIST_VECTOR_SET_SIZE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(vector: duckdb_vector, size: idx_t) -> duckdb_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(vector, size)
}

static __DUCKDB_LIST_VECTOR_RESERVE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_list_vector_reserve(
    vector: duckdb_vector,
    required_capacity: idx_t,
) -> duckdb_state {
    let function_ptr = __DUCKDB_LIST_VECTOR_RESERVE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        vector: duckdb_vector,
        required_capacity: idx_t,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(vector, required_capacity)
}

static __DUCKDB_STRUCT_VECTOR_GET_CHILD: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_struct_vector_get_child(
    vector: duckdb_vector,
    index: idx_t,
) -> duckdb_vector {
    let function_ptr = __DUCKDB_STRUCT_VECTOR_GET_CHILD
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        vector: duckdb_vector,
        index: idx_t,
    ) -> duckdb_vector = ::std::mem::transmute(function_ptr);
    (fun)(vector, index)
}

static __DUCKDB_ARRAY_VECTOR_GET_CHILD: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_array_vector_get_child(vector: duckdb_vector) -> duckdb_vector {
    let function_ptr = __DUCKDB_ARRAY_VECTOR_GET_CHILD
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(vector: duckdb_vector) -> duckdb_vector = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(vector)
}

static __DUCKDB_VALIDITY_ROW_IS_VALID: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_validity_row_is_valid(validity: *mut u64, row: idx_t) -> bool {
    let function_ptr = __DUCKDB_VALIDITY_ROW_IS_VALID
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(validity: *mut u64, row: idx_t) -> bool = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(validity, row)
}

static __DUCKDB_VALIDITY_SET_ROW_VALIDITY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_validity_set_row_validity(
    validity: *mut u64,
    row: idx_t,
    valid: bool,
) {
    let function_ptr = __DUCKDB_VALIDITY_SET_ROW_VALIDITY
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(validity: *mut u64, row: idx_t, valid: bool) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(validity, row, valid)
}

static __DUCKDB_VALIDITY_SET_ROW_INVALID: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_validity_set_row_invalid(validity: *mut u64, row: idx_t) {
    let function_ptr = __DUCKDB_VALIDITY_SET_ROW_INVALID
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(validity: *mut u64, row: idx_t) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(validity, row)
}

static __DUCKDB_VALIDITY_SET_ROW_VALID: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_validity_set_row_valid(validity: *mut u64, row: idx_t) {
    let function_ptr = __DUCKDB_VALIDITY_SET_ROW_VALID
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(validity: *mut u64, row: idx_t) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(validity, row)
}

static __DUCKDB_CREATE_SCALAR_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_scalar_function() -> duckdb_scalar_function {
    let function_ptr = __DUCKDB_CREATE_SCALAR_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn() -> duckdb_scalar_function = ::std::mem::transmute(
        function_ptr,
    );
    (fun)()
}

static __DUCKDB_DESTROY_SCALAR_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_scalar_function(
    scalar_function: *mut duckdb_scalar_function,
) {
    let function_ptr = __DUCKDB_DESTROY_SCALAR_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(scalar_function: *mut duckdb_scalar_function) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(scalar_function)
}

static __DUCKDB_SCALAR_FUNCTION_SET_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_scalar_function_set_name(
    scalar_function: duckdb_scalar_function,
    name: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_SET_NAME
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        scalar_function: duckdb_scalar_function,
        name: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(scalar_function, name)
}

static __DUCKDB_SCALAR_FUNCTION_ADD_PARAMETER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_scalar_function_add_parameter(
    scalar_function: duckdb_scalar_function,
    type_: duckdb_logical_type,
) {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_ADD_PARAMETER
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        scalar_function: duckdb_scalar_function,
        type_: duckdb_logical_type,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(scalar_function, type_)
}

static __DUCKDB_SCALAR_FUNCTION_SET_RETURN_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_scalar_function_set_return_type(
    scalar_function: duckdb_scalar_function,
    type_: duckdb_logical_type,
) {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_SET_RETURN_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        scalar_function: duckdb_scalar_function,
        type_: duckdb_logical_type,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(scalar_function, type_)
}

static __DUCKDB_SCALAR_FUNCTION_SET_EXTRA_INFO: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_scalar_function_set_extra_info(
    scalar_function: duckdb_scalar_function,
    extra_info: *mut ::std::os::raw::c_void,
    destroy: duckdb_delete_callback_t,
) {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_SET_EXTRA_INFO
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        scalar_function: duckdb_scalar_function,
        extra_info: *mut ::std::os::raw::c_void,
        destroy: duckdb_delete_callback_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(scalar_function, extra_info, destroy)
}

static __DUCKDB_SCALAR_FUNCTION_SET_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_scalar_function_set_function(
    scalar_function: duckdb_scalar_function,
    function: duckdb_scalar_function_t,
) {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_SET_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        scalar_function: duckdb_scalar_function,
        function: duckdb_scalar_function_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(scalar_function, function)
}

static __DUCKDB_REGISTER_SCALAR_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_register_scalar_function(
    con: duckdb_connection,
    scalar_function: duckdb_scalar_function,
) -> duckdb_state {
    let function_ptr = __DUCKDB_REGISTER_SCALAR_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        con: duckdb_connection,
        scalar_function: duckdb_scalar_function,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(con, scalar_function)
}

static __DUCKDB_CREATE_TABLE_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_table_function() -> duckdb_table_function {
    let function_ptr = __DUCKDB_CREATE_TABLE_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn() -> duckdb_table_function = ::std::mem::transmute(
        function_ptr,
    );
    (fun)()
}

static __DUCKDB_DESTROY_TABLE_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_table_function(table_function: *mut duckdb_table_function) {
    let function_ptr = __DUCKDB_DESTROY_TABLE_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(table_function: *mut duckdb_table_function) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(table_function)
}

static __DUCKDB_TABLE_FUNCTION_SET_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_function_set_name(
    table_function: duckdb_table_function,
    name: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_TABLE_FUNCTION_SET_NAME
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_function: duckdb_table_function,
        name: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(table_function, name)
}

static __DUCKDB_TABLE_FUNCTION_ADD_PARAMETER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_function_add_parameter(
    table_function: duckdb_table_function,
    type_: duckdb_logical_type,
) {
    let function_ptr = __DUCKDB_TABLE_FUNCTION_ADD_PARAMETER
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_function: duckdb_table_function,
        type_: duckdb_logical_type,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(table_function, type_)
}

static __DUCKDB_TABLE_FUNCTION_ADD_NAMED_PARAMETER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_function_add_named_parameter(
    table_function: duckdb_table_function,
    name: *const ::std::os::raw::c_char,
    type_: duckdb_logical_type,
) {
    let function_ptr = __DUCKDB_TABLE_FUNCTION_ADD_NAMED_PARAMETER
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_function: duckdb_table_function,
        name: *const ::std::os::raw::c_char,
        type_: duckdb_logical_type,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(table_function, name, type_)
}

static __DUCKDB_TABLE_FUNCTION_SET_EXTRA_INFO: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_function_set_extra_info(
    table_function: duckdb_table_function,
    extra_info: *mut ::std::os::raw::c_void,
    destroy: duckdb_delete_callback_t,
) {
    let function_ptr = __DUCKDB_TABLE_FUNCTION_SET_EXTRA_INFO
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_function: duckdb_table_function,
        extra_info: *mut ::std::os::raw::c_void,
        destroy: duckdb_delete_callback_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(table_function, extra_info, destroy)
}

static __DUCKDB_TABLE_FUNCTION_SET_BIND: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_function_set_bind(
    table_function: duckdb_table_function,
    bind: duckdb_table_function_bind_t,
) {
    let function_ptr = __DUCKDB_TABLE_FUNCTION_SET_BIND
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_function: duckdb_table_function,
        bind: duckdb_table_function_bind_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(table_function, bind)
}

static __DUCKDB_TABLE_FUNCTION_SET_INIT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_function_set_init(
    table_function: duckdb_table_function,
    init: duckdb_table_function_init_t,
) {
    let function_ptr = __DUCKDB_TABLE_FUNCTION_SET_INIT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_function: duckdb_table_function,
        init: duckdb_table_function_init_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(table_function, init)
}

static __DUCKDB_TABLE_FUNCTION_SET_LOCAL_INIT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_function_set_local_init(
    table_function: duckdb_table_function,
    init: duckdb_table_function_init_t,
) {
    let function_ptr = __DUCKDB_TABLE_FUNCTION_SET_LOCAL_INIT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_function: duckdb_table_function,
        init: duckdb_table_function_init_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(table_function, init)
}

static __DUCKDB_TABLE_FUNCTION_SET_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_function_set_function(
    table_function: duckdb_table_function,
    function: duckdb_table_function_t,
) {
    let function_ptr = __DUCKDB_TABLE_FUNCTION_SET_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_function: duckdb_table_function,
        function: duckdb_table_function_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(table_function, function)
}

static __DUCKDB_TABLE_FUNCTION_SUPPORTS_PROJECTION_PUSHDOWN: ::std::sync::atomic::AtomicPtr<
    (),
> = ::std::sync::atomic::AtomicPtr::new(::std::ptr::null_mut());
pub unsafe fn duckdb_table_function_supports_projection_pushdown(
    table_function: duckdb_table_function,
    pushdown: bool,
) {
    let function_ptr = __DUCKDB_TABLE_FUNCTION_SUPPORTS_PROJECTION_PUSHDOWN
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_function: duckdb_table_function,
        pushdown: bool,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(table_function, pushdown)
}

static __DUCKDB_REGISTER_TABLE_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_register_table_function(
    con: duckdb_connection,
    function: duckdb_table_function,
) -> duckdb_state {
    let function_ptr = __DUCKDB_REGISTER_TABLE_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        con: duckdb_connection,
        function: duckdb_table_function,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(con, function)
}

static __DUCKDB_BIND_GET_EXTRA_INFO: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_get_extra_info(
    info: duckdb_bind_info,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_BIND_GET_EXTRA_INFO
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_bind_info,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_BIND_ADD_RESULT_COLUMN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_add_result_column(
    info: duckdb_bind_info,
    name: *const ::std::os::raw::c_char,
    type_: duckdb_logical_type,
) {
    let function_ptr = __DUCKDB_BIND_ADD_RESULT_COLUMN
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_bind_info,
        name: *const ::std::os::raw::c_char,
        type_: duckdb_logical_type,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, name, type_)
}

static __DUCKDB_BIND_GET_PARAMETER_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_get_parameter_count(info: duckdb_bind_info) -> idx_t {
    let function_ptr = __DUCKDB_BIND_GET_PARAMETER_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(info: duckdb_bind_info) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(info)
}

static __DUCKDB_BIND_GET_PARAMETER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_get_parameter(
    info: duckdb_bind_info,
    index: idx_t,
) -> duckdb_value {
    let function_ptr = __DUCKDB_BIND_GET_PARAMETER
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_bind_info,
        index: idx_t,
    ) -> duckdb_value = ::std::mem::transmute(function_ptr);
    (fun)(info, index)
}

static __DUCKDB_BIND_GET_NAMED_PARAMETER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_get_named_parameter(
    info: duckdb_bind_info,
    name: *const ::std::os::raw::c_char,
) -> duckdb_value {
    let function_ptr = __DUCKDB_BIND_GET_NAMED_PARAMETER
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_bind_info,
        name: *const ::std::os::raw::c_char,
    ) -> duckdb_value = ::std::mem::transmute(function_ptr);
    (fun)(info, name)
}

static __DUCKDB_BIND_SET_BIND_DATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_set_bind_data(
    info: duckdb_bind_info,
    bind_data: *mut ::std::os::raw::c_void,
    destroy: duckdb_delete_callback_t,
) {
    let function_ptr = __DUCKDB_BIND_SET_BIND_DATA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_bind_info,
        bind_data: *mut ::std::os::raw::c_void,
        destroy: duckdb_delete_callback_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, bind_data, destroy)
}

static __DUCKDB_BIND_SET_CARDINALITY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_set_cardinality(
    info: duckdb_bind_info,
    cardinality: idx_t,
    is_exact: bool,
) {
    let function_ptr = __DUCKDB_BIND_SET_CARDINALITY
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_bind_info,
        cardinality: idx_t,
        is_exact: bool,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, cardinality, is_exact)
}

static __DUCKDB_BIND_SET_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_bind_set_error(
    info: duckdb_bind_info,
    error: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_BIND_SET_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_bind_info,
        error: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, error)
}

static __DUCKDB_INIT_GET_EXTRA_INFO: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_init_get_extra_info(
    info: duckdb_init_info,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_INIT_GET_EXTRA_INFO
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_init_info,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_INIT_GET_BIND_DATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_init_get_bind_data(
    info: duckdb_init_info,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_INIT_GET_BIND_DATA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_init_info,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_INIT_SET_INIT_DATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_init_set_init_data(
    info: duckdb_init_info,
    init_data: *mut ::std::os::raw::c_void,
    destroy: duckdb_delete_callback_t,
) {
    let function_ptr = __DUCKDB_INIT_SET_INIT_DATA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_init_info,
        init_data: *mut ::std::os::raw::c_void,
        destroy: duckdb_delete_callback_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, init_data, destroy)
}

static __DUCKDB_INIT_GET_COLUMN_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_init_get_column_count(info: duckdb_init_info) -> idx_t {
    let function_ptr = __DUCKDB_INIT_GET_COLUMN_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(info: duckdb_init_info) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(info)
}

static __DUCKDB_INIT_GET_COLUMN_INDEX: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_init_get_column_index(
    info: duckdb_init_info,
    column_index: idx_t,
) -> idx_t {
    let function_ptr = __DUCKDB_INIT_GET_COLUMN_INDEX
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_init_info,
        column_index: idx_t,
    ) -> idx_t = ::std::mem::transmute(function_ptr);
    (fun)(info, column_index)
}

static __DUCKDB_INIT_SET_MAX_THREADS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_init_set_max_threads(info: duckdb_init_info, max_threads: idx_t) {
    let function_ptr = __DUCKDB_INIT_SET_MAX_THREADS
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(info: duckdb_init_info, max_threads: idx_t) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(info, max_threads)
}

static __DUCKDB_INIT_SET_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_init_set_error(
    info: duckdb_init_info,
    error: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_INIT_SET_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_init_info,
        error: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, error)
}

static __DUCKDB_FUNCTION_GET_EXTRA_INFO: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_function_get_extra_info(
    info: duckdb_function_info,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_FUNCTION_GET_EXTRA_INFO
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_function_info,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_FUNCTION_GET_BIND_DATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_function_get_bind_data(
    info: duckdb_function_info,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_FUNCTION_GET_BIND_DATA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_function_info,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_FUNCTION_GET_INIT_DATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_function_get_init_data(
    info: duckdb_function_info,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_FUNCTION_GET_INIT_DATA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_function_info,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_FUNCTION_GET_LOCAL_INIT_DATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_function_get_local_init_data(
    info: duckdb_function_info,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_FUNCTION_GET_LOCAL_INIT_DATA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_function_info,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_FUNCTION_SET_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_function_set_error(
    info: duckdb_function_info,
    error: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_FUNCTION_SET_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_function_info,
        error: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, error)
}

static __DUCKDB_ADD_REPLACEMENT_SCAN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_add_replacement_scan(
    db: duckdb_database,
    replacement: duckdb_replacement_callback_t,
    extra_data: *mut ::std::os::raw::c_void,
    delete_callback: duckdb_delete_callback_t,
) {
    let function_ptr = __DUCKDB_ADD_REPLACEMENT_SCAN
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        db: duckdb_database,
        replacement: duckdb_replacement_callback_t,
        extra_data: *mut ::std::os::raw::c_void,
        delete_callback: duckdb_delete_callback_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(db, replacement, extra_data, delete_callback)
}

static __DUCKDB_REPLACEMENT_SCAN_SET_FUNCTION_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_replacement_scan_set_function_name(
    info: duckdb_replacement_scan_info,
    function_name: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_REPLACEMENT_SCAN_SET_FUNCTION_NAME
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_replacement_scan_info,
        function_name: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, function_name)
}

static __DUCKDB_REPLACEMENT_SCAN_ADD_PARAMETER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_replacement_scan_add_parameter(
    info: duckdb_replacement_scan_info,
    parameter: duckdb_value,
) {
    let function_ptr = __DUCKDB_REPLACEMENT_SCAN_ADD_PARAMETER
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_replacement_scan_info,
        parameter: duckdb_value,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, parameter)
}

static __DUCKDB_REPLACEMENT_SCAN_SET_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_replacement_scan_set_error(
    info: duckdb_replacement_scan_info,
    error: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_REPLACEMENT_SCAN_SET_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_replacement_scan_info,
        error: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, error)
}

static __DUCKDB_APPENDER_CREATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_appender_create(
    connection: duckdb_connection,
    schema: *const ::std::os::raw::c_char,
    table: *const ::std::os::raw::c_char,
    out_appender: *mut duckdb_appender,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPENDER_CREATE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        connection: duckdb_connection,
        schema: *const ::std::os::raw::c_char,
        table: *const ::std::os::raw::c_char,
        out_appender: *mut duckdb_appender,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(connection, schema, table, out_appender)
}

static __DUCKDB_APPENDER_COLUMN_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_appender_column_count(appender: duckdb_appender) -> idx_t {
    let function_ptr = __DUCKDB_APPENDER_COLUMN_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(appender: duckdb_appender) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(appender)
}

static __DUCKDB_APPENDER_COLUMN_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_appender_column_type(
    appender: duckdb_appender,
    col_idx: idx_t,
) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_APPENDER_COLUMN_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        col_idx: idx_t,
    ) -> duckdb_logical_type = ::std::mem::transmute(function_ptr);
    (fun)(appender, col_idx)
}

static __DUCKDB_APPENDER_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_appender_error(
    appender: duckdb_appender,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_APPENDER_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(appender)
}

static __DUCKDB_APPENDER_FLUSH: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_appender_flush(appender: duckdb_appender) -> duckdb_state {
    let function_ptr = __DUCKDB_APPENDER_FLUSH
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(appender)
}

static __DUCKDB_APPENDER_CLOSE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_appender_close(appender: duckdb_appender) -> duckdb_state {
    let function_ptr = __DUCKDB_APPENDER_CLOSE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(appender)
}

static __DUCKDB_APPENDER_DESTROY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_appender_destroy(appender: *mut duckdb_appender) -> duckdb_state {
    let function_ptr = __DUCKDB_APPENDER_DESTROY
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(appender: *mut duckdb_appender) -> duckdb_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(appender)
}

static __DUCKDB_APPENDER_BEGIN_ROW: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_appender_begin_row(appender: duckdb_appender) -> duckdb_state {
    let function_ptr = __DUCKDB_APPENDER_BEGIN_ROW
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(appender)
}

static __DUCKDB_APPENDER_END_ROW: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_appender_end_row(appender: duckdb_appender) -> duckdb_state {
    let function_ptr = __DUCKDB_APPENDER_END_ROW
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(appender)
}

static __DUCKDB_APPEND_DEFAULT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_default(appender: duckdb_appender) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_DEFAULT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(appender)
}

static __DUCKDB_APPEND_BOOL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_bool(
    appender: duckdb_appender,
    value: bool,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_BOOL.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: bool,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_INT8: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_int8(appender: duckdb_appender, value: i8) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_INT8.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: i8,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_INT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_int16(
    appender: duckdb_appender,
    value: i16,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_INT16
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: i16,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_INT32: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_int32(
    appender: duckdb_appender,
    value: i32,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_INT32
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: i32,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_INT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_int64(
    appender: duckdb_appender,
    value: i64,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_INT64
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: i64,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_HUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_hugeint(
    appender: duckdb_appender,
    value: duckdb_hugeint,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_HUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: duckdb_hugeint,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_UINT8: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_uint8(appender: duckdb_appender, value: u8) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_UINT8
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: u8,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_UINT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_uint16(
    appender: duckdb_appender,
    value: u16,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_UINT16
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: u16,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_UINT32: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_uint32(
    appender: duckdb_appender,
    value: u32,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_UINT32
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: u32,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_UINT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_uint64(
    appender: duckdb_appender,
    value: u64,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_UINT64
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: u64,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_UHUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_uhugeint(
    appender: duckdb_appender,
    value: duckdb_uhugeint,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_UHUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: duckdb_uhugeint,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_FLOAT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_float(
    appender: duckdb_appender,
    value: f32,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_FLOAT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: f32,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_DOUBLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_double(
    appender: duckdb_appender,
    value: f64,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_DOUBLE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: f64,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_DATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_date(
    appender: duckdb_appender,
    value: duckdb_date,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_DATE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: duckdb_date,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_TIME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_time(
    appender: duckdb_appender,
    value: duckdb_time,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_TIME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: duckdb_time,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_TIMESTAMP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_timestamp(
    appender: duckdb_appender,
    value: duckdb_timestamp,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_TIMESTAMP
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: duckdb_timestamp,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_INTERVAL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_interval(
    appender: duckdb_appender,
    value: duckdb_interval,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_INTERVAL
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        value: duckdb_interval,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, value)
}

static __DUCKDB_APPEND_VARCHAR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_varchar(
    appender: duckdb_appender,
    val: *const ::std::os::raw::c_char,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_VARCHAR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        val: *const ::std::os::raw::c_char,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, val)
}

static __DUCKDB_APPEND_VARCHAR_LENGTH: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_varchar_length(
    appender: duckdb_appender,
    val: *const ::std::os::raw::c_char,
    length: idx_t,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_VARCHAR_LENGTH
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        val: *const ::std::os::raw::c_char,
        length: idx_t,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, val, length)
}

static __DUCKDB_APPEND_BLOB: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_blob(
    appender: duckdb_appender,
    data: *const ::std::os::raw::c_void,
    length: idx_t,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_BLOB.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        data: *const ::std::os::raw::c_void,
        length: idx_t,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, data, length)
}

static __DUCKDB_APPEND_NULL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_null(appender: duckdb_appender) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_NULL.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(appender: duckdb_appender) -> duckdb_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(appender)
}

static __DUCKDB_APPEND_DATA_CHUNK: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_append_data_chunk(
    appender: duckdb_appender,
    chunk: duckdb_data_chunk,
) -> duckdb_state {
    let function_ptr = __DUCKDB_APPEND_DATA_CHUNK
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        appender: duckdb_appender,
        chunk: duckdb_data_chunk,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(appender, chunk)
}

static __DUCKDB_EXECUTE_TASKS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_execute_tasks(database: duckdb_database, max_tasks: idx_t) {
    let function_ptr = __DUCKDB_EXECUTE_TASKS
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(database: duckdb_database, max_tasks: idx_t) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(database, max_tasks)
}

static __DUCKDB_CREATE_TASK_STATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_task_state(database: duckdb_database) -> duckdb_task_state {
    let function_ptr = __DUCKDB_CREATE_TASK_STATE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(database: duckdb_database) -> duckdb_task_state = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(database)
}

static __DUCKDB_EXECUTE_TASKS_STATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_execute_tasks_state(state: duckdb_task_state) {
    let function_ptr = __DUCKDB_EXECUTE_TASKS_STATE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(state: duckdb_task_state) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(state)
}

static __DUCKDB_EXECUTE_N_TASKS_STATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_execute_n_tasks_state(
    state: duckdb_task_state,
    max_tasks: idx_t,
) -> idx_t {
    let function_ptr = __DUCKDB_EXECUTE_N_TASKS_STATE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(state: duckdb_task_state, max_tasks: idx_t) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(state, max_tasks)
}

static __DUCKDB_FINISH_EXECUTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_finish_execution(state: duckdb_task_state) {
    let function_ptr = __DUCKDB_FINISH_EXECUTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(state: duckdb_task_state) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(state)
}

static __DUCKDB_TASK_STATE_IS_FINISHED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_task_state_is_finished(state: duckdb_task_state) -> bool {
    let function_ptr = __DUCKDB_TASK_STATE_IS_FINISHED
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(state: duckdb_task_state) -> bool = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(state)
}

static __DUCKDB_DESTROY_TASK_STATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_task_state(state: duckdb_task_state) {
    let function_ptr = __DUCKDB_DESTROY_TASK_STATE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(state: duckdb_task_state) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(state)
}

static __DUCKDB_EXECUTION_IS_FINISHED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_execution_is_finished(con: duckdb_connection) -> bool {
    let function_ptr = __DUCKDB_EXECUTION_IS_FINISHED
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(con: duckdb_connection) -> bool = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(con)
}

static __DUCKDB_GET_PROFILING_INFO: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_profiling_info(
    connection: duckdb_connection,
) -> duckdb_profiling_info {
    let function_ptr = __DUCKDB_GET_PROFILING_INFO
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        connection: duckdb_connection,
    ) -> duckdb_profiling_info = ::std::mem::transmute(function_ptr);
    (fun)(connection)
}

static __DUCKDB_PROFILING_INFO_GET_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_profiling_info_get_value(
    info: duckdb_profiling_info,
    key: *const ::std::os::raw::c_char,
) -> duckdb_value {
    let function_ptr = __DUCKDB_PROFILING_INFO_GET_VALUE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_profiling_info,
        key: *const ::std::os::raw::c_char,
    ) -> duckdb_value = ::std::mem::transmute(function_ptr);
    (fun)(info, key)
}

static __DUCKDB_PROFILING_INFO_GET_CHILD_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_profiling_info_get_child_count(
    info: duckdb_profiling_info,
) -> idx_t {
    let function_ptr = __DUCKDB_PROFILING_INFO_GET_CHILD_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(info: duckdb_profiling_info) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(info)
}

static __DUCKDB_PROFILING_INFO_GET_CHILD: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_profiling_info_get_child(
    info: duckdb_profiling_info,
    index: idx_t,
) -> duckdb_profiling_info {
    let function_ptr = __DUCKDB_PROFILING_INFO_GET_CHILD
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_profiling_info,
        index: idx_t,
    ) -> duckdb_profiling_info = ::std::mem::transmute(function_ptr);
    (fun)(info, index)
}

static __DUCKDB_PROFILING_INFO_GET_METRICS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_profiling_info_get_metrics(
    info: duckdb_profiling_info,
) -> duckdb_value {
    let function_ptr = __DUCKDB_PROFILING_INFO_GET_METRICS
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(info: duckdb_profiling_info) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(info)
}

static __DUCKDB_SCALAR_FUNCTION_SET_VARARGS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_scalar_function_set_varargs(
    scalar_function: duckdb_scalar_function,
    type_: duckdb_logical_type,
) {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_SET_VARARGS
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        scalar_function: duckdb_scalar_function,
        type_: duckdb_logical_type,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(scalar_function, type_)
}

static __DUCKDB_SCALAR_FUNCTION_SET_SPECIAL_HANDLING: ::std::sync::atomic::AtomicPtr<
    (),
> = ::std::sync::atomic::AtomicPtr::new(::std::ptr::null_mut());
pub unsafe fn duckdb_scalar_function_set_special_handling(
    scalar_function: duckdb_scalar_function,
) {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_SET_SPECIAL_HANDLING
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(scalar_function: duckdb_scalar_function) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(scalar_function)
}

static __DUCKDB_SCALAR_FUNCTION_SET_VOLATILE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_scalar_function_set_volatile(
    scalar_function: duckdb_scalar_function,
) {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_SET_VOLATILE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(scalar_function: duckdb_scalar_function) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(scalar_function)
}

static __DUCKDB_SCALAR_FUNCTION_GET_EXTRA_INFO: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_scalar_function_get_extra_info(
    info: duckdb_function_info,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_GET_EXTRA_INFO
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_function_info,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_SCALAR_FUNCTION_SET_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_scalar_function_set_error(
    info: duckdb_function_info,
    error: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_SCALAR_FUNCTION_SET_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_function_info,
        error: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, error)
}

static __DUCKDB_TABLE_DESCRIPTION_CREATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_description_create(
    connection: duckdb_connection,
    schema: *const ::std::os::raw::c_char,
    table: *const ::std::os::raw::c_char,
    out: *mut duckdb_table_description,
) -> duckdb_state {
    let function_ptr = __DUCKDB_TABLE_DESCRIPTION_CREATE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        connection: duckdb_connection,
        schema: *const ::std::os::raw::c_char,
        table: *const ::std::os::raw::c_char,
        out: *mut duckdb_table_description,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(connection, schema, table, out)
}

static __DUCKDB_TABLE_DESCRIPTION_DESTROY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_description_destroy(
    table_description: *mut duckdb_table_description,
) {
    let function_ptr = __DUCKDB_TABLE_DESCRIPTION_DESTROY
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(table_description: *mut duckdb_table_description) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(table_description)
}

static __DUCKDB_TABLE_DESCRIPTION_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_table_description_error(
    table_description: duckdb_table_description,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_TABLE_DESCRIPTION_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_description: duckdb_table_description,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(table_description)
}

static __DUCKDB_RESULT_ERROR_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_result_error_type(result: *mut duckdb_result) -> duckdb_error_type {
    let function_ptr = __DUCKDB_RESULT_ERROR_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: *mut duckdb_result) -> duckdb_error_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_STRING_T_LENGTH: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_string_t_length(string: duckdb_string_t) -> u32 {
    let function_ptr = __DUCKDB_STRING_T_LENGTH
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(string: duckdb_string_t) -> u32 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(string)
}

static __DUCKDB_STRING_T_DATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_string_t_data(
    string: *mut duckdb_string_t,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_STRING_T_DATA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        string: *mut duckdb_string_t,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(string)
}

static __DUCKDB_CREATE_BOOL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_bool(input: bool) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_BOOL.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: bool) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_INT8: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_int8(input: i8) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_INT8.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: i8) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_UINT8: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_uint8(input: u8) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_UINT8
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: u8) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_INT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_int16(input: i16) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_INT16
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: i16) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_UINT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_uint16(input: u16) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_UINT16
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: u16) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_INT32: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_int32(input: i32) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_INT32
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: i32) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_UINT32: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_uint32(input: u32) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_UINT32
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: u32) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_UINT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_uint64(input: u64) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_UINT64
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: u64) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_HUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_hugeint(input: duckdb_hugeint) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_HUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: duckdb_hugeint) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_UHUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_uhugeint(input: duckdb_uhugeint) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_UHUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: duckdb_uhugeint) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_FLOAT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_float(input: f32) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_FLOAT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: f32) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_DOUBLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_double(input: f64) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_DOUBLE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: f64) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_DATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_date(input: duckdb_date) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_DATE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: duckdb_date) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_TIME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_time(input: duckdb_time) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_TIME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: duckdb_time) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_TIME_TZ_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_time_tz_value(value: duckdb_time_tz) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_TIME_TZ_VALUE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(value: duckdb_time_tz) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(value)
}

static __DUCKDB_CREATE_TIMESTAMP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_timestamp(input: duckdb_timestamp) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_TIMESTAMP
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: duckdb_timestamp) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_INTERVAL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_interval(input: duckdb_interval) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_INTERVAL
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(input: duckdb_interval) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(input)
}

static __DUCKDB_CREATE_BLOB: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_blob(data: *const u8, length: idx_t) -> duckdb_value {
    let function_ptr = __DUCKDB_CREATE_BLOB.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(data: *const u8, length: idx_t) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(data, length)
}

static __DUCKDB_GET_BOOL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_bool(val: duckdb_value) -> bool {
    let function_ptr = __DUCKDB_GET_BOOL.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> bool = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_INT8: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_int8(val: duckdb_value) -> i8 {
    let function_ptr = __DUCKDB_GET_INT8.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> i8 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_UINT8: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_uint8(val: duckdb_value) -> u8 {
    let function_ptr = __DUCKDB_GET_UINT8.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> u8 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_INT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_int16(val: duckdb_value) -> i16 {
    let function_ptr = __DUCKDB_GET_INT16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> i16 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_UINT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_uint16(val: duckdb_value) -> u16 {
    let function_ptr = __DUCKDB_GET_UINT16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> u16 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_INT32: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_int32(val: duckdb_value) -> i32 {
    let function_ptr = __DUCKDB_GET_INT32.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> i32 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_UINT32: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_uint32(val: duckdb_value) -> u32 {
    let function_ptr = __DUCKDB_GET_UINT32.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> u32 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_UINT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_uint64(val: duckdb_value) -> u64 {
    let function_ptr = __DUCKDB_GET_UINT64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> u64 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_HUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_hugeint(val: duckdb_value) -> duckdb_hugeint {
    let function_ptr = __DUCKDB_GET_HUGEINT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> duckdb_hugeint = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_UHUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_uhugeint(val: duckdb_value) -> duckdb_uhugeint {
    let function_ptr = __DUCKDB_GET_UHUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> duckdb_uhugeint = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_FLOAT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_float(val: duckdb_value) -> f32 {
    let function_ptr = __DUCKDB_GET_FLOAT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> f32 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_DOUBLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_double(val: duckdb_value) -> f64 {
    let function_ptr = __DUCKDB_GET_DOUBLE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> f64 = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_DATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_date(val: duckdb_value) -> duckdb_date {
    let function_ptr = __DUCKDB_GET_DATE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> duckdb_date = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_TIME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_time(val: duckdb_value) -> duckdb_time {
    let function_ptr = __DUCKDB_GET_TIME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> duckdb_time = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_TIME_TZ: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_time_tz(val: duckdb_value) -> duckdb_time_tz {
    let function_ptr = __DUCKDB_GET_TIME_TZ.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> duckdb_time_tz = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_TIMESTAMP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_timestamp(val: duckdb_value) -> duckdb_timestamp {
    let function_ptr = __DUCKDB_GET_TIMESTAMP
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> duckdb_timestamp = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_INTERVAL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_interval(val: duckdb_value) -> duckdb_interval {
    let function_ptr = __DUCKDB_GET_INTERVAL
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> duckdb_interval = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_VALUE_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_value_type(val: duckdb_value) -> duckdb_logical_type {
    let function_ptr = __DUCKDB_GET_VALUE_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> duckdb_logical_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_GET_BLOB: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_blob(val: duckdb_value) -> duckdb_blob {
    let function_ptr = __DUCKDB_GET_BLOB.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(val: duckdb_value) -> duckdb_blob = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(val)
}

static __DUCKDB_CREATE_SCALAR_FUNCTION_SET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_scalar_function_set(
    name: *const ::std::os::raw::c_char,
) -> duckdb_scalar_function_set {
    let function_ptr = __DUCKDB_CREATE_SCALAR_FUNCTION_SET
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
    ) -> duckdb_scalar_function_set = ::std::mem::transmute(function_ptr);
    (fun)(name)
}

static __DUCKDB_DESTROY_SCALAR_FUNCTION_SET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_scalar_function_set(
    scalar_function_set: *mut duckdb_scalar_function_set,
) {
    let function_ptr = __DUCKDB_DESTROY_SCALAR_FUNCTION_SET
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        scalar_function_set: *mut duckdb_scalar_function_set,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(scalar_function_set)
}

static __DUCKDB_ADD_SCALAR_FUNCTION_TO_SET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_add_scalar_function_to_set(
    set: duckdb_scalar_function_set,
    function: duckdb_scalar_function,
) -> duckdb_state {
    let function_ptr = __DUCKDB_ADD_SCALAR_FUNCTION_TO_SET
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        set: duckdb_scalar_function_set,
        function: duckdb_scalar_function,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(set, function)
}

static __DUCKDB_REGISTER_SCALAR_FUNCTION_SET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_register_scalar_function_set(
    con: duckdb_connection,
    set: duckdb_scalar_function_set,
) -> duckdb_state {
    let function_ptr = __DUCKDB_REGISTER_SCALAR_FUNCTION_SET
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        con: duckdb_connection,
        set: duckdb_scalar_function_set,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(con, set)
}

static __DUCKDB_CREATE_AGGREGATE_FUNCTION_SET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_aggregate_function_set(
    name: *const ::std::os::raw::c_char,
) -> duckdb_aggregate_function_set {
    let function_ptr = __DUCKDB_CREATE_AGGREGATE_FUNCTION_SET
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
    ) -> duckdb_aggregate_function_set = ::std::mem::transmute(function_ptr);
    (fun)(name)
}

static __DUCKDB_DESTROY_AGGREGATE_FUNCTION_SET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_aggregate_function_set(
    aggregate_function_set: *mut duckdb_aggregate_function_set,
) {
    let function_ptr = __DUCKDB_DESTROY_AGGREGATE_FUNCTION_SET
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        aggregate_function_set: *mut duckdb_aggregate_function_set,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(aggregate_function_set)
}

static __DUCKDB_ADD_AGGREGATE_FUNCTION_TO_SET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_add_aggregate_function_to_set(
    set: duckdb_aggregate_function_set,
    function: duckdb_aggregate_function,
) -> duckdb_state {
    let function_ptr = __DUCKDB_ADD_AGGREGATE_FUNCTION_TO_SET
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        set: duckdb_aggregate_function_set,
        function: duckdb_aggregate_function,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(set, function)
}

static __DUCKDB_REGISTER_AGGREGATE_FUNCTION_SET: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_register_aggregate_function_set(
    con: duckdb_connection,
    set: duckdb_aggregate_function_set,
) -> duckdb_state {
    let function_ptr = __DUCKDB_REGISTER_AGGREGATE_FUNCTION_SET
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        con: duckdb_connection,
        set: duckdb_aggregate_function_set,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(con, set)
}

static __DUCKDB_GET_MAP_SIZE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_map_size(value: duckdb_value) -> idx_t {
    let function_ptr = __DUCKDB_GET_MAP_SIZE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(value: duckdb_value) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(value)
}

static __DUCKDB_GET_MAP_KEY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_map_key(value: duckdb_value, index: idx_t) -> duckdb_value {
    let function_ptr = __DUCKDB_GET_MAP_KEY.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(value: duckdb_value, index: idx_t) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(value, index)
}

static __DUCKDB_GET_MAP_VALUE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_get_map_value(value: duckdb_value, index: idx_t) -> duckdb_value {
    let function_ptr = __DUCKDB_GET_MAP_VALUE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(value: duckdb_value, index: idx_t) -> duckdb_value = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(value, index)
}

static __DUCKDB_CREATE_AGGREGATE_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_aggregate_function() -> duckdb_aggregate_function {
    let function_ptr = __DUCKDB_CREATE_AGGREGATE_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn() -> duckdb_aggregate_function = ::std::mem::transmute(
        function_ptr,
    );
    (fun)()
}

static __DUCKDB_DESTROY_AGGREGATE_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_aggregate_function(
    aggregate_function: *mut duckdb_aggregate_function,
) {
    let function_ptr = __DUCKDB_DESTROY_AGGREGATE_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(aggregate_function: *mut duckdb_aggregate_function) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(aggregate_function)
}

static __DUCKDB_AGGREGATE_FUNCTION_SET_NAME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_aggregate_function_set_name(
    aggregate_function: duckdb_aggregate_function,
    name: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_AGGREGATE_FUNCTION_SET_NAME
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        aggregate_function: duckdb_aggregate_function,
        name: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(aggregate_function, name)
}

static __DUCKDB_AGGREGATE_FUNCTION_ADD_PARAMETER: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_aggregate_function_add_parameter(
    aggregate_function: duckdb_aggregate_function,
    type_: duckdb_logical_type,
) {
    let function_ptr = __DUCKDB_AGGREGATE_FUNCTION_ADD_PARAMETER
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        aggregate_function: duckdb_aggregate_function,
        type_: duckdb_logical_type,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(aggregate_function, type_)
}

static __DUCKDB_AGGREGATE_FUNCTION_SET_RETURN_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_aggregate_function_set_return_type(
    aggregate_function: duckdb_aggregate_function,
    type_: duckdb_logical_type,
) {
    let function_ptr = __DUCKDB_AGGREGATE_FUNCTION_SET_RETURN_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        aggregate_function: duckdb_aggregate_function,
        type_: duckdb_logical_type,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(aggregate_function, type_)
}

static __DUCKDB_AGGREGATE_FUNCTION_SET_FUNCTIONS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_aggregate_function_set_functions(
    aggregate_function: duckdb_aggregate_function,
    state_size: duckdb_aggregate_state_size,
    state_init: duckdb_aggregate_init_t,
    update: duckdb_aggregate_update_t,
    combine: duckdb_aggregate_combine_t,
    finalize: duckdb_aggregate_finalize_t,
) {
    let function_ptr = __DUCKDB_AGGREGATE_FUNCTION_SET_FUNCTIONS
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        aggregate_function: duckdb_aggregate_function,
        state_size: duckdb_aggregate_state_size,
        state_init: duckdb_aggregate_init_t,
        update: duckdb_aggregate_update_t,
        combine: duckdb_aggregate_combine_t,
        finalize: duckdb_aggregate_finalize_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(aggregate_function, state_size, state_init, update, combine, finalize)
}

static __DUCKDB_AGGREGATE_FUNCTION_SET_DESTRUCTOR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_aggregate_function_set_destructor(
    aggregate_function: duckdb_aggregate_function,
    destroy: duckdb_aggregate_destroy_t,
) {
    let function_ptr = __DUCKDB_AGGREGATE_FUNCTION_SET_DESTRUCTOR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        aggregate_function: duckdb_aggregate_function,
        destroy: duckdb_aggregate_destroy_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(aggregate_function, destroy)
}

static __DUCKDB_REGISTER_AGGREGATE_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_register_aggregate_function(
    con: duckdb_connection,
    aggregate_function: duckdb_aggregate_function,
) -> duckdb_state {
    let function_ptr = __DUCKDB_REGISTER_AGGREGATE_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        con: duckdb_connection,
        aggregate_function: duckdb_aggregate_function,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(con, aggregate_function)
}

static __DUCKDB_AGGREGATE_FUNCTION_SET_SPECIAL_HANDLING: ::std::sync::atomic::AtomicPtr<
    (),
> = ::std::sync::atomic::AtomicPtr::new(::std::ptr::null_mut());
pub unsafe fn duckdb_aggregate_function_set_special_handling(
    aggregate_function: duckdb_aggregate_function,
) {
    let function_ptr = __DUCKDB_AGGREGATE_FUNCTION_SET_SPECIAL_HANDLING
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(aggregate_function: duckdb_aggregate_function) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(aggregate_function)
}

static __DUCKDB_AGGREGATE_FUNCTION_SET_EXTRA_INFO: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_aggregate_function_set_extra_info(
    aggregate_function: duckdb_aggregate_function,
    extra_info: *mut ::std::os::raw::c_void,
    destroy: duckdb_delete_callback_t,
) {
    let function_ptr = __DUCKDB_AGGREGATE_FUNCTION_SET_EXTRA_INFO
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        aggregate_function: duckdb_aggregate_function,
        extra_info: *mut ::std::os::raw::c_void,
        destroy: duckdb_delete_callback_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(aggregate_function, extra_info, destroy)
}

static __DUCKDB_AGGREGATE_FUNCTION_GET_EXTRA_INFO: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_aggregate_function_get_extra_info(
    info: duckdb_function_info,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_AGGREGATE_FUNCTION_GET_EXTRA_INFO
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_function_info,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_AGGREGATE_FUNCTION_SET_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_aggregate_function_set_error(
    info: duckdb_function_info,
    error: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_AGGREGATE_FUNCTION_SET_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_function_info,
        error: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, error)
}

static __DUCKDB_LOGICAL_TYPE_SET_ALIAS: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_logical_type_set_alias(
    type_: duckdb_logical_type,
    alias: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_LOGICAL_TYPE_SET_ALIAS
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        type_: duckdb_logical_type,
        alias: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(type_, alias)
}

static __DUCKDB_REGISTER_LOGICAL_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_register_logical_type(
    con: duckdb_connection,
    type_: duckdb_logical_type,
    info: duckdb_create_type_info,
) -> duckdb_state {
    let function_ptr = __DUCKDB_REGISTER_LOGICAL_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        con: duckdb_connection,
        type_: duckdb_logical_type,
        info: duckdb_create_type_info,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(con, type_, info)
}

static __DUCKDB_CREATE_CAST_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_create_cast_function() -> duckdb_cast_function {
    let function_ptr = __DUCKDB_CREATE_CAST_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn() -> duckdb_cast_function = ::std::mem::transmute(
        function_ptr,
    );
    (fun)()
}

static __DUCKDB_CAST_FUNCTION_SET_SOURCE_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_cast_function_set_source_type(
    cast_function: duckdb_cast_function,
    source_type: duckdb_logical_type,
) {
    let function_ptr = __DUCKDB_CAST_FUNCTION_SET_SOURCE_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        cast_function: duckdb_cast_function,
        source_type: duckdb_logical_type,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(cast_function, source_type)
}

static __DUCKDB_CAST_FUNCTION_SET_TARGET_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_cast_function_set_target_type(
    cast_function: duckdb_cast_function,
    target_type: duckdb_logical_type,
) {
    let function_ptr = __DUCKDB_CAST_FUNCTION_SET_TARGET_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        cast_function: duckdb_cast_function,
        target_type: duckdb_logical_type,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(cast_function, target_type)
}

static __DUCKDB_CAST_FUNCTION_SET_IMPLICIT_CAST_COST: ::std::sync::atomic::AtomicPtr<
    (),
> = ::std::sync::atomic::AtomicPtr::new(::std::ptr::null_mut());
pub unsafe fn duckdb_cast_function_set_implicit_cast_cost(
    cast_function: duckdb_cast_function,
    cost: i64,
) {
    let function_ptr = __DUCKDB_CAST_FUNCTION_SET_IMPLICIT_CAST_COST
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(cast_function: duckdb_cast_function, cost: i64) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(cast_function, cost)
}

static __DUCKDB_CAST_FUNCTION_SET_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_cast_function_set_function(
    cast_function: duckdb_cast_function,
    function: duckdb_cast_function_t,
) {
    let function_ptr = __DUCKDB_CAST_FUNCTION_SET_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        cast_function: duckdb_cast_function,
        function: duckdb_cast_function_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(cast_function, function)
}

static __DUCKDB_CAST_FUNCTION_SET_EXTRA_INFO: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_cast_function_set_extra_info(
    cast_function: duckdb_cast_function,
    extra_info: *mut ::std::os::raw::c_void,
    destroy: duckdb_delete_callback_t,
) {
    let function_ptr = __DUCKDB_CAST_FUNCTION_SET_EXTRA_INFO
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        cast_function: duckdb_cast_function,
        extra_info: *mut ::std::os::raw::c_void,
        destroy: duckdb_delete_callback_t,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(cast_function, extra_info, destroy)
}

static __DUCKDB_CAST_FUNCTION_GET_EXTRA_INFO: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_cast_function_get_extra_info(
    info: duckdb_function_info,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_CAST_FUNCTION_GET_EXTRA_INFO
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_function_info,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(info)
}

static __DUCKDB_CAST_FUNCTION_GET_CAST_MODE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_cast_function_get_cast_mode(
    info: duckdb_function_info,
) -> duckdb_cast_mode {
    let function_ptr = __DUCKDB_CAST_FUNCTION_GET_CAST_MODE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(info: duckdb_function_info) -> duckdb_cast_mode = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(info)
}

static __DUCKDB_CAST_FUNCTION_SET_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_cast_function_set_error(
    info: duckdb_function_info,
    error: *const ::std::os::raw::c_char,
) {
    let function_ptr = __DUCKDB_CAST_FUNCTION_SET_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_function_info,
        error: *const ::std::os::raw::c_char,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, error)
}

static __DUCKDB_CAST_FUNCTION_SET_ROW_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_cast_function_set_row_error(
    info: duckdb_function_info,
    error: *const ::std::os::raw::c_char,
    row: idx_t,
    output: duckdb_vector,
) {
    let function_ptr = __DUCKDB_CAST_FUNCTION_SET_ROW_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        info: duckdb_function_info,
        error: *const ::std::os::raw::c_char,
        row: idx_t,
        output: duckdb_vector,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(info, error, row, output)
}

static __DUCKDB_REGISTER_CAST_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_register_cast_function(
    con: duckdb_connection,
    cast_function: duckdb_cast_function,
) -> duckdb_state {
    let function_ptr = __DUCKDB_REGISTER_CAST_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        con: duckdb_connection,
        cast_function: duckdb_cast_function,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(con, cast_function)
}

static __DUCKDB_DESTROY_CAST_FUNCTION: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_cast_function(cast_function: *mut duckdb_cast_function) {
    let function_ptr = __DUCKDB_DESTROY_CAST_FUNCTION
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(cast_function: *mut duckdb_cast_function) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(cast_function)
}

static __DUCKDB_ROW_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_row_count(result: *mut duckdb_result) -> idx_t {
    let function_ptr = __DUCKDB_ROW_COUNT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: *mut duckdb_result) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_COLUMN_DATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_column_data(
    result: *mut duckdb_result,
    col: idx_t,
) -> *mut ::std::os::raw::c_void {
    let function_ptr = __DUCKDB_COLUMN_DATA.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
    ) -> *mut ::std::os::raw::c_void = ::std::mem::transmute(function_ptr);
    (fun)(result, col)
}

static __DUCKDB_NULLMASK_DATA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_nullmask_data(result: *mut duckdb_result, col: idx_t) -> *mut bool {
    let function_ptr = __DUCKDB_NULLMASK_DATA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: *mut duckdb_result, col: idx_t) -> *mut bool = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result, col)
}

static __DUCKDB_RESULT_GET_CHUNK: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_result_get_chunk(
    result: duckdb_result,
    chunk_index: idx_t,
) -> duckdb_data_chunk {
    let function_ptr = __DUCKDB_RESULT_GET_CHUNK
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: duckdb_result,
        chunk_index: idx_t,
    ) -> duckdb_data_chunk = ::std::mem::transmute(function_ptr);
    (fun)(result, chunk_index)
}

static __DUCKDB_RESULT_IS_STREAMING: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_result_is_streaming(result: duckdb_result) -> bool {
    let function_ptr = __DUCKDB_RESULT_IS_STREAMING
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: duckdb_result) -> bool = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_RESULT_CHUNK_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_result_chunk_count(result: duckdb_result) -> idx_t {
    let function_ptr = __DUCKDB_RESULT_CHUNK_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: duckdb_result) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_RESULT_RETURN_TYPE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_result_return_type(result: duckdb_result) -> duckdb_result_type {
    let function_ptr = __DUCKDB_RESULT_RETURN_TYPE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: duckdb_result) -> duckdb_result_type = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_VALUE_BOOLEAN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_boolean(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> bool {
    let function_ptr = __DUCKDB_VALUE_BOOLEAN
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> bool = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_INT8: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_int8(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> i8 {
    let function_ptr = __DUCKDB_VALUE_INT8.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> i8 = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_INT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_int16(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> i16 {
    let function_ptr = __DUCKDB_VALUE_INT16.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> i16 = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_INT32: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_int32(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> i32 {
    let function_ptr = __DUCKDB_VALUE_INT32.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> i32 = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_INT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_int64(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> i64 {
    let function_ptr = __DUCKDB_VALUE_INT64.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> i64 = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_HUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_hugeint(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> duckdb_hugeint {
    let function_ptr = __DUCKDB_VALUE_HUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> duckdb_hugeint = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_UHUGEINT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_uhugeint(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> duckdb_uhugeint {
    let function_ptr = __DUCKDB_VALUE_UHUGEINT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> duckdb_uhugeint = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_DECIMAL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_decimal(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> duckdb_decimal {
    let function_ptr = __DUCKDB_VALUE_DECIMAL
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> duckdb_decimal = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_UINT8: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_uint8(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> u8 {
    let function_ptr = __DUCKDB_VALUE_UINT8.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> u8 = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_UINT16: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_uint16(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> u16 {
    let function_ptr = __DUCKDB_VALUE_UINT16
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> u16 = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_UINT32: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_uint32(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> u32 {
    let function_ptr = __DUCKDB_VALUE_UINT32
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> u32 = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_UINT64: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_uint64(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> u64 {
    let function_ptr = __DUCKDB_VALUE_UINT64
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> u64 = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_FLOAT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_float(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> f32 {
    let function_ptr = __DUCKDB_VALUE_FLOAT.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> f32 = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_DOUBLE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_double(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> f64 {
    let function_ptr = __DUCKDB_VALUE_DOUBLE
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> f64 = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_DATE: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_date(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> duckdb_date {
    let function_ptr = __DUCKDB_VALUE_DATE.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> duckdb_date = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_TIME: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_time(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> duckdb_time {
    let function_ptr = __DUCKDB_VALUE_TIME.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> duckdb_time = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_TIMESTAMP: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_timestamp(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> duckdb_timestamp {
    let function_ptr = __DUCKDB_VALUE_TIMESTAMP
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> duckdb_timestamp = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_INTERVAL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_interval(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> duckdb_interval {
    let function_ptr = __DUCKDB_VALUE_INTERVAL
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> duckdb_interval = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_VARCHAR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_varchar(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> *mut ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_VALUE_VARCHAR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> *mut ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_STRING: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_string(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> duckdb_string {
    let function_ptr = __DUCKDB_VALUE_STRING
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> duckdb_string = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_VARCHAR_INTERNAL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_varchar_internal(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> *mut ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_VALUE_VARCHAR_INTERNAL
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> *mut ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_STRING_INTERNAL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_string_internal(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> duckdb_string {
    let function_ptr = __DUCKDB_VALUE_STRING_INTERNAL
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> duckdb_string = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_BLOB: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_blob(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> duckdb_blob {
    let function_ptr = __DUCKDB_VALUE_BLOB.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> duckdb_blob = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_VALUE_IS_NULL: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_value_is_null(
    result: *mut duckdb_result,
    col: idx_t,
    row: idx_t,
) -> bool {
    let function_ptr = __DUCKDB_VALUE_IS_NULL
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: *mut duckdb_result,
        col: idx_t,
        row: idx_t,
    ) -> bool = ::std::mem::transmute(function_ptr);
    (fun)(result, col, row)
}

static __DUCKDB_EXECUTE_PREPARED_STREAMING: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_execute_prepared_streaming(
    prepared_statement: duckdb_prepared_statement,
    out_result: *mut duckdb_result,
) -> duckdb_state {
    let function_ptr = __DUCKDB_EXECUTE_PREPARED_STREAMING
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        out_result: *mut duckdb_result,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, out_result)
}

static __DUCKDB_PENDING_PREPARED_STREAMING: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_pending_prepared_streaming(
    prepared_statement: duckdb_prepared_statement,
    out_result: *mut duckdb_pending_result,
) -> duckdb_state {
    let function_ptr = __DUCKDB_PENDING_PREPARED_STREAMING
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        out_result: *mut duckdb_pending_result,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, out_result)
}

static __DUCKDB_COLUMN_HAS_DEFAULT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_column_has_default(
    table_description: duckdb_table_description,
    index: idx_t,
    out: *mut bool,
) -> duckdb_state {
    let function_ptr = __DUCKDB_COLUMN_HAS_DEFAULT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        table_description: duckdb_table_description,
        index: idx_t,
        out: *mut bool,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(table_description, index, out)
}

static __DUCKDB_QUERY_ARROW: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_query_arrow(
    connection: duckdb_connection,
    query: *const ::std::os::raw::c_char,
    out_result: *mut duckdb_arrow,
) -> duckdb_state {
    let function_ptr = __DUCKDB_QUERY_ARROW.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        connection: duckdb_connection,
        query: *const ::std::os::raw::c_char,
        out_result: *mut duckdb_arrow,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(connection, query, out_result)
}

static __DUCKDB_QUERY_ARROW_SCHEMA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_query_arrow_schema(
    result: duckdb_arrow,
    out_schema: *mut duckdb_arrow_schema,
) -> duckdb_state {
    let function_ptr = __DUCKDB_QUERY_ARROW_SCHEMA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: duckdb_arrow,
        out_schema: *mut duckdb_arrow_schema,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(result, out_schema)
}

static __DUCKDB_PREPARED_ARROW_SCHEMA: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_prepared_arrow_schema(
    prepared: duckdb_prepared_statement,
    out_schema: *mut duckdb_arrow_schema,
) -> duckdb_state {
    let function_ptr = __DUCKDB_PREPARED_ARROW_SCHEMA
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared: duckdb_prepared_statement,
        out_schema: *mut duckdb_arrow_schema,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared, out_schema)
}

static __DUCKDB_RESULT_ARROW_ARRAY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_result_arrow_array(
    result: duckdb_result,
    chunk: duckdb_data_chunk,
    out_array: *mut duckdb_arrow_array,
) {
    let function_ptr = __DUCKDB_RESULT_ARROW_ARRAY
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: duckdb_result,
        chunk: duckdb_data_chunk,
        out_array: *mut duckdb_arrow_array,
    ) = ::std::mem::transmute(function_ptr);
    (fun)(result, chunk, out_array)
}

static __DUCKDB_QUERY_ARROW_ARRAY: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_query_arrow_array(
    result: duckdb_arrow,
    out_array: *mut duckdb_arrow_array,
) -> duckdb_state {
    let function_ptr = __DUCKDB_QUERY_ARROW_ARRAY
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: duckdb_arrow,
        out_array: *mut duckdb_arrow_array,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(result, out_array)
}

static __DUCKDB_ARROW_COLUMN_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_arrow_column_count(result: duckdb_arrow) -> idx_t {
    let function_ptr = __DUCKDB_ARROW_COLUMN_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: duckdb_arrow) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_ARROW_ROW_COUNT: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_arrow_row_count(result: duckdb_arrow) -> idx_t {
    let function_ptr = __DUCKDB_ARROW_ROW_COUNT
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: duckdb_arrow) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_ARROW_ROWS_CHANGED: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_arrow_rows_changed(result: duckdb_arrow) -> idx_t {
    let function_ptr = __DUCKDB_ARROW_ROWS_CHANGED
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: duckdb_arrow) -> idx_t = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_QUERY_ARROW_ERROR: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_query_arrow_error(
    result: duckdb_arrow,
) -> *const ::std::os::raw::c_char {
    let function_ptr = __DUCKDB_QUERY_ARROW_ERROR
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        result: duckdb_arrow,
    ) -> *const ::std::os::raw::c_char = ::std::mem::transmute(function_ptr);
    (fun)(result)
}

static __DUCKDB_DESTROY_ARROW: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_arrow(result: *mut duckdb_arrow) {
    let function_ptr = __DUCKDB_DESTROY_ARROW
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: *mut duckdb_arrow) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

static __DUCKDB_DESTROY_ARROW_STREAM: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_destroy_arrow_stream(stream_p: *mut duckdb_arrow_stream) {
    let function_ptr = __DUCKDB_DESTROY_ARROW_STREAM
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(stream_p: *mut duckdb_arrow_stream) = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(stream_p)
}

static __DUCKDB_EXECUTE_PREPARED_ARROW: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_execute_prepared_arrow(
    prepared_statement: duckdb_prepared_statement,
    out_result: *mut duckdb_arrow,
) -> duckdb_state {
    let function_ptr = __DUCKDB_EXECUTE_PREPARED_ARROW
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        prepared_statement: duckdb_prepared_statement,
        out_result: *mut duckdb_arrow,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(prepared_statement, out_result)
}

static __DUCKDB_ARROW_SCAN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_arrow_scan(
    connection: duckdb_connection,
    table_name: *const ::std::os::raw::c_char,
    arrow: duckdb_arrow_stream,
) -> duckdb_state {
    let function_ptr = __DUCKDB_ARROW_SCAN.load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        connection: duckdb_connection,
        table_name: *const ::std::os::raw::c_char,
        arrow: duckdb_arrow_stream,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(connection, table_name, arrow)
}

static __DUCKDB_ARROW_ARRAY_SCAN: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_arrow_array_scan(
    connection: duckdb_connection,
    table_name: *const ::std::os::raw::c_char,
    arrow_schema: duckdb_arrow_schema,
    arrow_array: duckdb_arrow_array,
    out_stream: *mut duckdb_arrow_stream,
) -> duckdb_state {
    let function_ptr = __DUCKDB_ARROW_ARRAY_SCAN
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(
        connection: duckdb_connection,
        table_name: *const ::std::os::raw::c_char,
        arrow_schema: duckdb_arrow_schema,
        arrow_array: duckdb_arrow_array,
        out_stream: *mut duckdb_arrow_stream,
    ) -> duckdb_state = ::std::mem::transmute(function_ptr);
    (fun)(connection, table_name, arrow_schema, arrow_array, out_stream)
}

static __DUCKDB_STREAM_FETCH_CHUNK: ::std::sync::atomic::AtomicPtr<()> = ::std::sync::atomic::AtomicPtr::new(
    ::std::ptr::null_mut(),
);
pub unsafe fn duckdb_stream_fetch_chunk(result: duckdb_result) -> duckdb_data_chunk {
    let function_ptr = __DUCKDB_STREAM_FETCH_CHUNK
        .load(::std::sync::atomic::Ordering::Acquire);
    assert!(
        ! function_ptr.is_null(), "DuckDB API not initialized or DuckDB feature omitted"
    );
    let fun: unsafe extern "C" fn(result: duckdb_result) -> duckdb_data_chunk = ::std::mem::transmute(
        function_ptr,
    );
    (fun)(result)
}

/// Like DUCKDB_EXTENSION_API_INIT macro
pub unsafe fn duckdb_rs_extension_api_init(
    info: duckdb_extension_info,
    access: *const duckdb_extension_access,
    version: &str,
) -> ::std::result::Result<bool, &'static str> {
    let version_c_string = std::ffi::CString::new(version).unwrap();
    let p_api = (*access).get_api.unwrap()(info, version_c_string.as_ptr())
        as *const duckdb_ext_api_v0;
    if p_api.is_null() {
        return Ok(false);
    }
    if let Some(fun) = (*p_api).duckdb_open {
        __DUCKDB_OPEN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_open_ext {
        __DUCKDB_OPEN_EXT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_close {
        __DUCKDB_CLOSE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_connect {
        __DUCKDB_CONNECT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_interrupt {
        __DUCKDB_INTERRUPT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_query_progress {
        __DUCKDB_QUERY_PROGRESS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_disconnect {
        __DUCKDB_DISCONNECT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_library_version {
        __DUCKDB_LIBRARY_VERSION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_config {
        __DUCKDB_CREATE_CONFIG
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_config_count {
        __DUCKDB_CONFIG_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_config_flag {
        __DUCKDB_GET_CONFIG_FLAG
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_set_config {
        __DUCKDB_SET_CONFIG
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_config {
        __DUCKDB_DESTROY_CONFIG
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_query {
        __DUCKDB_QUERY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_result {
        __DUCKDB_DESTROY_RESULT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_column_name {
        __DUCKDB_COLUMN_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_column_type {
        __DUCKDB_COLUMN_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_result_statement_type {
        __DUCKDB_RESULT_STATEMENT_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_column_logical_type {
        __DUCKDB_COLUMN_LOGICAL_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_column_count {
        __DUCKDB_COLUMN_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_rows_changed {
        __DUCKDB_ROWS_CHANGED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_result_error {
        __DUCKDB_RESULT_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_malloc {
        __DUCKDB_MALLOC
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_free {
        __DUCKDB_FREE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_vector_size {
        __DUCKDB_VECTOR_SIZE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_string_is_inlined {
        __DUCKDB_STRING_IS_INLINED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_from_date {
        __DUCKDB_FROM_DATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_to_date {
        __DUCKDB_TO_DATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_is_finite_date {
        __DUCKDB_IS_FINITE_DATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_from_time {
        __DUCKDB_FROM_TIME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_time_tz {
        __DUCKDB_CREATE_TIME_TZ
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_from_time_tz {
        __DUCKDB_FROM_TIME_TZ
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_to_time {
        __DUCKDB_TO_TIME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_from_timestamp {
        __DUCKDB_FROM_TIMESTAMP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_to_timestamp {
        __DUCKDB_TO_TIMESTAMP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_is_finite_timestamp {
        __DUCKDB_IS_FINITE_TIMESTAMP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_hugeint_to_double {
        __DUCKDB_HUGEINT_TO_DOUBLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_double_to_hugeint {
        __DUCKDB_DOUBLE_TO_HUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_uhugeint_to_double {
        __DUCKDB_UHUGEINT_TO_DOUBLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_double_to_uhugeint {
        __DUCKDB_DOUBLE_TO_UHUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_double_to_decimal {
        __DUCKDB_DOUBLE_TO_DECIMAL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_decimal_to_double {
        __DUCKDB_DECIMAL_TO_DOUBLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_prepare {
        __DUCKDB_PREPARE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_prepare {
        __DUCKDB_DESTROY_PREPARE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_prepare_error {
        __DUCKDB_PREPARE_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_nparams {
        __DUCKDB_NPARAMS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_parameter_name {
        __DUCKDB_PARAMETER_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_param_type {
        __DUCKDB_PARAM_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_clear_bindings {
        __DUCKDB_CLEAR_BINDINGS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_prepared_statement_type {
        __DUCKDB_PREPARED_STATEMENT_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_value {
        __DUCKDB_BIND_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_parameter_index {
        __DUCKDB_BIND_PARAMETER_INDEX
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_boolean {
        __DUCKDB_BIND_BOOLEAN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_int8 {
        __DUCKDB_BIND_INT8
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_int16 {
        __DUCKDB_BIND_INT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_int32 {
        __DUCKDB_BIND_INT32
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_int64 {
        __DUCKDB_BIND_INT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_hugeint {
        __DUCKDB_BIND_HUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_uhugeint {
        __DUCKDB_BIND_UHUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_decimal {
        __DUCKDB_BIND_DECIMAL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_uint8 {
        __DUCKDB_BIND_UINT8
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_uint16 {
        __DUCKDB_BIND_UINT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_uint32 {
        __DUCKDB_BIND_UINT32
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_uint64 {
        __DUCKDB_BIND_UINT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_float {
        __DUCKDB_BIND_FLOAT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_double {
        __DUCKDB_BIND_DOUBLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_date {
        __DUCKDB_BIND_DATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_time {
        __DUCKDB_BIND_TIME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_timestamp {
        __DUCKDB_BIND_TIMESTAMP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_timestamp_tz {
        __DUCKDB_BIND_TIMESTAMP_TZ
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_interval {
        __DUCKDB_BIND_INTERVAL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_varchar {
        __DUCKDB_BIND_VARCHAR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_varchar_length {
        __DUCKDB_BIND_VARCHAR_LENGTH
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_blob {
        __DUCKDB_BIND_BLOB
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_null {
        __DUCKDB_BIND_NULL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_execute_prepared {
        __DUCKDB_EXECUTE_PREPARED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_extract_statements {
        __DUCKDB_EXTRACT_STATEMENTS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_prepare_extracted_statement {
        __DUCKDB_PREPARE_EXTRACTED_STATEMENT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_extract_statements_error {
        __DUCKDB_EXTRACT_STATEMENTS_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_extracted {
        __DUCKDB_DESTROY_EXTRACTED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_pending_prepared {
        __DUCKDB_PENDING_PREPARED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_pending {
        __DUCKDB_DESTROY_PENDING
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_pending_error {
        __DUCKDB_PENDING_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_pending_execute_task {
        __DUCKDB_PENDING_EXECUTE_TASK
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_pending_execute_check_state {
        __DUCKDB_PENDING_EXECUTE_CHECK_STATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_execute_pending {
        __DUCKDB_EXECUTE_PENDING
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_pending_execution_is_finished {
        __DUCKDB_PENDING_EXECUTION_IS_FINISHED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_value {
        __DUCKDB_DESTROY_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_varchar {
        __DUCKDB_CREATE_VARCHAR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_varchar_length {
        __DUCKDB_CREATE_VARCHAR_LENGTH
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_int64 {
        __DUCKDB_CREATE_INT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_struct_value {
        __DUCKDB_CREATE_STRUCT_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_list_value {
        __DUCKDB_CREATE_LIST_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_array_value {
        __DUCKDB_CREATE_ARRAY_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_varchar {
        __DUCKDB_GET_VARCHAR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_int64 {
        __DUCKDB_GET_INT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_logical_type {
        __DUCKDB_CREATE_LOGICAL_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_logical_type_get_alias {
        __DUCKDB_LOGICAL_TYPE_GET_ALIAS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_list_type {
        __DUCKDB_CREATE_LIST_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_array_type {
        __DUCKDB_CREATE_ARRAY_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_map_type {
        __DUCKDB_CREATE_MAP_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_union_type {
        __DUCKDB_CREATE_UNION_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_struct_type {
        __DUCKDB_CREATE_STRUCT_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_enum_type {
        __DUCKDB_CREATE_ENUM_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_decimal_type {
        __DUCKDB_CREATE_DECIMAL_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_type_id {
        __DUCKDB_GET_TYPE_ID
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_decimal_width {
        __DUCKDB_DECIMAL_WIDTH
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_decimal_scale {
        __DUCKDB_DECIMAL_SCALE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_decimal_internal_type {
        __DUCKDB_DECIMAL_INTERNAL_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_enum_internal_type {
        __DUCKDB_ENUM_INTERNAL_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_enum_dictionary_size {
        __DUCKDB_ENUM_DICTIONARY_SIZE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_enum_dictionary_value {
        __DUCKDB_ENUM_DICTIONARY_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_list_type_child_type {
        __DUCKDB_LIST_TYPE_CHILD_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_array_type_child_type {
        __DUCKDB_ARRAY_TYPE_CHILD_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_array_type_array_size {
        __DUCKDB_ARRAY_TYPE_ARRAY_SIZE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_map_type_key_type {
        __DUCKDB_MAP_TYPE_KEY_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_map_type_value_type {
        __DUCKDB_MAP_TYPE_VALUE_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_struct_type_child_count {
        __DUCKDB_STRUCT_TYPE_CHILD_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_struct_type_child_name {
        __DUCKDB_STRUCT_TYPE_CHILD_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_struct_type_child_type {
        __DUCKDB_STRUCT_TYPE_CHILD_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_union_type_member_count {
        __DUCKDB_UNION_TYPE_MEMBER_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_union_type_member_name {
        __DUCKDB_UNION_TYPE_MEMBER_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_union_type_member_type {
        __DUCKDB_UNION_TYPE_MEMBER_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_logical_type {
        __DUCKDB_DESTROY_LOGICAL_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_fetch_chunk {
        __DUCKDB_FETCH_CHUNK
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_data_chunk {
        __DUCKDB_CREATE_DATA_CHUNK
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_data_chunk {
        __DUCKDB_DESTROY_DATA_CHUNK
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_data_chunk_reset {
        __DUCKDB_DATA_CHUNK_RESET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_data_chunk_get_column_count {
        __DUCKDB_DATA_CHUNK_GET_COLUMN_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_data_chunk_get_vector {
        __DUCKDB_DATA_CHUNK_GET_VECTOR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_data_chunk_get_size {
        __DUCKDB_DATA_CHUNK_GET_SIZE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_data_chunk_set_size {
        __DUCKDB_DATA_CHUNK_SET_SIZE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_vector_get_column_type {
        __DUCKDB_VECTOR_GET_COLUMN_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_vector_get_data {
        __DUCKDB_VECTOR_GET_DATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_vector_get_validity {
        __DUCKDB_VECTOR_GET_VALIDITY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_vector_ensure_validity_writable {
        __DUCKDB_VECTOR_ENSURE_VALIDITY_WRITABLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_vector_assign_string_element {
        __DUCKDB_VECTOR_ASSIGN_STRING_ELEMENT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_vector_assign_string_element_len {
        __DUCKDB_VECTOR_ASSIGN_STRING_ELEMENT_LEN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_list_vector_get_child {
        __DUCKDB_LIST_VECTOR_GET_CHILD
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_list_vector_get_size {
        __DUCKDB_LIST_VECTOR_GET_SIZE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_list_vector_set_size {
        __DUCKDB_LIST_VECTOR_SET_SIZE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_list_vector_reserve {
        __DUCKDB_LIST_VECTOR_RESERVE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_struct_vector_get_child {
        __DUCKDB_STRUCT_VECTOR_GET_CHILD
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_array_vector_get_child {
        __DUCKDB_ARRAY_VECTOR_GET_CHILD
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_validity_row_is_valid {
        __DUCKDB_VALIDITY_ROW_IS_VALID
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_validity_set_row_validity {
        __DUCKDB_VALIDITY_SET_ROW_VALIDITY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_validity_set_row_invalid {
        __DUCKDB_VALIDITY_SET_ROW_INVALID
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_validity_set_row_valid {
        __DUCKDB_VALIDITY_SET_ROW_VALID
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_scalar_function {
        __DUCKDB_CREATE_SCALAR_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_scalar_function {
        __DUCKDB_DESTROY_SCALAR_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_set_name {
        __DUCKDB_SCALAR_FUNCTION_SET_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_add_parameter {
        __DUCKDB_SCALAR_FUNCTION_ADD_PARAMETER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_set_return_type {
        __DUCKDB_SCALAR_FUNCTION_SET_RETURN_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_set_extra_info {
        __DUCKDB_SCALAR_FUNCTION_SET_EXTRA_INFO
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_set_function {
        __DUCKDB_SCALAR_FUNCTION_SET_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_register_scalar_function {
        __DUCKDB_REGISTER_SCALAR_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_table_function {
        __DUCKDB_CREATE_TABLE_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_table_function {
        __DUCKDB_DESTROY_TABLE_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_function_set_name {
        __DUCKDB_TABLE_FUNCTION_SET_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_function_add_parameter {
        __DUCKDB_TABLE_FUNCTION_ADD_PARAMETER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_function_add_named_parameter {
        __DUCKDB_TABLE_FUNCTION_ADD_NAMED_PARAMETER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_function_set_extra_info {
        __DUCKDB_TABLE_FUNCTION_SET_EXTRA_INFO
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_function_set_bind {
        __DUCKDB_TABLE_FUNCTION_SET_BIND
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_function_set_init {
        __DUCKDB_TABLE_FUNCTION_SET_INIT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_function_set_local_init {
        __DUCKDB_TABLE_FUNCTION_SET_LOCAL_INIT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_function_set_function {
        __DUCKDB_TABLE_FUNCTION_SET_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_function_supports_projection_pushdown {
        __DUCKDB_TABLE_FUNCTION_SUPPORTS_PROJECTION_PUSHDOWN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_register_table_function {
        __DUCKDB_REGISTER_TABLE_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_get_extra_info {
        __DUCKDB_BIND_GET_EXTRA_INFO
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_add_result_column {
        __DUCKDB_BIND_ADD_RESULT_COLUMN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_get_parameter_count {
        __DUCKDB_BIND_GET_PARAMETER_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_get_parameter {
        __DUCKDB_BIND_GET_PARAMETER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_get_named_parameter {
        __DUCKDB_BIND_GET_NAMED_PARAMETER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_set_bind_data {
        __DUCKDB_BIND_SET_BIND_DATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_set_cardinality {
        __DUCKDB_BIND_SET_CARDINALITY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_bind_set_error {
        __DUCKDB_BIND_SET_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_init_get_extra_info {
        __DUCKDB_INIT_GET_EXTRA_INFO
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_init_get_bind_data {
        __DUCKDB_INIT_GET_BIND_DATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_init_set_init_data {
        __DUCKDB_INIT_SET_INIT_DATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_init_get_column_count {
        __DUCKDB_INIT_GET_COLUMN_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_init_get_column_index {
        __DUCKDB_INIT_GET_COLUMN_INDEX
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_init_set_max_threads {
        __DUCKDB_INIT_SET_MAX_THREADS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_init_set_error {
        __DUCKDB_INIT_SET_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_function_get_extra_info {
        __DUCKDB_FUNCTION_GET_EXTRA_INFO
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_function_get_bind_data {
        __DUCKDB_FUNCTION_GET_BIND_DATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_function_get_init_data {
        __DUCKDB_FUNCTION_GET_INIT_DATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_function_get_local_init_data {
        __DUCKDB_FUNCTION_GET_LOCAL_INIT_DATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_function_set_error {
        __DUCKDB_FUNCTION_SET_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_add_replacement_scan {
        __DUCKDB_ADD_REPLACEMENT_SCAN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_replacement_scan_set_function_name {
        __DUCKDB_REPLACEMENT_SCAN_SET_FUNCTION_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_replacement_scan_add_parameter {
        __DUCKDB_REPLACEMENT_SCAN_ADD_PARAMETER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_replacement_scan_set_error {
        __DUCKDB_REPLACEMENT_SCAN_SET_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_appender_create {
        __DUCKDB_APPENDER_CREATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_appender_column_count {
        __DUCKDB_APPENDER_COLUMN_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_appender_column_type {
        __DUCKDB_APPENDER_COLUMN_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_appender_error {
        __DUCKDB_APPENDER_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_appender_flush {
        __DUCKDB_APPENDER_FLUSH
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_appender_close {
        __DUCKDB_APPENDER_CLOSE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_appender_destroy {
        __DUCKDB_APPENDER_DESTROY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_appender_begin_row {
        __DUCKDB_APPENDER_BEGIN_ROW
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_appender_end_row {
        __DUCKDB_APPENDER_END_ROW
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_default {
        __DUCKDB_APPEND_DEFAULT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_bool {
        __DUCKDB_APPEND_BOOL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_int8 {
        __DUCKDB_APPEND_INT8
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_int16 {
        __DUCKDB_APPEND_INT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_int32 {
        __DUCKDB_APPEND_INT32
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_int64 {
        __DUCKDB_APPEND_INT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_hugeint {
        __DUCKDB_APPEND_HUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_uint8 {
        __DUCKDB_APPEND_UINT8
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_uint16 {
        __DUCKDB_APPEND_UINT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_uint32 {
        __DUCKDB_APPEND_UINT32
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_uint64 {
        __DUCKDB_APPEND_UINT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_uhugeint {
        __DUCKDB_APPEND_UHUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_float {
        __DUCKDB_APPEND_FLOAT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_double {
        __DUCKDB_APPEND_DOUBLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_date {
        __DUCKDB_APPEND_DATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_time {
        __DUCKDB_APPEND_TIME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_timestamp {
        __DUCKDB_APPEND_TIMESTAMP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_interval {
        __DUCKDB_APPEND_INTERVAL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_varchar {
        __DUCKDB_APPEND_VARCHAR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_varchar_length {
        __DUCKDB_APPEND_VARCHAR_LENGTH
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_blob {
        __DUCKDB_APPEND_BLOB
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_null {
        __DUCKDB_APPEND_NULL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_append_data_chunk {
        __DUCKDB_APPEND_DATA_CHUNK
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_execute_tasks {
        __DUCKDB_EXECUTE_TASKS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_task_state {
        __DUCKDB_CREATE_TASK_STATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_execute_tasks_state {
        __DUCKDB_EXECUTE_TASKS_STATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_execute_n_tasks_state {
        __DUCKDB_EXECUTE_N_TASKS_STATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_finish_execution {
        __DUCKDB_FINISH_EXECUTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_task_state_is_finished {
        __DUCKDB_TASK_STATE_IS_FINISHED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_task_state {
        __DUCKDB_DESTROY_TASK_STATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_execution_is_finished {
        __DUCKDB_EXECUTION_IS_FINISHED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_profiling_info {
        __DUCKDB_GET_PROFILING_INFO
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_profiling_info_get_value {
        __DUCKDB_PROFILING_INFO_GET_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_profiling_info_get_child_count {
        __DUCKDB_PROFILING_INFO_GET_CHILD_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_profiling_info_get_child {
        __DUCKDB_PROFILING_INFO_GET_CHILD
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_profiling_info_get_metrics {
        __DUCKDB_PROFILING_INFO_GET_METRICS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_set_varargs {
        __DUCKDB_SCALAR_FUNCTION_SET_VARARGS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_set_special_handling {
        __DUCKDB_SCALAR_FUNCTION_SET_SPECIAL_HANDLING
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_set_volatile {
        __DUCKDB_SCALAR_FUNCTION_SET_VOLATILE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_get_extra_info {
        __DUCKDB_SCALAR_FUNCTION_GET_EXTRA_INFO
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_scalar_function_set_error {
        __DUCKDB_SCALAR_FUNCTION_SET_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_description_create {
        __DUCKDB_TABLE_DESCRIPTION_CREATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_description_destroy {
        __DUCKDB_TABLE_DESCRIPTION_DESTROY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_table_description_error {
        __DUCKDB_TABLE_DESCRIPTION_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_result_error_type {
        __DUCKDB_RESULT_ERROR_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_string_t_length {
        __DUCKDB_STRING_T_LENGTH
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_string_t_data {
        __DUCKDB_STRING_T_DATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_bool {
        __DUCKDB_CREATE_BOOL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_int8 {
        __DUCKDB_CREATE_INT8
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_uint8 {
        __DUCKDB_CREATE_UINT8
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_int16 {
        __DUCKDB_CREATE_INT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_uint16 {
        __DUCKDB_CREATE_UINT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_int32 {
        __DUCKDB_CREATE_INT32
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_uint32 {
        __DUCKDB_CREATE_UINT32
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_uint64 {
        __DUCKDB_CREATE_UINT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_hugeint {
        __DUCKDB_CREATE_HUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_uhugeint {
        __DUCKDB_CREATE_UHUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_float {
        __DUCKDB_CREATE_FLOAT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_double {
        __DUCKDB_CREATE_DOUBLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_date {
        __DUCKDB_CREATE_DATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_time {
        __DUCKDB_CREATE_TIME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_time_tz_value {
        __DUCKDB_CREATE_TIME_TZ_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_timestamp {
        __DUCKDB_CREATE_TIMESTAMP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_interval {
        __DUCKDB_CREATE_INTERVAL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_blob {
        __DUCKDB_CREATE_BLOB
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_bool {
        __DUCKDB_GET_BOOL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_int8 {
        __DUCKDB_GET_INT8
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_uint8 {
        __DUCKDB_GET_UINT8
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_int16 {
        __DUCKDB_GET_INT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_uint16 {
        __DUCKDB_GET_UINT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_int32 {
        __DUCKDB_GET_INT32
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_uint32 {
        __DUCKDB_GET_UINT32
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_uint64 {
        __DUCKDB_GET_UINT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_hugeint {
        __DUCKDB_GET_HUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_uhugeint {
        __DUCKDB_GET_UHUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_float {
        __DUCKDB_GET_FLOAT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_double {
        __DUCKDB_GET_DOUBLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_date {
        __DUCKDB_GET_DATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_time {
        __DUCKDB_GET_TIME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_time_tz {
        __DUCKDB_GET_TIME_TZ
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_timestamp {
        __DUCKDB_GET_TIMESTAMP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_interval {
        __DUCKDB_GET_INTERVAL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_value_type {
        __DUCKDB_GET_VALUE_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_blob {
        __DUCKDB_GET_BLOB
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_scalar_function_set {
        __DUCKDB_CREATE_SCALAR_FUNCTION_SET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_scalar_function_set {
        __DUCKDB_DESTROY_SCALAR_FUNCTION_SET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_add_scalar_function_to_set {
        __DUCKDB_ADD_SCALAR_FUNCTION_TO_SET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_register_scalar_function_set {
        __DUCKDB_REGISTER_SCALAR_FUNCTION_SET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_aggregate_function_set {
        __DUCKDB_CREATE_AGGREGATE_FUNCTION_SET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_aggregate_function_set {
        __DUCKDB_DESTROY_AGGREGATE_FUNCTION_SET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_add_aggregate_function_to_set {
        __DUCKDB_ADD_AGGREGATE_FUNCTION_TO_SET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_register_aggregate_function_set {
        __DUCKDB_REGISTER_AGGREGATE_FUNCTION_SET
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_map_size {
        __DUCKDB_GET_MAP_SIZE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_map_key {
        __DUCKDB_GET_MAP_KEY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_get_map_value {
        __DUCKDB_GET_MAP_VALUE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_aggregate_function {
        __DUCKDB_CREATE_AGGREGATE_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_aggregate_function {
        __DUCKDB_DESTROY_AGGREGATE_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_aggregate_function_set_name {
        __DUCKDB_AGGREGATE_FUNCTION_SET_NAME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_aggregate_function_add_parameter {
        __DUCKDB_AGGREGATE_FUNCTION_ADD_PARAMETER
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_aggregate_function_set_return_type {
        __DUCKDB_AGGREGATE_FUNCTION_SET_RETURN_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_aggregate_function_set_functions {
        __DUCKDB_AGGREGATE_FUNCTION_SET_FUNCTIONS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_aggregate_function_set_destructor {
        __DUCKDB_AGGREGATE_FUNCTION_SET_DESTRUCTOR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_register_aggregate_function {
        __DUCKDB_REGISTER_AGGREGATE_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_aggregate_function_set_special_handling {
        __DUCKDB_AGGREGATE_FUNCTION_SET_SPECIAL_HANDLING
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_aggregate_function_set_extra_info {
        __DUCKDB_AGGREGATE_FUNCTION_SET_EXTRA_INFO
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_aggregate_function_get_extra_info {
        __DUCKDB_AGGREGATE_FUNCTION_GET_EXTRA_INFO
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_aggregate_function_set_error {
        __DUCKDB_AGGREGATE_FUNCTION_SET_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_logical_type_set_alias {
        __DUCKDB_LOGICAL_TYPE_SET_ALIAS
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_register_logical_type {
        __DUCKDB_REGISTER_LOGICAL_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_create_cast_function {
        __DUCKDB_CREATE_CAST_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_cast_function_set_source_type {
        __DUCKDB_CAST_FUNCTION_SET_SOURCE_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_cast_function_set_target_type {
        __DUCKDB_CAST_FUNCTION_SET_TARGET_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_cast_function_set_implicit_cast_cost {
        __DUCKDB_CAST_FUNCTION_SET_IMPLICIT_CAST_COST
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_cast_function_set_function {
        __DUCKDB_CAST_FUNCTION_SET_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_cast_function_set_extra_info {
        __DUCKDB_CAST_FUNCTION_SET_EXTRA_INFO
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_cast_function_get_extra_info {
        __DUCKDB_CAST_FUNCTION_GET_EXTRA_INFO
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_cast_function_get_cast_mode {
        __DUCKDB_CAST_FUNCTION_GET_CAST_MODE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_cast_function_set_error {
        __DUCKDB_CAST_FUNCTION_SET_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_cast_function_set_row_error {
        __DUCKDB_CAST_FUNCTION_SET_ROW_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_register_cast_function {
        __DUCKDB_REGISTER_CAST_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_cast_function {
        __DUCKDB_DESTROY_CAST_FUNCTION
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_row_count {
        __DUCKDB_ROW_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_column_data {
        __DUCKDB_COLUMN_DATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_nullmask_data {
        __DUCKDB_NULLMASK_DATA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_result_get_chunk {
        __DUCKDB_RESULT_GET_CHUNK
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_result_is_streaming {
        __DUCKDB_RESULT_IS_STREAMING
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_result_chunk_count {
        __DUCKDB_RESULT_CHUNK_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_result_return_type {
        __DUCKDB_RESULT_RETURN_TYPE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_boolean {
        __DUCKDB_VALUE_BOOLEAN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_int8 {
        __DUCKDB_VALUE_INT8
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_int16 {
        __DUCKDB_VALUE_INT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_int32 {
        __DUCKDB_VALUE_INT32
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_int64 {
        __DUCKDB_VALUE_INT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_hugeint {
        __DUCKDB_VALUE_HUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_uhugeint {
        __DUCKDB_VALUE_UHUGEINT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_decimal {
        __DUCKDB_VALUE_DECIMAL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_uint8 {
        __DUCKDB_VALUE_UINT8
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_uint16 {
        __DUCKDB_VALUE_UINT16
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_uint32 {
        __DUCKDB_VALUE_UINT32
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_uint64 {
        __DUCKDB_VALUE_UINT64
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_float {
        __DUCKDB_VALUE_FLOAT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_double {
        __DUCKDB_VALUE_DOUBLE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_date {
        __DUCKDB_VALUE_DATE
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_time {
        __DUCKDB_VALUE_TIME
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_timestamp {
        __DUCKDB_VALUE_TIMESTAMP
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_interval {
        __DUCKDB_VALUE_INTERVAL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_varchar {
        __DUCKDB_VALUE_VARCHAR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_string {
        __DUCKDB_VALUE_STRING
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_varchar_internal {
        __DUCKDB_VALUE_VARCHAR_INTERNAL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_string_internal {
        __DUCKDB_VALUE_STRING_INTERNAL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_blob {
        __DUCKDB_VALUE_BLOB
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_value_is_null {
        __DUCKDB_VALUE_IS_NULL
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_execute_prepared_streaming {
        __DUCKDB_EXECUTE_PREPARED_STREAMING
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_pending_prepared_streaming {
        __DUCKDB_PENDING_PREPARED_STREAMING
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_column_has_default {
        __DUCKDB_COLUMN_HAS_DEFAULT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_query_arrow {
        __DUCKDB_QUERY_ARROW
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_query_arrow_schema {
        __DUCKDB_QUERY_ARROW_SCHEMA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_prepared_arrow_schema {
        __DUCKDB_PREPARED_ARROW_SCHEMA
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_result_arrow_array {
        __DUCKDB_RESULT_ARROW_ARRAY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_query_arrow_array {
        __DUCKDB_QUERY_ARROW_ARRAY
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_arrow_column_count {
        __DUCKDB_ARROW_COLUMN_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_arrow_row_count {
        __DUCKDB_ARROW_ROW_COUNT
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_arrow_rows_changed {
        __DUCKDB_ARROW_ROWS_CHANGED
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_query_arrow_error {
        __DUCKDB_QUERY_ARROW_ERROR
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_arrow {
        __DUCKDB_DESTROY_ARROW
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_destroy_arrow_stream {
        __DUCKDB_DESTROY_ARROW_STREAM
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_execute_prepared_arrow {
        __DUCKDB_EXECUTE_PREPARED_ARROW
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_arrow_scan {
        __DUCKDB_ARROW_SCAN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_arrow_array_scan {
        __DUCKDB_ARROW_ARRAY_SCAN
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    if let Some(fun) = (*p_api).duckdb_stream_fetch_chunk {
        __DUCKDB_STREAM_FETCH_CHUNK
            .store(fun as usize as *mut (), ::std::sync::atomic::Ordering::Release);
    }
    Ok(true)
}

